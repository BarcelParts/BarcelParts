{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compareTopologyVersion = exports.parseServerType = exports.ServerDescription = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst utils_1 = require(\"../utils\");\n\nconst common_1 = require(\"./common\");\n\nconst WRITABLE_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.Standalone, common_1.ServerType.Mongos, common_1.ServerType.LoadBalancer]);\nconst DATA_BEARING_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.RSSecondary, common_1.ServerType.Mongos, common_1.ServerType.Standalone, common_1.ServerType.LoadBalancer]);\n/**\n * The client's view of a single server, based on the most recent hello outcome.\n *\n * Internal type, not meant to be directly instantiated\n * @public\n */\n\nclass ServerDescription {\n  /**\n   * Create a ServerDescription\n   * @internal\n   *\n   * @param address - The address of the server\n   * @param hello - An optional hello response for this server\n   */\n  constructor(address, hello, options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n\n    if (typeof address === 'string') {\n      this._hostAddress = new utils_1.HostAddress(address);\n      this.address = this._hostAddress.toString();\n    } else {\n      this._hostAddress = address;\n      this.address = this._hostAddress.toString();\n    }\n\n    this.type = parseServerType(hello, options);\n    this.hosts = (_b = (_a = hello === null || hello === void 0 ? void 0 : hello.hosts) === null || _a === void 0 ? void 0 : _a.map(host => host.toLowerCase())) !== null && _b !== void 0 ? _b : [];\n    this.passives = (_d = (_c = hello === null || hello === void 0 ? void 0 : hello.passives) === null || _c === void 0 ? void 0 : _c.map(host => host.toLowerCase())) !== null && _d !== void 0 ? _d : [];\n    this.arbiters = (_f = (_e = hello === null || hello === void 0 ? void 0 : hello.arbiters) === null || _e === void 0 ? void 0 : _e.map(host => host.toLowerCase())) !== null && _f !== void 0 ? _f : [];\n    this.tags = (_g = hello === null || hello === void 0 ? void 0 : hello.tags) !== null && _g !== void 0 ? _g : {};\n    this.minWireVersion = (_h = hello === null || hello === void 0 ? void 0 : hello.minWireVersion) !== null && _h !== void 0 ? _h : 0;\n    this.maxWireVersion = (_j = hello === null || hello === void 0 ? void 0 : hello.maxWireVersion) !== null && _j !== void 0 ? _j : 0;\n    this.roundTripTime = (_k = options === null || options === void 0 ? void 0 : options.roundTripTime) !== null && _k !== void 0 ? _k : -1;\n    this.lastUpdateTime = (0, utils_1.now)();\n    this.lastWriteDate = (_m = (_l = hello === null || hello === void 0 ? void 0 : hello.lastWrite) === null || _l === void 0 ? void 0 : _l.lastWriteDate) !== null && _m !== void 0 ? _m : 0;\n\n    if (options === null || options === void 0 ? void 0 : options.topologyVersion) {\n      this.topologyVersion = options.topologyVersion;\n    } else if (hello === null || hello === void 0 ? void 0 : hello.topologyVersion) {\n      this.topologyVersion = hello.topologyVersion;\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.error) {\n      this.error = options.error;\n    }\n\n    if (hello === null || hello === void 0 ? void 0 : hello.primary) {\n      this.primary = hello.primary;\n    }\n\n    if (hello === null || hello === void 0 ? void 0 : hello.me) {\n      this.me = hello.me.toLowerCase();\n    }\n\n    if (hello === null || hello === void 0 ? void 0 : hello.setName) {\n      this.setName = hello.setName;\n    }\n\n    if (hello === null || hello === void 0 ? void 0 : hello.setVersion) {\n      this.setVersion = hello.setVersion;\n    }\n\n    if (hello === null || hello === void 0 ? void 0 : hello.electionId) {\n      this.electionId = hello.electionId;\n    }\n\n    if (hello === null || hello === void 0 ? void 0 : hello.logicalSessionTimeoutMinutes) {\n      this.logicalSessionTimeoutMinutes = hello.logicalSessionTimeoutMinutes;\n    }\n\n    if (hello === null || hello === void 0 ? void 0 : hello.$clusterTime) {\n      this.$clusterTime = hello.$clusterTime;\n    }\n  }\n\n  get hostAddress() {\n    if (this._hostAddress) return this._hostAddress;else return new utils_1.HostAddress(this.address);\n  }\n\n  get allHosts() {\n    return this.hosts.concat(this.arbiters).concat(this.passives);\n  }\n  /** Is this server available for reads*/\n\n\n  get isReadable() {\n    return this.type === common_1.ServerType.RSSecondary || this.isWritable;\n  }\n  /** Is this server data bearing */\n\n\n  get isDataBearing() {\n    return DATA_BEARING_SERVER_TYPES.has(this.type);\n  }\n  /** Is this server available for writes */\n\n\n  get isWritable() {\n    return WRITABLE_SERVER_TYPES.has(this.type);\n  }\n\n  get host() {\n    const chopLength = `:${this.port}`.length;\n    return this.address.slice(0, -chopLength);\n  }\n\n  get port() {\n    const port = this.address.split(':').pop();\n    return port ? Number.parseInt(port, 10) : 27017;\n  }\n  /**\n   * Determines if another `ServerDescription` is equal to this one per the rules defined\n   * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}\n   */\n\n\n  equals(other) {\n    const topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;\n    const electionIdsEqual = this.electionId && other.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId;\n    return other != null && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;\n  }\n\n}\n\nexports.ServerDescription = ServerDescription; // Parses a `hello` message and determines the server type\n\nfunction parseServerType(hello, options) {\n  if (options === null || options === void 0 ? void 0 : options.loadBalanced) {\n    return common_1.ServerType.LoadBalancer;\n  }\n\n  if (!hello || !hello.ok) {\n    return common_1.ServerType.Unknown;\n  }\n\n  if (hello.isreplicaset) {\n    return common_1.ServerType.RSGhost;\n  }\n\n  if (hello.msg && hello.msg === 'isdbgrid') {\n    return common_1.ServerType.Mongos;\n  }\n\n  if (hello.setName) {\n    if (hello.hidden) {\n      return common_1.ServerType.RSOther;\n    } else if (hello.isWritablePrimary) {\n      return common_1.ServerType.RSPrimary;\n    } else if (hello.secondary) {\n      return common_1.ServerType.RSSecondary;\n    } else if (hello.arbiterOnly) {\n      return common_1.ServerType.RSArbiter;\n    } else {\n      return common_1.ServerType.RSOther;\n    }\n  }\n\n  return common_1.ServerType.Standalone;\n}\n\nexports.parseServerType = parseServerType;\n\nfunction tagsStrictEqual(tags, tags2) {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(key => tags2[key] === tags[key]);\n}\n/**\n * Compares two topology versions.\n *\n * @returns A negative number if `lhs` is older than `rhs`; positive if `lhs` is newer than `rhs`; 0 if they are equivalent.\n */\n\n\nfunction compareTopologyVersion(lhs, rhs) {\n  if (lhs == null || rhs == null) {\n    return -1;\n  }\n\n  if (lhs.processId.equals(rhs.processId)) {\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    const lhsCounter = bson_1.Long.isLong(lhs.counter) ? lhs.counter : bson_1.Long.fromNumber(lhs.counter);\n    const rhsCounter = bson_1.Long.isLong(rhs.counter) ? lhs.counter : bson_1.Long.fromNumber(rhs.counter);\n    return lhsCounter.compare(rhsCounter);\n  }\n\n  return -1;\n}\n\nexports.compareTopologyVersion = compareTopologyVersion;","map":{"version":3,"mappings":"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","names":["WRITABLE_SERVER_TYPES","Set","common_1","RSPrimary","Standalone","Mongos","LoadBalancer","DATA_BEARING_SERVER_TYPES","RSSecondary","ServerDescription","constructor","address","hello","options","_hostAddress","utils_1","toString","type","parseServerType","hosts","_a","map","host","toLowerCase","_b","passives","_c","_d","arbiters","_e","_f","tags","_g","minWireVersion","_h","maxWireVersion","_j","roundTripTime","_k","lastUpdateTime","lastWriteDate","lastWrite","_l","_m","topologyVersion","error","primary","me","setName","setVersion","electionId","logicalSessionTimeoutMinutes","$clusterTime","hostAddress","allHosts","concat","isReadable","isWritable","isDataBearing","has","chopLength","port","length","slice","split","pop","Number","parseInt","equals","other","topologyVersionsEqual","compareTopologyVersion","electionIdsEqual","tagsStrictEqual","exports","loadBalanced","ok","Unknown","isreplicaset","RSGhost","msg","hidden","RSOther","isWritablePrimary","secondary","arbiterOnly","RSArbiter","tags2","tagsKeys","Object","keys","tags2Keys","every","key","lhs","rhs","processId","lhsCounter","bson_1","isLong","counter","fromNumber","rhsCounter","compare"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\sdam\\server_description.ts"],"sourcesContent":["import { Document, Long, ObjectId } from '../bson';\nimport type { MongoError } from '../error';\nimport { arrayStrictEqual, errorStrictEqual, HostAddress, now } from '../utils';\nimport type { ClusterTime } from './common';\nimport { ServerType } from './common';\n\nconst WRITABLE_SERVER_TYPES = new Set<ServerType>([\n  ServerType.RSPrimary,\n  ServerType.Standalone,\n  ServerType.Mongos,\n  ServerType.LoadBalancer\n]);\n\nconst DATA_BEARING_SERVER_TYPES = new Set<ServerType>([\n  ServerType.RSPrimary,\n  ServerType.RSSecondary,\n  ServerType.Mongos,\n  ServerType.Standalone,\n  ServerType.LoadBalancer\n]);\n\n/** @public */\nexport interface TopologyVersion {\n  processId: ObjectId;\n  counter: Long;\n}\n\n/** @public */\nexport type TagSet = { [key: string]: string };\n\n/** @internal */\nexport interface ServerDescriptionOptions {\n  /** An Error used for better reporting debugging */\n  error?: MongoError;\n\n  /** The round trip time to ping this server (in ms) */\n  roundTripTime?: number;\n\n  /** The topologyVersion */\n  topologyVersion?: TopologyVersion;\n\n  /** If the client is in load balancing mode. */\n  loadBalanced?: boolean;\n}\n\n/**\n * The client's view of a single server, based on the most recent hello outcome.\n *\n * Internal type, not meant to be directly instantiated\n * @public\n */\nexport class ServerDescription {\n  private _hostAddress: HostAddress;\n  address: string;\n  type: ServerType;\n  hosts: string[];\n  passives: string[];\n  arbiters: string[];\n  tags: TagSet;\n\n  error?: MongoError;\n  topologyVersion?: TopologyVersion;\n  minWireVersion: number;\n  maxWireVersion: number;\n  roundTripTime: number;\n  lastUpdateTime: number;\n  lastWriteDate: number;\n\n  me?: string;\n  primary?: string;\n  setName?: string;\n  setVersion?: number;\n  electionId?: ObjectId;\n  logicalSessionTimeoutMinutes?: number;\n\n  // NOTE: does this belong here? It seems we should gossip the cluster time at the CMAP level\n  $clusterTime?: ClusterTime;\n\n  /**\n   * Create a ServerDescription\n   * @internal\n   *\n   * @param address - The address of the server\n   * @param hello - An optional hello response for this server\n   */\n  constructor(address: HostAddress | string, hello?: Document, options?: ServerDescriptionOptions) {\n    if (typeof address === 'string') {\n      this._hostAddress = new HostAddress(address);\n      this.address = this._hostAddress.toString();\n    } else {\n      this._hostAddress = address;\n      this.address = this._hostAddress.toString();\n    }\n    this.type = parseServerType(hello, options);\n    this.hosts = hello?.hosts?.map((host: string) => host.toLowerCase()) ?? [];\n    this.passives = hello?.passives?.map((host: string) => host.toLowerCase()) ?? [];\n    this.arbiters = hello?.arbiters?.map((host: string) => host.toLowerCase()) ?? [];\n    this.tags = hello?.tags ?? {};\n    this.minWireVersion = hello?.minWireVersion ?? 0;\n    this.maxWireVersion = hello?.maxWireVersion ?? 0;\n    this.roundTripTime = options?.roundTripTime ?? -1;\n    this.lastUpdateTime = now();\n    this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;\n\n    if (options?.topologyVersion) {\n      this.topologyVersion = options.topologyVersion;\n    } else if (hello?.topologyVersion) {\n      this.topologyVersion = hello.topologyVersion;\n    }\n\n    if (options?.error) {\n      this.error = options.error;\n    }\n\n    if (hello?.primary) {\n      this.primary = hello.primary;\n    }\n\n    if (hello?.me) {\n      this.me = hello.me.toLowerCase();\n    }\n\n    if (hello?.setName) {\n      this.setName = hello.setName;\n    }\n\n    if (hello?.setVersion) {\n      this.setVersion = hello.setVersion;\n    }\n\n    if (hello?.electionId) {\n      this.electionId = hello.electionId;\n    }\n\n    if (hello?.logicalSessionTimeoutMinutes) {\n      this.logicalSessionTimeoutMinutes = hello.logicalSessionTimeoutMinutes;\n    }\n\n    if (hello?.$clusterTime) {\n      this.$clusterTime = hello.$clusterTime;\n    }\n  }\n\n  get hostAddress(): HostAddress {\n    if (this._hostAddress) return this._hostAddress;\n    else return new HostAddress(this.address);\n  }\n\n  get allHosts(): string[] {\n    return this.hosts.concat(this.arbiters).concat(this.passives);\n  }\n\n  /** Is this server available for reads*/\n  get isReadable(): boolean {\n    return this.type === ServerType.RSSecondary || this.isWritable;\n  }\n\n  /** Is this server data bearing */\n  get isDataBearing(): boolean {\n    return DATA_BEARING_SERVER_TYPES.has(this.type);\n  }\n\n  /** Is this server available for writes */\n  get isWritable(): boolean {\n    return WRITABLE_SERVER_TYPES.has(this.type);\n  }\n\n  get host(): string {\n    const chopLength = `:${this.port}`.length;\n    return this.address.slice(0, -chopLength);\n  }\n\n  get port(): number {\n    const port = this.address.split(':').pop();\n    return port ? Number.parseInt(port, 10) : 27017;\n  }\n\n  /**\n   * Determines if another `ServerDescription` is equal to this one per the rules defined\n   * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}\n   */\n  equals(other: ServerDescription): boolean {\n    const topologyVersionsEqual =\n      this.topologyVersion === other.topologyVersion ||\n      compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;\n\n    const electionIdsEqual: boolean =\n      this.electionId && other.electionId\n        ? other.electionId && this.electionId.equals(other.electionId)\n        : this.electionId === other.electionId;\n\n    return (\n      other != null &&\n      errorStrictEqual(this.error, other.error) &&\n      this.type === other.type &&\n      this.minWireVersion === other.minWireVersion &&\n      arrayStrictEqual(this.hosts, other.hosts) &&\n      tagsStrictEqual(this.tags, other.tags) &&\n      this.setName === other.setName &&\n      this.setVersion === other.setVersion &&\n      electionIdsEqual &&\n      this.primary === other.primary &&\n      this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes &&\n      topologyVersionsEqual\n    );\n  }\n}\n\n// Parses a `hello` message and determines the server type\nexport function parseServerType(hello?: Document, options?: ServerDescriptionOptions): ServerType {\n  if (options?.loadBalanced) {\n    return ServerType.LoadBalancer;\n  }\n\n  if (!hello || !hello.ok) {\n    return ServerType.Unknown;\n  }\n\n  if (hello.isreplicaset) {\n    return ServerType.RSGhost;\n  }\n\n  if (hello.msg && hello.msg === 'isdbgrid') {\n    return ServerType.Mongos;\n  }\n\n  if (hello.setName) {\n    if (hello.hidden) {\n      return ServerType.RSOther;\n    } else if (hello.isWritablePrimary) {\n      return ServerType.RSPrimary;\n    } else if (hello.secondary) {\n      return ServerType.RSSecondary;\n    } else if (hello.arbiterOnly) {\n      return ServerType.RSArbiter;\n    } else {\n      return ServerType.RSOther;\n    }\n  }\n\n  return ServerType.Standalone;\n}\n\nfunction tagsStrictEqual(tags: TagSet, tags2: TagSet): boolean {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n\n  return (\n    tagsKeys.length === tags2Keys.length &&\n    tagsKeys.every((key: string) => tags2[key] === tags[key])\n  );\n}\n\n/**\n * Compares two topology versions.\n *\n * @returns A negative number if `lhs` is older than `rhs`; positive if `lhs` is newer than `rhs`; 0 if they are equivalent.\n */\nexport function compareTopologyVersion(lhs?: TopologyVersion, rhs?: TopologyVersion): number {\n  if (lhs == null || rhs == null) {\n    return -1;\n  }\n\n  if (lhs.processId.equals(rhs.processId)) {\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    const lhsCounter = Long.isLong(lhs.counter) ? lhs.counter : Long.fromNumber(lhs.counter);\n    const rhsCounter = Long.isLong(rhs.counter) ? lhs.counter : Long.fromNumber(rhs.counter);\n    return lhsCounter.compare(rhsCounter);\n  }\n\n  return -1;\n}\n"]},"metadata":{},"sourceType":"script"}