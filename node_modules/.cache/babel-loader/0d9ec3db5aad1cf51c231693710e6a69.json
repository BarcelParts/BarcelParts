{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;\n\nconst dns = require(\"dns\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst auth_provider_1 = require(\"./auth_provider\");\n/** @public */\n\n\nexports.GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n});\n\nclass GSSAPI extends auth_provider_1.AuthProvider {\n  auth(authContext, callback) {\n    const {\n      connection,\n      credentials\n    } = authContext;\n    if (credentials == null) return callback(new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication'));\n    const {\n      username\n    } = credentials;\n\n    function externalCommand(command, cb) {\n      return connection.command((0, utils_1.ns)('$external.$cmd'), command, undefined, cb);\n    }\n\n    makeKerberosClient(authContext, (err, client) => {\n      if (err) return callback(err);\n      if (client == null) return callback(new error_1.MongoMissingDependencyError('GSSAPI client missing'));\n      client.step('', (err, payload) => {\n        if (err) return callback(err);\n        externalCommand(saslStart(payload), (err, result) => {\n          if (err) return callback(err);\n          if (result == null) return callback();\n          negotiate(client, 10, result.payload, (err, payload) => {\n            if (err) return callback(err);\n            externalCommand(saslContinue(payload, result.conversationId), (err, result) => {\n              if (err) return callback(err);\n              if (result == null) return callback();\n              finalize(client, username, result.payload, (err, payload) => {\n                if (err) return callback(err);\n                externalCommand({\n                  saslContinue: 1,\n                  conversationId: result.conversationId,\n                  payload\n                }, (err, result) => {\n                  if (err) return callback(err);\n                  callback(undefined, result);\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  }\n\n}\n\nexports.GSSAPI = GSSAPI;\n\nfunction makeKerberosClient(authContext, callback) {\n  var _a;\n\n  const {\n    hostAddress\n  } = authContext.options;\n  const {\n    credentials\n  } = authContext;\n\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    return callback(new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.'));\n  }\n\n  if ('kModuleError' in deps_1.Kerberos) {\n    return callback(deps_1.Kerberos['kModuleError']);\n  }\n\n  const {\n    initializeClient\n  } = deps_1.Kerberos;\n  const {\n    username,\n    password\n  } = credentials;\n  const mechanismProperties = credentials.mechanismProperties;\n  const serviceName = (_a = mechanismProperties.SERVICE_NAME) !== null && _a !== void 0 ? _a : 'mongodb';\n  performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties, (err, host) => {\n    var _a;\n\n    if (err) return callback(err);\n    const initOptions = {};\n\n    if (password != null) {\n      Object.assign(initOptions, {\n        user: username,\n        password: password\n      });\n    }\n\n    const spnHost = (_a = mechanismProperties.SERVICE_HOST) !== null && _a !== void 0 ? _a : host;\n    let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n\n    if ('SERVICE_REALM' in mechanismProperties) {\n      spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n    }\n\n    initializeClient(spn, initOptions, (err, client) => {\n      // TODO(NODE-3483)\n      if (err) return callback(new error_1.MongoRuntimeError(err));\n      callback(undefined, client);\n    });\n  });\n}\n\nfunction saslStart(payload) {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  };\n}\n\nfunction saslContinue(payload, conversationId) {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  };\n}\n\nfunction negotiate(client, retries, payload, callback) {\n  client.step(payload, (err, response) => {\n    // Retries exhausted, raise error\n    if (err && retries === 0) return callback(err); // Adjust number of retries and call step again\n\n    if (err) return negotiate(client, retries - 1, payload, callback); // Return the payload\n\n    callback(undefined, response || '');\n  });\n}\n\nfunction finalize(client, user, payload, callback) {\n  // GSS Client Unwrap\n  client.unwrap(payload, (err, response) => {\n    if (err) return callback(err); // Wrap the response\n\n    client.wrap(response || '', {\n      user\n    }, (err, wrapped) => {\n      if (err) return callback(err); // Return the payload\n\n      callback(undefined, wrapped);\n    });\n  });\n}\n\nfunction performGSSAPICanonicalizeHostName(host, mechanismProperties, callback) {\n  const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n\n  if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {\n    return callback(undefined, host);\n  } // If forward and reverse or true\n\n\n  if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {\n    // Perform the lookup of the ip address.\n    dns.lookup(host, (error, address) => {\n      // No ip found, return the error.\n      if (error) return callback(error); // Perform a reverse ptr lookup on the ip address.\n\n      dns.resolvePtr(address, (err, results) => {\n        // This can error as ptr records may not exist for all ips. In this case\n        // fallback to a cname lookup as dns.lookup() does not return the\n        // cname.\n        if (err) {\n          return resolveCname(host, callback);\n        } // If the ptr did not error but had no results, return the host.\n\n\n        callback(undefined, results.length > 0 ? results[0] : host);\n      });\n    });\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    resolveCname(host, callback);\n  }\n}\n\nexports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;\n\nfunction resolveCname(host, callback) {\n  // Attempt to resolve the host name\n  dns.resolveCname(host, (err, r) => {\n    if (err) return callback(undefined, host); // Get the first resolve host id\n\n    if (r.length > 0) {\n      return callback(undefined, r[0]);\n    }\n\n    callback(undefined, host);\n  });\n}\n\nexports.resolveCname = resolveCname;","map":{"version":3,"mappings":"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","names":["exports","Object","freeze","on","off","none","forward","forwardAndReverse","GSSAPI","auth_provider_1","auth","authContext","callback","connection","credentials","error_1","username","externalCommand","command","cb","undefined","makeKerberosClient","err","client","step","payload","saslStart","result","negotiate","saslContinue","conversationId","finalize","hostAddress","options","host","deps_1","initializeClient","password","mechanismProperties","serviceName","SERVICE_NAME","_a","performGSSAPICanonicalizeHostName","initOptions","assign","user","spnHost","SERVICE_HOST","spn","process","platform","SERVICE_REALM","mechanism","autoAuthorize","retries","response","unwrap","wrap","wrapped","mode","CANONICALIZE_HOST_NAME","dns","lookup","error","address","resolvePtr","results","resolveCname","length","r"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\cmap\\auth\\gssapi.ts"],"sourcesContent":["import * as dns from 'dns';\n\nimport type { Document } from '../../bson';\nimport { Kerberos, KerberosClient } from '../../deps';\nimport {\n  MongoError,\n  MongoInvalidArgumentError,\n  MongoMissingCredentialsError,\n  MongoMissingDependencyError,\n  MongoRuntimeError\n} from '../../error';\nimport { Callback, ns } from '../../utils';\nimport { AuthContext, AuthProvider } from './auth_provider';\n\n/** @public */\nexport const GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n} as const);\n\n/** @public */\nexport type GSSAPICanonicalizationValue =\n  typeof GSSAPICanonicalizationValue[keyof typeof GSSAPICanonicalizationValue];\n\ntype MechanismProperties = {\n  /** @deprecated use `CANONICALIZE_HOST_NAME` instead */\n  gssapiCanonicalizeHostName?: boolean;\n  CANONICALIZE_HOST_NAME?: GSSAPICanonicalizationValue;\n  SERVICE_HOST?: string;\n  SERVICE_NAME?: string;\n  SERVICE_REALM?: string;\n};\n\nexport class GSSAPI extends AuthProvider {\n  override auth(authContext: AuthContext, callback: Callback): void {\n    const { connection, credentials } = authContext;\n    if (credentials == null)\n      return callback(\n        new MongoMissingCredentialsError('Credentials required for GSSAPI authentication')\n      );\n    const { username } = credentials;\n    function externalCommand(\n      command: Document,\n      cb: Callback<{ payload: string; conversationId: any }>\n    ) {\n      return connection.command(ns('$external.$cmd'), command, undefined, cb);\n    }\n    makeKerberosClient(authContext, (err, client) => {\n      if (err) return callback(err);\n      if (client == null) return callback(new MongoMissingDependencyError('GSSAPI client missing'));\n      client.step('', (err, payload) => {\n        if (err) return callback(err);\n\n        externalCommand(saslStart(payload), (err, result) => {\n          if (err) return callback(err);\n          if (result == null) return callback();\n          negotiate(client, 10, result.payload, (err, payload) => {\n            if (err) return callback(err);\n\n            externalCommand(saslContinue(payload, result.conversationId), (err, result) => {\n              if (err) return callback(err);\n              if (result == null) return callback();\n              finalize(client, username, result.payload, (err, payload) => {\n                if (err) return callback(err);\n\n                externalCommand(\n                  {\n                    saslContinue: 1,\n                    conversationId: result.conversationId,\n                    payload\n                  },\n                  (err, result) => {\n                    if (err) return callback(err);\n\n                    callback(undefined, result);\n                  }\n                );\n              });\n            });\n          });\n        });\n      });\n    });\n  }\n}\n\nfunction makeKerberosClient(authContext: AuthContext, callback: Callback<KerberosClient>): void {\n  const { hostAddress } = authContext.options;\n  const { credentials } = authContext;\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    return callback(\n      new MongoInvalidArgumentError('Connection must have host and port and credentials defined.')\n    );\n  }\n\n  if ('kModuleError' in Kerberos) {\n    return callback(Kerberos['kModuleError']);\n  }\n  const { initializeClient } = Kerberos;\n\n  const { username, password } = credentials;\n  const mechanismProperties = credentials.mechanismProperties as MechanismProperties;\n\n  const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n\n  performGSSAPICanonicalizeHostName(\n    hostAddress.host,\n    mechanismProperties,\n    (err?: Error | MongoError, host?: string) => {\n      if (err) return callback(err);\n\n      const initOptions = {};\n      if (password != null) {\n        Object.assign(initOptions, { user: username, password: password });\n      }\n\n      const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n      let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n      if ('SERVICE_REALM' in mechanismProperties) {\n        spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n      }\n\n      initializeClient(spn, initOptions, (err: string, client: KerberosClient): void => {\n        // TODO(NODE-3483)\n        if (err) return callback(new MongoRuntimeError(err));\n        callback(undefined, client);\n      });\n    }\n  );\n}\n\nfunction saslStart(payload?: string): Document {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  };\n}\n\nfunction saslContinue(payload?: string, conversationId?: number): Document {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  };\n}\n\nfunction negotiate(\n  client: KerberosClient,\n  retries: number,\n  payload: string,\n  callback: Callback<string>\n): void {\n  client.step(payload, (err, response) => {\n    // Retries exhausted, raise error\n    if (err && retries === 0) return callback(err);\n\n    // Adjust number of retries and call step again\n    if (err) return negotiate(client, retries - 1, payload, callback);\n\n    // Return the payload\n    callback(undefined, response || '');\n  });\n}\n\nfunction finalize(\n  client: KerberosClient,\n  user: string,\n  payload: string,\n  callback: Callback<string>\n): void {\n  // GSS Client Unwrap\n  client.unwrap(payload, (err, response) => {\n    if (err) return callback(err);\n\n    // Wrap the response\n    client.wrap(response || '', { user }, (err, wrapped) => {\n      if (err) return callback(err);\n\n      // Return the payload\n      callback(undefined, wrapped);\n    });\n  });\n}\n\nexport function performGSSAPICanonicalizeHostName(\n  host: string,\n  mechanismProperties: MechanismProperties,\n  callback: Callback<string>\n): void {\n  const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n  if (!mode || mode === GSSAPICanonicalizationValue.none) {\n    return callback(undefined, host);\n  }\n\n  // If forward and reverse or true\n  if (\n    mode === GSSAPICanonicalizationValue.on ||\n    mode === GSSAPICanonicalizationValue.forwardAndReverse\n  ) {\n    // Perform the lookup of the ip address.\n    dns.lookup(host, (error, address) => {\n      // No ip found, return the error.\n      if (error) return callback(error);\n\n      // Perform a reverse ptr lookup on the ip address.\n      dns.resolvePtr(address, (err, results) => {\n        // This can error as ptr records may not exist for all ips. In this case\n        // fallback to a cname lookup as dns.lookup() does not return the\n        // cname.\n        if (err) {\n          return resolveCname(host, callback);\n        }\n        // If the ptr did not error but had no results, return the host.\n        callback(undefined, results.length > 0 ? results[0] : host);\n      });\n    });\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    resolveCname(host, callback);\n  }\n}\n\nexport function resolveCname(host: string, callback: Callback<string>): void {\n  // Attempt to resolve the host name\n  dns.resolveCname(host, (err, r) => {\n    if (err) return callback(undefined, host);\n\n    // Get the first resolve host id\n    if (r.length > 0) {\n      return callback(undefined, r[0]);\n    }\n\n    callback(undefined, host);\n  });\n}\n"]},"metadata":{},"sourceType":"script"}