{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollectionsOperation = void 0;\n\nconst collection_1 = require(\"../collection\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nclass CollectionsOperation extends operation_1.AbstractOperation {\n  constructor(db, options) {\n    super(options);\n    this.options = options;\n    this.db = db;\n  }\n\n  execute(server, session, callback) {\n    const db = this.db; // Let's get the collection names\n\n    db.listCollections({}, { ...this.options,\n      nameOnly: true,\n      readPreference: this.readPreference,\n      session\n    }).toArray((err, documents) => {\n      if (err || !documents) return callback(err); // Filter collections removing any illegal ones\n\n      documents = documents.filter(doc => doc.name.indexOf('$') === -1); // Return the collection objects\n\n      callback(undefined, documents.map(d => {\n        return new collection_1.Collection(db, d.name, db.s.options);\n      }));\n    });\n  }\n\n}\n\nexports.CollectionsOperation = CollectionsOperation;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAKA;AAMA;;;AACA,MAAaA,oBAAb,SAA0CC,6BAA1C,CAAyE;AAIvEC,cAAYC,EAAZ,EAAoBC,OAApB,EAA+C;AAC7C,UAAMA,OAAN;AACA,SAAKA,OAAL,GAAeA,OAAf;AACA,SAAKD,EAAL,GAAUA,EAAV;AACD;;AAEQE,SAAO,CACdC,MADc,EAEdC,OAFc,EAGdC,QAHc,EAGkB;AAEhC,UAAML,EAAE,GAAG,KAAKA,EAAhB,CAFgC,CAIhC;;AACAA,MAAE,CAACM,eAAH,CACE,EADF,EAEE,EAAE,GAAG,KAAKL,OAAV;AAAmBM,cAAQ,EAAE,IAA7B;AAAmCC,oBAAc,EAAE,KAAKA,cAAxD;AAAwEJ;AAAxE,KAFF,EAGEK,OAHF,CAGU,CAACC,GAAD,EAAMC,SAAN,KAAmB;AAC3B,UAAID,GAAG,IAAI,CAACC,SAAZ,EAAuB,OAAON,QAAQ,CAACK,GAAD,CAAf,CADI,CAE3B;;AACAC,eAAS,GAAGA,SAAS,CAACC,MAAV,CAAiBC,GAAG,IAAIA,GAAG,CAACC,IAAJ,CAASC,OAAT,CAAiB,GAAjB,MAA0B,CAAC,CAAnD,CAAZ,CAH2B,CAK3B;;AACAV,cAAQ,CACNW,SADM,EAENL,SAAS,CAACM,GAAV,CAAcC,CAAC,IAAG;AAChB,eAAO,IAAIC,uBAAJ,CAAenB,EAAf,EAAmBkB,CAAC,CAACJ,IAArB,EAA2Bd,EAAE,CAACoB,CAAH,CAAKnB,OAAhC,CAAP;AACD,OAFD,CAFM,CAAR;AAMD,KAfD;AAgBD;;AAlCsE;;AAAzEoB","names":["CollectionsOperation","operation_1","constructor","db","options","execute","server","session","callback","listCollections","nameOnly","readPreference","toArray","err","documents","filter","doc","name","indexOf","undefined","map","d","collection_1","s","exports"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\operations\\collections.ts"],"sourcesContent":["import { Collection } from '../collection';\nimport type { Db } from '../db';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Callback } from '../utils';\nimport { AbstractOperation, OperationOptions } from './operation';\n\nexport interface CollectionsOptions extends OperationOptions {\n  nameOnly?: boolean;\n}\n\n/** @internal */\nexport class CollectionsOperation extends AbstractOperation<Collection[]> {\n  override options: CollectionsOptions;\n  db: Db;\n\n  constructor(db: Db, options: CollectionsOptions) {\n    super(options);\n    this.options = options;\n    this.db = db;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Collection[]>\n  ): void {\n    const db = this.db;\n\n    // Let's get the collection names\n    db.listCollections(\n      {},\n      { ...this.options, nameOnly: true, readPreference: this.readPreference, session }\n    ).toArray((err, documents) => {\n      if (err || !documents) return callback(err);\n      // Filter collections removing any illegal ones\n      documents = documents.filter(doc => doc.name.indexOf('$') === -1);\n\n      // Return the collection objects\n      callback(\n        undefined,\n        documents.map(d => {\n          return new Collection(db, d.name, db.s.options);\n        })\n      );\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}