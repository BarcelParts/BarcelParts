{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst get_more_1 = require(\"../operations/get_more\");\n\nconst read_concern_1 = require(\"../read_concern\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n/** @internal */\n\n\nconst kId = Symbol('id');\n/** @internal */\n\nconst kDocuments = Symbol('documents');\n/** @internal */\n\nconst kServer = Symbol('server');\n/** @internal */\n\nconst kNamespace = Symbol('namespace');\n/** @internal */\n\nconst kTopology = Symbol('topology');\n/** @internal */\n\nconst kSession = Symbol('session');\n/** @internal */\n\nconst kOptions = Symbol('options');\n/** @internal */\n\nconst kTransform = Symbol('transform');\n/** @internal */\n\nconst kInitialized = Symbol('initialized');\n/** @internal */\n\nconst kClosed = Symbol('closed');\n/** @internal */\n\nconst kKilled = Symbol('killed');\n/** @internal */\n\nconst kInit = Symbol('kInit');\n/** @public */\n\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\n\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(topology, namespace) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this[kTopology] = topology;\n    this[kNamespace] = namespace;\n    this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\n\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    };\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n\n    if (options.session instanceof sessions_1.ClientSession) {\n      this[kSession] = options.session;\n    }\n  }\n\n  get id() {\n    return this[kId];\n  }\n  /** @internal */\n\n\n  get topology() {\n    return this[kTopology];\n  }\n  /** @internal */\n\n\n  get server() {\n    return this[kServer];\n  }\n\n  get namespace() {\n    return this[kNamespace];\n  }\n\n  get readPreference() {\n    return this[kOptions].readPreference;\n  }\n\n  get readConcern() {\n    return this[kOptions].readConcern;\n  }\n  /** @internal */\n\n\n  get session() {\n    return this[kSession];\n  }\n\n  set session(clientSession) {\n    this[kSession] = clientSession;\n  }\n  /** @internal */\n\n\n  get cursorOptions() {\n    return this[kOptions];\n  }\n\n  get closed() {\n    return this[kClosed];\n  }\n\n  get killed() {\n    return this[kKilled];\n  }\n\n  get loadBalanced() {\n    return this[kTopology].loadBalanced;\n  }\n  /** Returns current buffered documents length */\n\n\n  bufferedCount() {\n    return this[kDocuments].length;\n  }\n  /** Returns current buffered documents */\n\n\n  readBufferedDocuments(number) {\n    return this[kDocuments].splice(0, number !== null && number !== void 0 ? number : this[kDocuments].length);\n  }\n\n  [Symbol.asyncIterator]() {\n    return {\n      next: () => this.next().then(value => value != null ? {\n        value,\n        done: false\n      } : {\n        value: undefined,\n        done: true\n      })\n    };\n  }\n\n  stream(options) {\n    if (options === null || options === void 0 ? void 0 : options.transform) {\n      const transform = options.transform;\n      const readable = makeCursorStream(this);\n      return readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n\n      }));\n    }\n\n    return makeCursorStream(this);\n  }\n\n  hasNext(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(undefined, false);\n      }\n\n      if (this[kDocuments].length) {\n        return done(undefined, true);\n      }\n\n      next(this, true, (err, doc) => {\n        if (err) return done(err);\n\n        if (doc) {\n          this[kDocuments].unshift(doc);\n          done(undefined, true);\n          return;\n        }\n\n        done(undefined, false);\n      });\n    });\n  }\n\n  next(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoCursorExhaustedError());\n      }\n\n      next(this, true, done);\n    });\n  }\n\n  tryNext(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoCursorExhaustedError());\n      }\n\n      next(this, false, done);\n    });\n  }\n\n  forEach(iterator, callback) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n\n    return (0, utils_1.maybePromise)(callback, done => {\n      const transform = this[kTransform];\n\n      const fetchDocs = () => {\n        next(this, true, (err, doc) => {\n          if (err || doc == null) return done(err);\n          let result; // NOTE: no need to transform because `next` will do this automatically\n\n          try {\n            result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n          } catch (error) {\n            return done(error);\n          }\n\n          if (result === false) return done(); // these do need to be transformed since they are copying the rest of the batch\n\n          const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\n\n          for (let i = 0; i < internalDocs.length; ++i) {\n            try {\n              result = iterator(transform ? transform(internalDocs[i]) : internalDocs[i] // TODO(NODE-3283): Improve transform typing\n              );\n            } catch (error) {\n              return done(error);\n            }\n\n            if (result === false) return done();\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n\n  close(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n    return (0, utils_1.maybePromise)(callback, done => cleanupCursor(this, {\n      needsToEmitClosed\n    }, done));\n  }\n\n  toArray(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      const docs = [];\n      const transform = this[kTransform];\n\n      const fetchDocs = () => {\n        // NOTE: if we add a `nextBatch` then we should use it here\n        next(this, true, (err, doc) => {\n          if (err) return done(err);\n          if (doc == null) return done(undefined, docs); // NOTE: no need to transform because `next` will do this automatically\n\n          docs.push(doc); // these do need to be transformed since they are copying the rest of the batch\n\n          const internalDocs = transform ? this[kDocuments].splice(0, this[kDocuments].length).map(transform) : this[kDocuments].splice(0, this[kDocuments].length); // TODO(NODE-3283): Improve transform typing\n\n          if (internalDocs) {\n            docs.push(...internalDocs);\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n\n\n  addCursorFlag(flag, value) {\n    assertUninitialized(this);\n\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this[kOptions][flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n\n\n  map(transform) {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadPreference(readPreference) {\n    assertUninitialized(this);\n\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadConcern(readConcern) {\n    assertUninitialized(this);\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n\n\n  maxTimeMS(value) {\n    assertUninitialized(this);\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   */\n\n\n  batchSize(value) {\n    assertUninitialized(this);\n\n    if (this[kOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this[kOptions].batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n\n\n  rewind() {\n    if (!this[kInitialized]) {\n      return;\n    }\n\n    this[kId] = undefined;\n    this[kDocuments] = [];\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n    const session = this[kSession];\n\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false && !session.hasEnded) {\n        session.endSession();\n      }\n\n      this[kSession] = undefined;\n    }\n  }\n  /** @internal */\n\n\n  _getMore(batchSize, callback) {\n    const cursorId = this[kId];\n    const cursorNs = this[kNamespace];\n    const server = this[kServer];\n\n    if (cursorId == null) {\n      callback(new error_1.MongoRuntimeError('Unable to iterate cursor with no id'));\n      return;\n    }\n\n    if (server == null) {\n      callback(new error_1.MongoRuntimeError('Unable to iterate cursor without selected server'));\n      return;\n    }\n\n    const getMoreOperation = new get_more_1.GetMoreOperation(cursorNs, cursorId, server, { ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    });\n    (0, execute_operation_1.executeOperation)(this, getMoreOperation, callback);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n\n\n  [kInit](callback) {\n    if (this[kSession] == null) {\n      if (this[kTopology].shouldCheckForSessionSupport()) {\n        return this[kTopology].selectServer(read_preference_1.ReadPreference.primaryPreferred, {}, err => {\n          if (err) return callback(err);\n          return this[kInit](callback);\n        });\n      } else if (this[kTopology].hasSessionSupport()) {\n        this[kSession] = this[kTopology].startSession({\n          owner: this,\n          explicit: false\n        });\n      }\n    }\n\n    this._initialize(this[kSession], (err, state) => {\n      if (state) {\n        const response = state.response;\n        this[kServer] = state.server;\n        this[kSession] = state.session;\n\n        if (response.cursor) {\n          this[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n\n          if (response.cursor.ns) {\n            this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n          }\n\n          this[kDocuments] = response.cursor.firstBatch;\n        } // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n\n\n        if (this[kId] == null) {\n          this[kId] = bson_1.Long.ZERO; // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n\n          this[kDocuments] = [state.response];\n        }\n      } // the cursor is now initialized, even if an error occurred or it is dead\n\n\n      this[kInitialized] = true;\n\n      if (err || cursorIsDead(this)) {\n        return cleanupCursor(this, {\n          error: err\n        }, () => callback(err, nextDocument(this)));\n      }\n\n      callback();\n    });\n  }\n\n}\n\nexports.AbstractCursor = AbstractCursor;\n/** @event */\n\nAbstractCursor.CLOSE = 'close';\n\nfunction nextDocument(cursor) {\n  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n    return null;\n  }\n\n  const doc = cursor[kDocuments].shift();\n\n  if (doc) {\n    const transform = cursor[kTransform];\n\n    if (transform) {\n      return transform(doc);\n    }\n\n    return doc;\n  }\n\n  return null;\n}\n\nfunction next(cursor, blocking, callback) {\n  const cursorId = cursor[kId];\n\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n\n  if (cursor[kDocuments] && cursor[kDocuments].length) {\n    callback(undefined, nextDocument(cursor));\n    return;\n  }\n\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    cursor[kInit]((err, value) => {\n      if (err) return callback(err);\n\n      if (value) {\n        return callback(undefined, value);\n      }\n\n      return next(cursor, blocking, callback);\n    });\n    return;\n  }\n\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n  } // otherwise need to call getMore\n\n\n  const batchSize = cursor[kOptions].batchSize || 1000;\n\n  cursor._getMore(batchSize, (err, response) => {\n    if (response) {\n      const cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n      cursor[kDocuments] = response.cursor.nextBatch;\n      cursor[kId] = cursorId;\n    }\n\n    if (err || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, {\n        error: err\n      }, () => callback(err, nextDocument(cursor)));\n    }\n\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n\n    next(cursor, blocking, callback);\n  });\n}\n\nfunction cursorIsDead(cursor) {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\n\nfunction cleanupCursor(cursor, options, callback) {\n  var _a;\n\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n  const needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;\n\n  if (error) {\n    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = bson_1.Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, callback);\n      }\n\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n\n    return callback();\n  }\n\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, () => {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n      }\n\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n\n  cursor[kKilled] = true;\n  server.killCursors(cursorNs, [cursorId], { ...(0, bson_1.pluckBSONSerializeOptions)(cursor[kOptions]),\n    session\n  }, () => completeCleanup());\n}\n/** @internal */\n\n\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoCursorInUseError();\n  }\n}\n\nexports.assertUninitialized = assertUninitialized;\n\nfunction makeCursorStream(cursor) {\n  const readable = new stream_1.Readable({\n    objectMode: true,\n    autoDestroy: false,\n    highWaterMark: 1\n  });\n  let initialized = false;\n  let reading = false;\n  let needToClose = true; // NOTE: we must close the cursor if we never read from it, use `_construct` in future node versions\n\n  readable._read = function () {\n    if (initialized === false) {\n      needToClose = false;\n      initialized = true;\n    }\n\n    if (!reading) {\n      reading = true;\n      readNext();\n    }\n  };\n\n  readable._destroy = function (error, cb) {\n    if (needToClose) {\n      cursor.close(err => process.nextTick(cb, err || error));\n    } else {\n      cb(error);\n    }\n  };\n\n  function readNext() {\n    needToClose = false;\n    next(cursor, true, (err, result) => {\n      needToClose = err ? !cursor.closed : result != null;\n\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          cursor.close();\n          return readable.push(null);\n        } // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n\n\n        if (err.message.match(/interrupted/)) {\n          return readable.push(null);\n        }\n\n        return readable.destroy(err);\n      }\n\n      if (result == null) {\n        readable.push(null);\n      } else if (readable.destroyed) {\n        cursor.close();\n      } else {\n        if (readable.push(result)) {\n          return readNext();\n        }\n\n        reading = false;\n      }\n    });\n  }\n\n  return readable;\n}","map":{"version":3,"mappings":"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","names":["kId","Symbol","kDocuments","kServer","kNamespace","kTopology","kSession","kOptions","kTransform","kInitialized","kClosed","kKilled","kInit","exports","AbstractCursor","mongo_types_1","constructor","topology","namespace","options","readPreference","read_preference_1","primary","readConcern","read_concern_1","fromOptions","batchSize","comment","undefined","maxTimeMS","session","sessions_1","id","server","clientSession","cursorOptions","closed","killed","loadBalanced","bufferedCount","length","readBufferedDocuments","number","splice","asyncIterator","next","then","value","done","stream","transform","readable","makeCursorStream","pipe","stream_1","objectMode","highWaterMark","chunk","_","callback","transformed","err","hasNext","bson_1","ZERO","doc","unshift","error_1","tryNext","forEach","iterator","fetchDocs","result","error","internalDocs","i","close","needsToEmitClosed","cleanupCursor","toArray","docs","push","map","addCursorFlag","flag","assertUninitialized","includes","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","tailable","rewind","explicit","hasEnded","endSession","_getMore","cursorId","cursorNs","getMoreOperation","get_more_1","shouldCheckForSessionSupport","selectServer","primaryPreferred","hasSessionSupport","startSession","owner","_initialize","state","response","cursor","fromNumber","ns","firstBatch","cursorIsDead","nextDocument","shift","blocking","nextBatch","isZero","_a","completeCleanup","emit","CLOSE","inTransaction","killCursors","autoDestroy","initialized","reading","needToClose","_read","readNext","_destroy","cb","process","nextTick","message","match","destroy","destroyed"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\cursor\\abstract_cursor.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\r\n\r\nimport { BSONSerializeOptions, Document, Long, pluckBSONSerializeOptions } from '../bson';\r\nimport {\r\n  AnyError,\r\n  MongoCursorExhaustedError,\r\n  MongoCursorInUseError,\r\n  MongoInvalidArgumentError,\r\n  MongoNetworkError,\r\n  MongoRuntimeError,\r\n  MongoTailableCursorError\r\n} from '../error';\r\nimport { TODO_NODE_3286, TypedEventEmitter } from '../mongo_types';\r\nimport { executeOperation, ExecutionResult } from '../operations/execute_operation';\r\nimport { GetMoreOperation } from '../operations/get_more';\r\nimport { ReadConcern, ReadConcernLike } from '../read_concern';\r\nimport { ReadPreference, ReadPreferenceLike } from '../read_preference';\r\nimport type { Server } from '../sdam/server';\r\nimport type { Topology } from '../sdam/topology';\r\nimport { ClientSession, maybeClearPinnedConnection } from '../sessions';\r\nimport { Callback, maybePromise, MongoDBNamespace, ns } from '../utils';\r\n\r\n/** @internal */\r\nconst kId = Symbol('id');\r\n/** @internal */\r\nconst kDocuments = Symbol('documents');\r\n/** @internal */\r\nconst kServer = Symbol('server');\r\n/** @internal */\r\nconst kNamespace = Symbol('namespace');\r\n/** @internal */\r\nconst kTopology = Symbol('topology');\r\n/** @internal */\r\nconst kSession = Symbol('session');\r\n/** @internal */\r\nconst kOptions = Symbol('options');\r\n/** @internal */\r\nconst kTransform = Symbol('transform');\r\n/** @internal */\r\nconst kInitialized = Symbol('initialized');\r\n/** @internal */\r\nconst kClosed = Symbol('closed');\r\n/** @internal */\r\nconst kKilled = Symbol('killed');\r\n/** @internal */\r\nconst kInit = Symbol('kInit');\r\n\r\n/** @public */\r\nexport const CURSOR_FLAGS = [\r\n  'tailable',\r\n  'oplogReplay',\r\n  'noCursorTimeout',\r\n  'awaitData',\r\n  'exhaust',\r\n  'partial'\r\n] as const;\r\n\r\n/** @public\r\n * @deprecated This interface is deprecated */\r\nexport interface CursorCloseOptions {\r\n  /** Bypass calling killCursors when closing the cursor. */\r\n  /** @deprecated  the skipKillCursors option is deprecated */\r\n  skipKillCursors?: boolean;\r\n}\r\n\r\n/** @public */\r\nexport interface CursorStreamOptions {\r\n  /** A transformation method applied to each document emitted by the stream */\r\n  transform?(doc: Document): Document;\r\n}\r\n\r\n/** @public */\r\nexport type CursorFlag = typeof CURSOR_FLAGS[number];\r\n\r\n/** @public */\r\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\r\n  session?: ClientSession;\r\n  readPreference?: ReadPreferenceLike;\r\n  readConcern?: ReadConcernLike;\r\n  batchSize?: number;\r\n  maxTimeMS?: number;\r\n  /**\r\n   * Comment to apply to the operation.\r\n   *\r\n   * In server versions pre-4.4, 'comment' must be string.  A server\r\n   * error will be thrown if any other type is provided.\r\n   *\r\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\r\n   */\r\n  comment?: unknown;\r\n  tailable?: boolean;\r\n  awaitData?: boolean;\r\n  noCursorTimeout?: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\r\n  // resolved\r\n  readPreference: ReadPreference;\r\n  readConcern?: ReadConcern;\r\n\r\n  // cursor flags, some are deprecated\r\n  oplogReplay?: boolean;\r\n  exhaust?: boolean;\r\n  partial?: boolean;\r\n};\r\n\r\n/** @public */\r\nexport type AbstractCursorEvents = {\r\n  [AbstractCursor.CLOSE](): void;\r\n};\r\n\r\n/** @public */\r\nexport abstract class AbstractCursor<\r\n  TSchema = any,\r\n  CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\r\n> extends TypedEventEmitter<CursorEvents> {\r\n  /** @internal */\r\n  [kId]?: Long;\r\n  /** @internal */\r\n  [kSession]?: ClientSession;\r\n  /** @internal */\r\n  [kServer]?: Server;\r\n  /** @internal */\r\n  [kNamespace]: MongoDBNamespace;\r\n  /** @internal */\r\n  [kDocuments]: TSchema[];\r\n  /** @internal */\r\n  [kTopology]: Topology;\r\n  /** @internal */\r\n  [kTransform]?: (doc: TSchema) => any;\r\n  /** @internal */\r\n  [kInitialized]: boolean;\r\n  /** @internal */\r\n  [kClosed]: boolean;\r\n  /** @internal */\r\n  [kKilled]: boolean;\r\n  /** @internal */\r\n  [kOptions]: InternalAbstractCursorOptions;\r\n\r\n  /** @event */\r\n  static readonly CLOSE = 'close' as const;\r\n\r\n  /** @internal */\r\n  constructor(\r\n    topology: Topology,\r\n    namespace: MongoDBNamespace,\r\n    options: AbstractCursorOptions = {}\r\n  ) {\r\n    super();\r\n\r\n    this[kTopology] = topology;\r\n    this[kNamespace] = namespace;\r\n    this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\r\n    this[kInitialized] = false;\r\n    this[kClosed] = false;\r\n    this[kKilled] = false;\r\n    this[kOptions] = {\r\n      readPreference:\r\n        options.readPreference && options.readPreference instanceof ReadPreference\r\n          ? options.readPreference\r\n          : ReadPreference.primary,\r\n      ...pluckBSONSerializeOptions(options)\r\n    };\r\n\r\n    const readConcern = ReadConcern.fromOptions(options);\r\n    if (readConcern) {\r\n      this[kOptions].readConcern = readConcern;\r\n    }\r\n\r\n    if (typeof options.batchSize === 'number') {\r\n      this[kOptions].batchSize = options.batchSize;\r\n    }\r\n\r\n    // we check for undefined specifically here to allow falsy values\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    if (options.comment !== undefined) {\r\n      this[kOptions].comment = options.comment;\r\n    }\r\n\r\n    if (typeof options.maxTimeMS === 'number') {\r\n      this[kOptions].maxTimeMS = options.maxTimeMS;\r\n    }\r\n\r\n    if (options.session instanceof ClientSession) {\r\n      this[kSession] = options.session;\r\n    }\r\n  }\r\n\r\n  get id(): Long | undefined {\r\n    return this[kId];\r\n  }\r\n\r\n  /** @internal */\r\n  get topology(): Topology {\r\n    return this[kTopology];\r\n  }\r\n\r\n  /** @internal */\r\n  get server(): Server | undefined {\r\n    return this[kServer];\r\n  }\r\n\r\n  get namespace(): MongoDBNamespace {\r\n    return this[kNamespace];\r\n  }\r\n\r\n  get readPreference(): ReadPreference {\r\n    return this[kOptions].readPreference;\r\n  }\r\n\r\n  get readConcern(): ReadConcern | undefined {\r\n    return this[kOptions].readConcern;\r\n  }\r\n\r\n  /** @internal */\r\n  get session(): ClientSession | undefined {\r\n    return this[kSession];\r\n  }\r\n\r\n  set session(clientSession: ClientSession | undefined) {\r\n    this[kSession] = clientSession;\r\n  }\r\n\r\n  /** @internal */\r\n  get cursorOptions(): InternalAbstractCursorOptions {\r\n    return this[kOptions];\r\n  }\r\n\r\n  get closed(): boolean {\r\n    return this[kClosed];\r\n  }\r\n\r\n  get killed(): boolean {\r\n    return this[kKilled];\r\n  }\r\n\r\n  get loadBalanced(): boolean {\r\n    return this[kTopology].loadBalanced;\r\n  }\r\n\r\n  /** Returns current buffered documents length */\r\n  bufferedCount(): number {\r\n    return this[kDocuments].length;\r\n  }\r\n\r\n  /** Returns current buffered documents */\r\n  readBufferedDocuments(number?: number): TSchema[] {\r\n    return this[kDocuments].splice(0, number ?? this[kDocuments].length);\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<TSchema, void> {\r\n    return {\r\n      next: () =>\r\n        this.next().then(value =>\r\n          value != null ? { value, done: false } : { value: undefined, done: true }\r\n        )\r\n    };\r\n  }\r\n\r\n  stream(options?: CursorStreamOptions): Readable {\r\n    if (options?.transform) {\r\n      const transform = options.transform;\r\n      const readable = makeCursorStream(this);\r\n\r\n      return readable.pipe(\r\n        new Transform({\r\n          objectMode: true,\r\n          highWaterMark: 1,\r\n          transform(chunk, _, callback) {\r\n            try {\r\n              const transformed = transform(chunk);\r\n              callback(undefined, transformed);\r\n            } catch (err) {\r\n              callback(err);\r\n            }\r\n          }\r\n        })\r\n      );\r\n    }\r\n\r\n    return makeCursorStream(this);\r\n  }\r\n\r\n  hasNext(): Promise<boolean>;\r\n  hasNext(callback: Callback<boolean>): void;\r\n  hasNext(callback?: Callback<boolean>): Promise<boolean> | void {\r\n    return maybePromise(callback, done => {\r\n      if (this[kId] === Long.ZERO) {\r\n        return done(undefined, false);\r\n      }\r\n\r\n      if (this[kDocuments].length) {\r\n        return done(undefined, true);\r\n      }\r\n\r\n      next<TSchema>(this, true, (err, doc) => {\r\n        if (err) return done(err);\r\n\r\n        if (doc) {\r\n          this[kDocuments].unshift(doc);\r\n          done(undefined, true);\r\n          return;\r\n        }\r\n\r\n        done(undefined, false);\r\n      });\r\n    });\r\n  }\r\n\r\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\r\n  next(): Promise<TSchema | null>;\r\n  next(callback: Callback<TSchema | null>): void;\r\n  next(callback?: Callback<TSchema | null>): Promise<TSchema | null> | void;\r\n  next(callback?: Callback<TSchema | null>): Promise<TSchema | null> | void {\r\n    return maybePromise(callback, done => {\r\n      if (this[kId] === Long.ZERO) {\r\n        return done(new MongoCursorExhaustedError());\r\n      }\r\n\r\n      next(this, true, done);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\r\n   */\r\n  tryNext(): Promise<TSchema | null>;\r\n  tryNext(callback: Callback<TSchema | null>): void;\r\n  tryNext(callback?: Callback<TSchema | null>): Promise<TSchema | null> | void {\r\n    return maybePromise(callback, done => {\r\n      if (this[kId] === Long.ZERO) {\r\n        return done(new MongoCursorExhaustedError());\r\n      }\r\n\r\n      next(this, false, done);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\r\n   *\r\n   * @param iterator - The iteration callback.\r\n   * @param callback - The end callback.\r\n   */\r\n  forEach(iterator: (doc: TSchema) => boolean | void): Promise<void>;\r\n  forEach(iterator: (doc: TSchema) => boolean | void, callback: Callback<void>): void;\r\n  forEach(\r\n    iterator: (doc: TSchema) => boolean | void,\r\n    callback?: Callback<void>\r\n  ): Promise<void> | void {\r\n    if (typeof iterator !== 'function') {\r\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\r\n    }\r\n    return maybePromise(callback, done => {\r\n      const transform = this[kTransform];\r\n      const fetchDocs = () => {\r\n        next<TSchema>(this, true, (err, doc) => {\r\n          if (err || doc == null) return done(err);\r\n          let result;\r\n          // NOTE: no need to transform because `next` will do this automatically\r\n          try {\r\n            result = iterator(doc); // TODO(NODE-3283): Improve transform typing\r\n          } catch (error) {\r\n            return done(error);\r\n          }\r\n\r\n          if (result === false) return done();\r\n\r\n          // these do need to be transformed since they are copying the rest of the batch\r\n          const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\r\n          for (let i = 0; i < internalDocs.length; ++i) {\r\n            try {\r\n              result = iterator(\r\n                (transform ? transform(internalDocs[i]) : internalDocs[i]) as TSchema // TODO(NODE-3283): Improve transform typing\r\n              );\r\n            } catch (error) {\r\n              return done(error);\r\n            }\r\n            if (result === false) return done();\r\n          }\r\n\r\n          fetchDocs();\r\n        });\r\n      };\r\n\r\n      fetchDocs();\r\n    });\r\n  }\r\n\r\n  close(): void;\r\n  close(callback: Callback): void;\r\n  /**\r\n   * @deprecated options argument is deprecated\r\n   */\r\n  close(options: CursorCloseOptions): Promise<void>;\r\n  /**\r\n   * @deprecated options argument is deprecated\r\n   */\r\n  close(options: CursorCloseOptions, callback: Callback): void;\r\n  close(options?: CursorCloseOptions | Callback, callback?: Callback): Promise<void> | void {\r\n    if (typeof options === 'function') (callback = options), (options = {});\r\n    options = options ?? {};\r\n\r\n    const needsToEmitClosed = !this[kClosed];\r\n    this[kClosed] = true;\r\n\r\n    return maybePromise(callback, done => cleanupCursor(this, { needsToEmitClosed }, done));\r\n  }\r\n\r\n  /**\r\n   * Returns an array of documents. The caller is responsible for making sure that there\r\n   * is enough memory to store the results. Note that the array only contains partial\r\n   * results when this cursor had been previously accessed. In that case,\r\n   * cursor.rewind() can be used to reset the cursor.\r\n   *\r\n   * @param callback - The result callback.\r\n   */\r\n  toArray(): Promise<TSchema[]>;\r\n  toArray(callback: Callback<TSchema[]>): void;\r\n  toArray(callback?: Callback<TSchema[]>): Promise<TSchema[]> | void {\r\n    return maybePromise(callback, done => {\r\n      const docs: TSchema[] = [];\r\n      const transform = this[kTransform];\r\n      const fetchDocs = () => {\r\n        // NOTE: if we add a `nextBatch` then we should use it here\r\n        next<TSchema>(this, true, (err, doc) => {\r\n          if (err) return done(err);\r\n          if (doc == null) return done(undefined, docs);\r\n\r\n          // NOTE: no need to transform because `next` will do this automatically\r\n          docs.push(doc);\r\n\r\n          // these do need to be transformed since they are copying the rest of the batch\r\n          const internalDocs = (\r\n            transform\r\n              ? this[kDocuments].splice(0, this[kDocuments].length).map(transform)\r\n              : this[kDocuments].splice(0, this[kDocuments].length)\r\n          ) as TSchema[]; // TODO(NODE-3283): Improve transform typing\r\n\r\n          if (internalDocs) {\r\n            docs.push(...internalDocs);\r\n          }\r\n\r\n          fetchDocs();\r\n        });\r\n      };\r\n\r\n      fetchDocs();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Add a cursor flag to the cursor\r\n   *\r\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\r\n   * @param value - The flag boolean value.\r\n   */\r\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\r\n    assertUninitialized(this);\r\n    if (!CURSOR_FLAGS.includes(flag)) {\r\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\r\n    }\r\n\r\n    if (typeof value !== 'boolean') {\r\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\r\n    }\r\n\r\n    this[kOptions][flag] = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Map all documents using the provided function\r\n   * If there is a transform set on the cursor, that will be called first and the result passed to\r\n   * this function's transform.\r\n   *\r\n   * @remarks\r\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\r\n   * it **does not** return a new instance of a cursor. This means when calling map,\r\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\r\n   * Take note of the following example:\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const cursor: FindCursor<Document> = coll.find();\r\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\r\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\r\n   * ```\r\n   * @param transform - The mapping transformation method.\r\n   */\r\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\r\n    assertUninitialized(this);\r\n    const oldTransform = this[kTransform] as (doc: TSchema) => TSchema; // TODO(NODE-3283): Improve transform typing\r\n    if (oldTransform) {\r\n      this[kTransform] = doc => {\r\n        return transform(oldTransform(doc));\r\n      };\r\n    } else {\r\n      this[kTransform] = transform;\r\n    }\r\n\r\n    return this as unknown as AbstractCursor<T>;\r\n  }\r\n\r\n  /**\r\n   * Set the ReadPreference for the cursor.\r\n   *\r\n   * @param readPreference - The new read preference for the cursor.\r\n   */\r\n  withReadPreference(readPreference: ReadPreferenceLike): this {\r\n    assertUninitialized(this);\r\n    if (readPreference instanceof ReadPreference) {\r\n      this[kOptions].readPreference = readPreference;\r\n    } else if (typeof readPreference === 'string') {\r\n      this[kOptions].readPreference = ReadPreference.fromString(readPreference);\r\n    } else {\r\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the ReadPreference for the cursor.\r\n   *\r\n   * @param readPreference - The new read preference for the cursor.\r\n   */\r\n  withReadConcern(readConcern: ReadConcernLike): this {\r\n    assertUninitialized(this);\r\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\r\n    if (resolvedReadConcern) {\r\n      this[kOptions].readConcern = resolvedReadConcern;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\r\n   *\r\n   * @param value - Number of milliseconds to wait before aborting the query.\r\n   */\r\n  maxTimeMS(value: number): this {\r\n    assertUninitialized(this);\r\n    if (typeof value !== 'number') {\r\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\r\n    }\r\n\r\n    this[kOptions].maxTimeMS = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the batch size for the cursor.\r\n   *\r\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\r\n   */\r\n  batchSize(value: number): this {\r\n    assertUninitialized(this);\r\n    if (this[kOptions].tailable) {\r\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\r\n    }\r\n\r\n    if (typeof value !== 'number') {\r\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\r\n    }\r\n\r\n    this[kOptions].batchSize = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\r\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\r\n   * if the resultant data has already been retrieved by this cursor.\r\n   */\r\n  rewind(): void {\r\n    if (!this[kInitialized]) {\r\n      return;\r\n    }\r\n\r\n    this[kId] = undefined;\r\n    this[kDocuments] = [];\r\n    this[kClosed] = false;\r\n    this[kKilled] = false;\r\n    this[kInitialized] = false;\r\n\r\n    const session = this[kSession];\r\n    if (session) {\r\n      // We only want to end this session if we created it, and it hasn't ended yet\r\n      if (session.explicit === false && !session.hasEnded) {\r\n        session.endSession();\r\n      }\r\n\r\n      this[kSession] = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\r\n   */\r\n  abstract clone(): AbstractCursor<TSchema>;\r\n\r\n  /** @internal */\r\n  abstract _initialize(\r\n    session: ClientSession | undefined,\r\n    callback: Callback<ExecutionResult>\r\n  ): void;\r\n\r\n  /** @internal */\r\n  _getMore(batchSize: number, callback: Callback<Document>): void {\r\n    const cursorId = this[kId];\r\n    const cursorNs = this[kNamespace];\r\n    const server = this[kServer];\r\n\r\n    if (cursorId == null) {\r\n      callback(new MongoRuntimeError('Unable to iterate cursor with no id'));\r\n      return;\r\n    }\r\n\r\n    if (server == null) {\r\n      callback(new MongoRuntimeError('Unable to iterate cursor without selected server'));\r\n      return;\r\n    }\r\n\r\n    const getMoreOperation = new GetMoreOperation(cursorNs, cursorId, server, {\r\n      ...this[kOptions],\r\n      session: this[kSession],\r\n      batchSize\r\n    });\r\n\r\n    executeOperation(this, getMoreOperation, callback);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   *\r\n   * This function is exposed for the unified test runner's createChangeStream\r\n   * operation.  We cannot refactor to use the abstract _initialize method without\r\n   * a significant refactor.\r\n   */\r\n  [kInit](callback: Callback<TSchema | null>): void {\r\n    if (this[kSession] == null) {\r\n      if (this[kTopology].shouldCheckForSessionSupport()) {\r\n        return this[kTopology].selectServer(ReadPreference.primaryPreferred, {}, err => {\r\n          if (err) return callback(err);\r\n          return this[kInit](callback);\r\n        });\r\n      } else if (this[kTopology].hasSessionSupport()) {\r\n        this[kSession] = this[kTopology].startSession({ owner: this, explicit: false });\r\n      }\r\n    }\r\n\r\n    this._initialize(this[kSession], (err, state) => {\r\n      if (state) {\r\n        const response = state.response;\r\n        this[kServer] = state.server;\r\n        this[kSession] = state.session;\r\n\r\n        if (response.cursor) {\r\n          this[kId] =\r\n            typeof response.cursor.id === 'number'\r\n              ? Long.fromNumber(response.cursor.id)\r\n              : response.cursor.id;\r\n\r\n          if (response.cursor.ns) {\r\n            this[kNamespace] = ns(response.cursor.ns);\r\n          }\r\n\r\n          this[kDocuments] = response.cursor.firstBatch;\r\n        }\r\n\r\n        // When server responses return without a cursor document, we close this cursor\r\n        // and return the raw server response. This is often the case for explain commands\r\n        // for example\r\n        if (this[kId] == null) {\r\n          this[kId] = Long.ZERO;\r\n          // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\r\n          this[kDocuments] = [state.response as TODO_NODE_3286];\r\n        }\r\n      }\r\n\r\n      // the cursor is now initialized, even if an error occurred or it is dead\r\n      this[kInitialized] = true;\r\n\r\n      if (err || cursorIsDead(this)) {\r\n        return cleanupCursor(this, { error: err }, () => callback(err, nextDocument(this)));\r\n      }\r\n\r\n      callback();\r\n    });\r\n  }\r\n}\r\n\r\nfunction nextDocument<T>(cursor: AbstractCursor): T | null {\r\n  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\r\n    return null;\r\n  }\r\n\r\n  const doc = cursor[kDocuments].shift();\r\n  if (doc) {\r\n    const transform = cursor[kTransform];\r\n    if (transform) {\r\n      return transform(doc) as T;\r\n    }\r\n\r\n    return doc;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction next<T>(cursor: AbstractCursor<T>, blocking: boolean, callback: Callback<T | null>): void {\r\n  const cursorId = cursor[kId];\r\n  if (cursor.closed) {\r\n    return callback(undefined, null);\r\n  }\r\n\r\n  if (cursor[kDocuments] && cursor[kDocuments].length) {\r\n    callback(undefined, nextDocument<T>(cursor));\r\n    return;\r\n  }\r\n\r\n  if (cursorId == null) {\r\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\r\n    cursor[kInit]((err, value) => {\r\n      if (err) return callback(err);\r\n      if (value) {\r\n        return callback(undefined, value);\r\n      }\r\n      return next(cursor, blocking, callback);\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  if (cursorIsDead(cursor)) {\r\n    return cleanupCursor(cursor, undefined, () => callback(undefined, null));\r\n  }\r\n\r\n  // otherwise need to call getMore\r\n  const batchSize = cursor[kOptions].batchSize || 1000;\r\n  cursor._getMore(batchSize, (err, response) => {\r\n    if (response) {\r\n      const cursorId =\r\n        typeof response.cursor.id === 'number'\r\n          ? Long.fromNumber(response.cursor.id)\r\n          : response.cursor.id;\r\n\r\n      cursor[kDocuments] = response.cursor.nextBatch;\r\n      cursor[kId] = cursorId;\r\n    }\r\n\r\n    if (err || cursorIsDead(cursor)) {\r\n      return cleanupCursor(cursor, { error: err }, () => callback(err, nextDocument<T>(cursor)));\r\n    }\r\n\r\n    if (cursor[kDocuments].length === 0 && blocking === false) {\r\n      return callback(undefined, null);\r\n    }\r\n\r\n    next(cursor, blocking, callback);\r\n  });\r\n}\r\n\r\nfunction cursorIsDead(cursor: AbstractCursor): boolean {\r\n  const cursorId = cursor[kId];\r\n  return !!cursorId && cursorId.isZero();\r\n}\r\n\r\nfunction cleanupCursor(\r\n  cursor: AbstractCursor,\r\n  options: { error?: AnyError | undefined; needsToEmitClosed?: boolean } | undefined,\r\n  callback: Callback\r\n): void {\r\n  const cursorId = cursor[kId];\r\n  const cursorNs = cursor[kNamespace];\r\n  const server = cursor[kServer];\r\n  const session = cursor[kSession];\r\n  const error = options?.error;\r\n  const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;\r\n\r\n  if (error) {\r\n    if (cursor.loadBalanced && error instanceof MongoNetworkError) {\r\n      return completeCleanup();\r\n    }\r\n  }\r\n\r\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\r\n    if (needsToEmitClosed) {\r\n      cursor[kClosed] = true;\r\n      cursor[kId] = Long.ZERO;\r\n      cursor.emit(AbstractCursor.CLOSE);\r\n    }\r\n\r\n    if (session) {\r\n      if (session.owner === cursor) {\r\n        return session.endSession({ error }, callback);\r\n      }\r\n\r\n      if (!session.inTransaction()) {\r\n        maybeClearPinnedConnection(session, { error });\r\n      }\r\n    }\r\n\r\n    return callback();\r\n  }\r\n\r\n  function completeCleanup() {\r\n    if (session) {\r\n      if (session.owner === cursor) {\r\n        return session.endSession({ error }, () => {\r\n          cursor.emit(AbstractCursor.CLOSE);\r\n          callback();\r\n        });\r\n      }\r\n\r\n      if (!session.inTransaction()) {\r\n        maybeClearPinnedConnection(session, { error });\r\n      }\r\n    }\r\n\r\n    cursor.emit(AbstractCursor.CLOSE);\r\n    return callback();\r\n  }\r\n\r\n  cursor[kKilled] = true;\r\n  server.killCursors(\r\n    cursorNs,\r\n    [cursorId],\r\n    { ...pluckBSONSerializeOptions(cursor[kOptions]), session },\r\n    () => completeCleanup()\r\n  );\r\n}\r\n\r\n/** @internal */\r\nexport function assertUninitialized(cursor: AbstractCursor): void {\r\n  if (cursor[kInitialized]) {\r\n    throw new MongoCursorInUseError();\r\n  }\r\n}\r\n\r\nfunction makeCursorStream(cursor: AbstractCursor) {\r\n  const readable = new Readable({\r\n    objectMode: true,\r\n    autoDestroy: false,\r\n    highWaterMark: 1\r\n  });\r\n\r\n  let initialized = false;\r\n  let reading = false;\r\n  let needToClose = true; // NOTE: we must close the cursor if we never read from it, use `_construct` in future node versions\r\n\r\n  readable._read = function () {\r\n    if (initialized === false) {\r\n      needToClose = false;\r\n      initialized = true;\r\n    }\r\n\r\n    if (!reading) {\r\n      reading = true;\r\n      readNext();\r\n    }\r\n  };\r\n\r\n  readable._destroy = function (error, cb) {\r\n    if (needToClose) {\r\n      cursor.close(err => process.nextTick(cb, err || error));\r\n    } else {\r\n      cb(error);\r\n    }\r\n  };\r\n\r\n  function readNext() {\r\n    needToClose = false;\r\n    next(cursor, true, (err, result) => {\r\n      needToClose = err ? !cursor.closed : result != null;\r\n\r\n      if (err) {\r\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\r\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\r\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\r\n        //       propagate the error message by removing this special case.\r\n        if (err.message.match(/server is closed/)) {\r\n          cursor.close();\r\n          return readable.push(null);\r\n        }\r\n\r\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\r\n        //       to be \"operation interrupted\", where a cursor has been closed but there is an\r\n        //       active getMore in-flight. This used to check if the cursor was killed but once\r\n        //       that changed to happen in cleanup legitimate errors would not destroy the\r\n        //       stream. There are change streams test specifically test these cases.\r\n        if (err.message.match(/interrupted/)) {\r\n          return readable.push(null);\r\n        }\r\n\r\n        return readable.destroy(err);\r\n      }\r\n\r\n      if (result == null) {\r\n        readable.push(null);\r\n      } else if (readable.destroyed) {\r\n        cursor.close();\r\n      } else {\r\n        if (readable.push(result)) {\r\n          return readNext();\r\n        }\r\n\r\n        reading = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  return readable;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}