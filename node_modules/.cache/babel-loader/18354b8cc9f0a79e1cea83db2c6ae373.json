{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shuffle = exports.parsePackageVersion = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.parseIndexOptions = exports.normalizeHintField = exports.checkCollectionName = exports.MAX_JS_INT = void 0;\nexports.commandSupportsReadConcern = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst os = require(\"os\");\n\nconst url_1 = require(\"url\");\n\nconst bson_1 = require(\"./bson\");\n\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\n\nconst constants_2 = require(\"./constants\");\n\nconst error_1 = require(\"./error\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst write_concern_1 = require(\"./write_concern\");\n\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\n\nfunction checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\n\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\n\nfunction normalizeHintField(hint) {\n  let finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\nexports.normalizeHintField = normalizeHintField;\n/**\n * Create an index specifier based on\n * @internal\n */\n\nfunction parseIndexOptions(indexSpec) {\n  const fieldHash = {};\n  const indexes = [];\n  let keys; // Get all the fields accordingly\n\n  if ('string' === typeof indexSpec) {\n    // 'type'\n    indexes.push(indexSpec + '_' + 1);\n    fieldHash[indexSpec] = 1;\n  } else if (Array.isArray(indexSpec)) {\n    indexSpec.forEach(f => {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(k => {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(indexSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(indexSpec);\n    Object.entries(indexSpec).forEach(_ref => {\n      let [key, value] = _ref;\n      indexes.push(key + '_' + value);\n      fieldHash[key] = value;\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n}\n\nexports.parseIndexOptions = parseIndexOptions;\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction isObject(arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n}\n\nexports.isObject = isObject;\n/** @internal */\n\nfunction mergeOptions(target, source) {\n  return { ...target,\n    ...source\n  };\n}\n\nexports.mergeOptions = mergeOptions;\n/** @internal */\n\nfunction filterOptions(options, names) {\n  const filterOptions = {};\n\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  } // Filtered options\n\n\n  return filterOptions;\n}\n\nexports.filterOptions = filterOptions;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\n\nfunction applyRetryableWrites(target, db) {\n  var _a;\n\n  if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\n\nfunction isPromiseLike(maybePromise) {\n  return !!maybePromise && typeof maybePromise.then === 'function';\n}\n\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\n\nfunction decorateWithCollation(command, target, options) {\n  const capabilities = getTopology(target).capabilities;\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\n\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  const readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\n\nfunction getTopology(provider) {\n  // MongoClient or ClientSession or AbstractCursor\n  if (`topology` in provider && provider.topology) {\n    return provider.topology;\n  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\nexports.getTopology = getTopology;\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\n\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const options = args[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.bind(this)(...args); // call the function, no change\n    } // interrupt the function call with a warning\n\n\n    for (const deprecatedOption of config.deprecatedOptions) {\n      if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitWarning(msg);\n\n        if (this && 'getLogger' in this) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    }\n\n    return fn.bind(this)(...args);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\n\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\n\nexports.ns = ns;\n/** @public */\n\nclass MongoDBNamespace {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const [db, ...collection] = namespace.split('.');\n    return new MongoDBNamespace(db, collection.join('.'));\n  }\n\n}\n\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\n\nfunction* makeCounter() {\n  let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let count = seed;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\nexports.makeCounter = makeCounter;\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\n\nfunction maybePromise(callback, wrapper) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  wrapper((err, res) => {\n    if (err != null) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback(err);\n      } catch (error) {\n        process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    callback(err, res);\n  });\n  return result;\n}\n\nexports.maybePromise = maybePromise;\n/** @internal */\n\nfunction databaseNamespace(ns) {\n  return ns.split('.')[0];\n}\n\nexports.databaseNamespace = databaseNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\n\nfunction uuidV4() {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\n\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is avaiable that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n\n    if (topologyOrServer.hello) {\n      return topologyOrServer.hello.maxWireVersion;\n    }\n\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n      const lastHello = topologyOrServer.lastHello();\n\n      if (lastHello) {\n        return lastHello.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\nexports.maxWireVersion = maxWireVersion;\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\n\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\nexports.collationNotSupported = collationNotSupported;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nexports.eachAsync = eachAsync;\n/** @internal */\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nexports.makeStateMachine = makeStateMachine; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\nconst NODE_DRIVER_VERSION = require('../package.json').version;\n\nfunction makeClientMetadata(options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n  }; // support optionally provided wrapping driver info\n\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n\n  return metadata;\n}\n\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nexports.now = now;\n/** @internal */\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\nexports.calculateDurationInMs = calculateDurationInMs;\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\n\nfunction makeInterruptibleAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let cannotBeExpedited = false;\n  let stopped = false;\n  options = options !== null && options !== void 0 ? options : {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const nextScheduledCallTime = lastCallTime + interval;\n    const timeUntilNextCall = nextScheduledCallTime - currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n      return;\n    } // debounce multiple calls to wake within the `minInterval`\n\n\n    if (cannotBeExpedited) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n      cannotBeExpedited = true;\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = undefined;\n    }\n\n    lastCallTime = 0;\n    cannotBeExpedited = false;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    cannotBeExpedited = false;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule(undefined);\n  }\n\n  return {\n    wake,\n    stop\n  };\n}\n\nexports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;\n/** @internal */\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\n\nfunction resolveOptions(parent, options) {\n  var _a, _b, _c;\n\n  const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent)); // Users cannot pass a readConcern/writeConcern to operations in a transaction\n\n  const session = options === null || options === void 0 ? void 0 : options.session;\n\n  if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  return result;\n}\n\nexports.resolveOptions = resolveOptions;\n\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isSuperset = isSuperset;\n/**\n * Checks if the document is a Hello request\n * @internal\n */\n\nfunction isHello(doc) {\n  return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\n\nexports.isHello = isHello;\n/** Returns the items that are uniquely in setA */\n\nfunction setDifference(setA, setB) {\n  const difference = new Set(setA);\n\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n\n  return difference;\n}\n\nexports.setDifference = setDifference;\n\nfunction isRecord(value) {\n  let requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  const toString = Object.prototype.toString;\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  const isObject = v => toString.call(v) === '[object Object]';\n\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    } // Check to see if some method exists from the Object exists\n\n\n    if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\n\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n\n    return res;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n\n      case 'map':\n        return new Map(value);\n\n      case 'set':\n        return new Set(value);\n\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n\n  return value;\n}\n\nexports.deepCopy = deepCopy;\n/** @internal */\n\nconst kBuffers = Symbol('buffers');\n/** @internal */\n\nconst kLength = Symbol('length');\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\n\nclass BufferPool {\n  constructor() {\n    this[kBuffers] = [];\n    this[kLength] = 0;\n  }\n\n  get length() {\n    return this[kLength];\n  }\n  /** Adds a buffer to the internal buffer pool list */\n\n\n  append(buffer) {\n    this[kBuffers].push(buffer);\n    this[kLength] += buffer.length;\n  }\n  /** Returns the requested number of bytes without consuming them */\n\n\n  peek(size) {\n    return this.read(size, false);\n  }\n  /** Reads the requested number of bytes, optionally consuming them */\n\n\n  read(size) {\n    let consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (typeof size !== 'number' || size < 0) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    }\n\n    if (size > this[kLength]) {\n      return Buffer.alloc(0);\n    }\n\n    let result; // read the whole buffer\n\n    if (size === this.length) {\n      result = Buffer.concat(this[kBuffers]);\n\n      if (consume) {\n        this[kBuffers] = [];\n        this[kLength] = 0;\n      }\n    } // size is within first buffer, no need to concat\n    else if (size <= this[kBuffers][0].length) {\n      result = this[kBuffers][0].slice(0, size);\n\n      if (consume) {\n        this[kBuffers][0] = this[kBuffers][0].slice(size);\n        this[kLength] -= size;\n      }\n    } // size is beyond first buffer, need to track and copy\n    else {\n      result = Buffer.allocUnsafe(size);\n      let idx;\n      let offset = 0;\n      let bytesToCopy = size;\n\n      for (idx = 0; idx < this[kBuffers].length; ++idx) {\n        let bytesCopied;\n\n        if (bytesToCopy > this[kBuffers][idx].length) {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n          offset += bytesCopied;\n        } else {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n\n          if (consume) {\n            this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n          }\n\n          offset += bytesCopied;\n          break;\n        }\n\n        bytesToCopy -= bytesCopied;\n      } // compact the internal buffer array\n\n\n      if (consume) {\n        this[kBuffers] = this[kBuffers].slice(idx);\n        this[kLength] -= size;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.BufferPool = BufferPool;\n/** @public */\n\nclass HostAddress {\n  constructor(hostString) {\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n\n    const {\n      hostname,\n      port\n    } = new url_1.URL(`mongodb://${escapedHost}`);\n\n    if (hostname.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(hostname);\n    } else if (typeof hostname === 'string') {\n      this.isIPv6 = false;\n      let normalized = decodeURIComponent(hostname).toLowerCase();\n\n      if (normalized.startsWith('[') && normalized.endsWith(']')) {\n        this.isIPv6 = true;\n        normalized = normalized.substring(1, hostname.length - 1);\n      }\n\n      this.host = normalized.toLowerCase();\n\n      if (typeof port === 'number') {\n        this.port = port;\n      } else if (typeof port === 'string' && port !== '') {\n        this.port = Number.parseInt(port, 10);\n      } else {\n        this.port = 27017;\n      }\n\n      if (this.port === 0) {\n        throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n      }\n    } else {\n      throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');\n    }\n\n    Object.freeze(this);\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n\n  inspect() {\n    return `new HostAddress('${this.toString(true)}')`;\n  }\n  /**\n   * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n   */\n\n\n  toString() {\n    let ipv6Brackets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (typeof this.host === 'string') {\n      if (this.isIPv6 && ipv6Brackets) {\n        return `[${this.host}]:${this.port}`;\n      }\n\n      return `${this.host}:${this.port}`;\n    }\n\n    return `${this.socketPath}`;\n  }\n\n  static fromString(s) {\n    return new HostAddress(s);\n  }\n\n  static fromHostPort(host, port) {\n    if (host.includes(':')) {\n      host = `[${host}]`; // IPv6 address\n    }\n\n    return HostAddress.fromString(`${host}:${port}`);\n  }\n\n  static fromSrvRecord(_ref2) {\n    let {\n      name,\n      port\n    } = _ref2;\n    return HostAddress.fromHostPort(name, port);\n  }\n\n}\n\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk() {\n    return new bson_1.ObjectId();\n  }\n\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\n\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\n\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\n\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\n\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\n\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\n\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\n\nfunction supportsRetryableWrites(server) {\n  if (!server) {\n    return false;\n  }\n\n  if (server.loadBalanced) {\n    // Loadbalanced topologies will always support retry writes\n    return true;\n  }\n\n  if (server.description.logicalSessionTimeoutMinutes != null) {\n    // that supports sessions\n    if (server.description.type !== common_1.ServerType.Standalone) {\n      // and that is not a standalone\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.supportsRetryableWrites = supportsRetryableWrites;\n\nfunction parsePackageVersion(_ref3) {\n  let {\n    version\n  } = _ref3;\n  const [major, minor, patch] = version.split('.').map(n => Number.parseInt(n, 10));\n  return {\n    major,\n    minor,\n    patch\n  };\n}\n\nexports.parsePackageVersion = parsePackageVersion;\n/**\n * Fisher–Yates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\n\nfunction shuffle(sequence) {\n  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const items = Array.from(sequence); // shallow copy in order to never shuffle the input\n\n  if (limit > items.length) {\n    throw new error_1.MongoRuntimeError('Limit must be less than the number of items');\n  }\n\n  let remainingItemsToShuffle = items.length;\n  const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n\n  while (remainingItemsToShuffle > lowerBound) {\n    // Pick a remaining element\n    const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n    remainingItemsToShuffle -= 1; // And swap it with the current element\n\n    const swapHold = items[remainingItemsToShuffle];\n    items[remainingItemsToShuffle] = items[randomIndex];\n    items[randomIndex] = swapHold;\n  }\n\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\n\nexports.shuffle = shuffle; // TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.commandSupportsReadConcern = commandSupportsReadConcern;","map":{"version":3,"mappings":"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","names":["exports","Number","MAX_SAFE_INTEGER","checkCollectionName","collectionName","error_1","indexOf","match","normalizeHintField","hint","finalHint","undefined","Array","isArray","forEach","param","name","parseIndexOptions","indexSpec","fieldHash","indexes","keys","push","f","isObject","Object","k","entries","key","value","join","arg","prototype","toString","call","mergeOptions","target","source","filterOptions","options","names","includes","applyRetryableWrites","db","s","_a","retryWrites","applyWriteConcern","sources","coll","collection","session","inTransaction","writeConcern","write_concern_1","fromOptions","assign","isPromiseLike","maybePromise","then","decorateWithCollation","command","capabilities","getTopology","collation","commandsTakeCollation","decorateWithReadConcern","readConcern","length","decorateWithExplain","explain","verbosity","provider","topology","client","defaultMsgHandler","option","deprecateOptions","config","fn","process","noDeprecation","msgHandler","optionsWarned","Set","deprecated","args","optionsIndex","bind","deprecatedOption","deprecatedOptions","has","add","msg","emitWarning","logger","getLogger","warn","setPrototypeOf","ns","MongoDBNamespace","fromString","constructor","withCollection","namespace","split","makeCounter","seed","count","newCount","callback","wrapper","Promise","promise_provider_1","get","result","resolve","reject","err","res","error","nextTick","databaseNamespace","uuidV4","crypto","randomBytes","maxWireVersion","topologyOrServer","loadBalanced","constants_1","hello","lastHello","description","collationNotSupported","server","cmd","eachAsync","arr","eachFn","idx","awaiting","eachCallback","eachAsyncSeries","arrayStrictEqual","arr2","every","elt","errorStrictEqual","lhs","rhs","message","makeStateMachine","stateTable","stateTransition","newState","legalStates","state","emit","NODE_DRIVER_VERSION","require","version","makeClientMetadata","metadata","driver","os","type","platform","architecture","arch","release","endianness","driverInfo","appName","buffer","Buffer","from","application","byteLength","slice","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","makeInterruptibleAsyncInterval","timerId","lastCallTime","cannotBeExpedited","stopped","interval","minInterval","immediate","clock","wake","currentTime","nextScheduledCallTime","timeUntilNextCall","executeAndReschedule","reschedule","stop","clearTimeout","ms","setTimeout","hasAtomicOperators","doc","document","resolveOptions","parent","_b","readPreference","_c","isSuperset","set","subset","elem","isHello","constants_2","setDifference","setA","setB","difference","delete","isRecord","requiredKeys","hasOwnProperty","v","ctor","deepCopy","map","item","toLowerCase","Map","kBuffers","Symbol","kLength","BufferPool","append","peek","size","read","consume","alloc","concat","allocUnsafe","offset","bytesToCopy","bytesCopied","copy","HostAddress","hostString","escapedHost","hostname","port","url_1","endsWith","socketPath","decodeURIComponent","isIPv6","normalized","startsWith","substring","host","parseInt","freeze","for","inspect","ipv6Brackets","fromHostPort","fromSrvRecord","createPk","bson_1","code","emittedWarnings","emitWarningOnce","enumToString","en","values","supportsRetryableWrites","logicalSessionTimeoutMinutes","common_1","Standalone","parsePackageVersion","major","minor","patch","n","shuffle","sequence","limit","items","remainingItemsToShuffle","lowerBound","randomIndex","random","swapHold","commandSupportsReadConcern","aggregate","distinct","find","geoNear","mapReduce","out","inline"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\utils.ts"],"sourcesContent":["import * as crypto from 'crypto';\r\nimport type { SrvRecord } from 'dns';\r\nimport * as os from 'os';\r\nimport { URL } from 'url';\r\n\r\nimport { Document, ObjectId, resolveBSONOptions } from './bson';\r\nimport type { Connection } from './cmap/connection';\r\nimport { MAX_SUPPORTED_WIRE_VERSION } from './cmap/wire_protocol/constants';\r\nimport type { Collection } from './collection';\r\nimport { LEGACY_HELLO_COMMAND } from './constants';\r\nimport type { AbstractCursor } from './cursor/abstract_cursor';\r\nimport type { FindCursor } from './cursor/find_cursor';\r\nimport type { Db } from './db';\r\nimport {\r\n  AnyError,\r\n  MongoCompatibilityError,\r\n  MongoInvalidArgumentError,\r\n  MongoNotConnectedError,\r\n  MongoParseError,\r\n  MongoRuntimeError\r\n} from './error';\r\nimport type { Explain } from './explain';\r\nimport type { MongoClient } from './mongo_client';\r\nimport type { CommandOperationOptions, OperationParent } from './operations/command';\r\nimport type { IndexDirection, IndexSpecification } from './operations/indexes';\r\nimport type { Hint, OperationOptions } from './operations/operation';\r\nimport { PromiseProvider } from './promise_provider';\r\nimport { ReadConcern } from './read_concern';\r\nimport { ReadPreference } from './read_preference';\r\nimport { ServerType } from './sdam/common';\r\nimport type { Server } from './sdam/server';\r\nimport type { Topology } from './sdam/topology';\r\nimport type { ClientSession } from './sessions';\r\nimport { W, WriteConcern, WriteConcernOptions } from './write_concern';\r\n\r\n/**\r\n * MongoDB Driver style callback\r\n * @public\r\n */\r\nexport type Callback<T = any> = (error?: AnyError, result?: T) => void;\r\n\r\nexport const MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\r\n\r\nexport type AnyOptions = Document;\r\n\r\n/**\r\n * Throws if collectionName is not a valid mongodb collection namespace.\r\n * @internal\r\n */\r\nexport function checkCollectionName(collectionName: string): void {\r\n  if ('string' !== typeof collectionName) {\r\n    throw new MongoInvalidArgumentError('Collection name must be a String');\r\n  }\r\n\r\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\r\n    throw new MongoInvalidArgumentError('Collection names cannot be empty');\r\n  }\r\n\r\n  if (\r\n    collectionName.indexOf('$') !== -1 &&\r\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\r\n  ) {\r\n    // TODO(NODE-3483): Use MongoNamespace static method\r\n    throw new MongoInvalidArgumentError(\"Collection names must not contain '$'\");\r\n  }\r\n\r\n  if (collectionName.match(/^\\.|\\.$/) != null) {\r\n    // TODO(NODE-3483): Use MongoNamespace static method\r\n    throw new MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\r\n  }\r\n\r\n  // Validate that we are not passing 0x00 in the collection name\r\n  if (collectionName.indexOf('\\x00') !== -1) {\r\n    // TODO(NODE-3483): Use MongoNamespace static method\r\n    throw new MongoInvalidArgumentError('Collection names cannot contain a null character');\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure Hint field is in a shape we expect:\r\n * - object of index names mapping to 1 or -1\r\n * - just an index name\r\n * @internal\r\n */\r\nexport function normalizeHintField(hint?: Hint): Hint | undefined {\r\n  let finalHint = undefined;\r\n\r\n  if (typeof hint === 'string') {\r\n    finalHint = hint;\r\n  } else if (Array.isArray(hint)) {\r\n    finalHint = {};\r\n\r\n    hint.forEach(param => {\r\n      finalHint[param] = 1;\r\n    });\r\n  } else if (hint != null && typeof hint === 'object') {\r\n    finalHint = {} as Document;\r\n    for (const name in hint) {\r\n      finalHint[name] = hint[name];\r\n    }\r\n  }\r\n\r\n  return finalHint;\r\n}\r\n\r\ninterface IndexOptions {\r\n  name: string;\r\n  keys?: string[];\r\n  fieldHash: Document;\r\n}\r\n\r\n/**\r\n * Create an index specifier based on\r\n * @internal\r\n */\r\nexport function parseIndexOptions(indexSpec: IndexSpecification): IndexOptions {\r\n  const fieldHash: { [key: string]: IndexDirection } = {};\r\n  const indexes = [];\r\n  let keys;\r\n\r\n  // Get all the fields accordingly\r\n  if ('string' === typeof indexSpec) {\r\n    // 'type'\r\n    indexes.push(indexSpec + '_' + 1);\r\n    fieldHash[indexSpec] = 1;\r\n  } else if (Array.isArray(indexSpec)) {\r\n    indexSpec.forEach((f: any) => {\r\n      if ('string' === typeof f) {\r\n        // [{location:'2d'}, 'type']\r\n        indexes.push(f + '_' + 1);\r\n        fieldHash[f] = 1;\r\n      } else if (Array.isArray(f)) {\r\n        // [['location', '2d'],['type', 1]]\r\n        indexes.push(f[0] + '_' + (f[1] || 1));\r\n        fieldHash[f[0]] = f[1] || 1;\r\n      } else if (isObject(f)) {\r\n        // [{location:'2d'}, {type:1}]\r\n        keys = Object.keys(f);\r\n        keys.forEach(k => {\r\n          indexes.push(k + '_' + (f as AnyOptions)[k]);\r\n          fieldHash[k] = (f as AnyOptions)[k];\r\n        });\r\n      } else {\r\n        // undefined (ignore)\r\n      }\r\n    });\r\n  } else if (isObject(indexSpec)) {\r\n    // {location:'2d', type:1}\r\n    keys = Object.keys(indexSpec);\r\n    Object.entries(indexSpec).forEach(([key, value]) => {\r\n      indexes.push(key + '_' + value);\r\n      fieldHash[key] = value;\r\n    });\r\n  }\r\n\r\n  return {\r\n    name: indexes.join('_'),\r\n    keys: keys,\r\n    fieldHash: fieldHash\r\n  };\r\n}\r\n\r\n/**\r\n * Checks if arg is an Object:\r\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nexport function isObject(arg: unknown): arg is object {\r\n  return '[object Object]' === Object.prototype.toString.call(arg);\r\n}\r\n\r\n/** @internal */\r\nexport function mergeOptions<T, S>(target: T, source: S): T & S {\r\n  return { ...target, ...source };\r\n}\r\n\r\n/** @internal */\r\nexport function filterOptions(options: AnyOptions, names: string[]): AnyOptions {\r\n  const filterOptions: AnyOptions = {};\r\n\r\n  for (const name in options) {\r\n    if (names.includes(name)) {\r\n      filterOptions[name] = options[name];\r\n    }\r\n  }\r\n\r\n  // Filtered options\r\n  return filterOptions;\r\n}\r\n\r\ninterface HasRetryableWrites {\r\n  retryWrites?: boolean;\r\n}\r\n/**\r\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\r\n * @internal\r\n *\r\n * @param target - The target command to which we will apply retryWrites.\r\n * @param db - The database from which we can inherit a retryWrites value.\r\n */\r\nexport function applyRetryableWrites<T extends HasRetryableWrites>(target: T, db?: Db): T {\r\n  if (db && db.s.options?.retryWrites) {\r\n    target.retryWrites = true;\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\ninterface HasWriteConcern {\r\n  writeConcern?: WriteConcernOptions | WriteConcern | W;\r\n}\r\n/**\r\n * Applies a write concern to a command based on well defined inheritance rules, optionally\r\n * detecting support for the write concern in the first place.\r\n * @internal\r\n *\r\n * @param target - the target command we will be applying the write concern to\r\n * @param sources - sources where we can inherit default write concerns from\r\n * @param options - optional settings passed into a command for write concern overrides\r\n */\r\nexport function applyWriteConcern<T extends HasWriteConcern>(\r\n  target: T,\r\n  sources: { db?: Db; collection?: Collection },\r\n  options?: OperationOptions & WriteConcernOptions\r\n): T {\r\n  options = options ?? {};\r\n  const db = sources.db;\r\n  const coll = sources.collection;\r\n\r\n  if (options.session && options.session.inTransaction()) {\r\n    // writeConcern is not allowed within a multi-statement transaction\r\n    if (target.writeConcern) {\r\n      delete target.writeConcern;\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  const writeConcern = WriteConcern.fromOptions(options);\r\n  if (writeConcern) {\r\n    return Object.assign(target, { writeConcern });\r\n  }\r\n\r\n  if (coll && coll.writeConcern) {\r\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\r\n  }\r\n\r\n  if (db && db.writeConcern) {\r\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Checks if a given value is a Promise\r\n *\r\n * @typeParam T - The result type of maybePromise\r\n * @param maybePromise - An object that could be a promise\r\n * @returns true if the provided value is a Promise\r\n */\r\nexport function isPromiseLike<T = any>(\r\n  maybePromise?: PromiseLike<T> | void\r\n): maybePromise is Promise<T> {\r\n  return !!maybePromise && typeof maybePromise.then === 'function';\r\n}\r\n\r\n/**\r\n * Applies collation to a given command.\r\n * @internal\r\n *\r\n * @param command - the command on which to apply collation\r\n * @param target - target of command\r\n * @param options - options containing collation settings\r\n */\r\nexport function decorateWithCollation(\r\n  command: Document,\r\n  target: MongoClient | Db | Collection,\r\n  options: AnyOptions\r\n): void {\r\n  const capabilities = getTopology(target).capabilities;\r\n  if (options.collation && typeof options.collation === 'object') {\r\n    if (capabilities && capabilities.commandsTakeCollation) {\r\n      command.collation = options.collation;\r\n    } else {\r\n      throw new MongoCompatibilityError(`Current topology does not support collation`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Applies a read concern to a given command.\r\n * @internal\r\n *\r\n * @param command - the command on which to apply the read concern\r\n * @param coll - the parent collection of the operation calling this method\r\n */\r\nexport function decorateWithReadConcern(\r\n  command: Document,\r\n  coll: { s: { readConcern?: ReadConcern } },\r\n  options?: OperationOptions\r\n): void {\r\n  if (options && options.session && options.session.inTransaction()) {\r\n    return;\r\n  }\r\n  const readConcern = Object.assign({}, command.readConcern || {});\r\n  if (coll.s.readConcern) {\r\n    Object.assign(readConcern, coll.s.readConcern);\r\n  }\r\n\r\n  if (Object.keys(readConcern).length > 0) {\r\n    Object.assign(command, { readConcern: readConcern });\r\n  }\r\n}\r\n\r\n/**\r\n * Applies an explain to a given command.\r\n * @internal\r\n *\r\n * @param command - the command on which to apply the explain\r\n * @param options - the options containing the explain verbosity\r\n */\r\nexport function decorateWithExplain(command: Document, explain: Explain): Document {\r\n  if (command.explain) {\r\n    return command;\r\n  }\r\n\r\n  return { explain: command, verbosity: explain.verbosity };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type TopologyProvider =\r\n  | MongoClient\r\n  | ClientSession\r\n  | FindCursor\r\n  | AbstractCursor\r\n  | Collection<any>\r\n  | Db;\r\n\r\n/**\r\n * A helper function to get the topology from a given provider. Throws\r\n * if the topology cannot be found.\r\n * @throws MongoNotConnectedError\r\n * @internal\r\n */\r\nexport function getTopology(provider: TopologyProvider): Topology {\r\n  // MongoClient or ClientSession or AbstractCursor\r\n  if (`topology` in provider && provider.topology) {\r\n    return provider.topology;\r\n  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\r\n    return provider.s.client.topology;\r\n  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\r\n    return provider.s.db.s.client.topology;\r\n  }\r\n\r\n  throw new MongoNotConnectedError('MongoClient must be connected to perform this operation');\r\n}\r\n\r\n/**\r\n * Default message handler for generating deprecation warnings.\r\n * @internal\r\n *\r\n * @param name - function name\r\n * @param option - option name\r\n * @returns warning message\r\n */\r\nexport function defaultMsgHandler(name: string, option: string): string {\r\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\r\n}\r\n\r\nexport interface DeprecateOptionsConfig {\r\n  /** function name */\r\n  name: string;\r\n  /** options to deprecate */\r\n  deprecatedOptions: string[];\r\n  /** index of options object in function arguments array */\r\n  optionsIndex: number;\r\n  /** optional custom message handler to generate warnings */\r\n  msgHandler?(name: string, option: string): string;\r\n}\r\n\r\n/**\r\n * Deprecates a given function's options.\r\n * @internal\r\n *\r\n * @param this - the bound class if this is a method\r\n * @param config - configuration for deprecation\r\n * @param fn - the target function of deprecation\r\n * @returns modified function that warns once per deprecated option, and executes original function\r\n */\r\nexport function deprecateOptions(\r\n  this: unknown,\r\n  config: DeprecateOptionsConfig,\r\n  fn: (...args: any[]) => any\r\n): any {\r\n  if ((process as any).noDeprecation === true) {\r\n    return fn;\r\n  }\r\n\r\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\r\n\r\n  const optionsWarned = new Set();\r\n  function deprecated(this: any, ...args: any[]) {\r\n    const options = args[config.optionsIndex] as AnyOptions;\r\n\r\n    // ensure options is a valid, non-empty object, otherwise short-circuit\r\n    if (!isObject(options) || Object.keys(options).length === 0) {\r\n      return fn.bind(this)(...args); // call the function, no change\r\n    }\r\n\r\n    // interrupt the function call with a warning\r\n    for (const deprecatedOption of config.deprecatedOptions) {\r\n      if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\r\n        optionsWarned.add(deprecatedOption);\r\n        const msg = msgHandler(config.name, deprecatedOption);\r\n        emitWarning(msg);\r\n        if (this && 'getLogger' in this) {\r\n          const logger = this.getLogger();\r\n          if (logger) {\r\n            logger.warn(msg);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return fn.bind(this)(...args);\r\n  }\r\n\r\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\r\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\r\n  Object.setPrototypeOf(deprecated, fn);\r\n  if (fn.prototype) {\r\n    // Setting this (rather than using Object.setPrototype, as above) ensures\r\n    // that calling the unwrapped constructor gives an instanceof the wrapped\r\n    // constructor.\r\n    deprecated.prototype = fn.prototype;\r\n  }\r\n\r\n  return deprecated;\r\n}\r\n\r\n/** @internal */\r\nexport function ns(ns: string): MongoDBNamespace {\r\n  return MongoDBNamespace.fromString(ns);\r\n}\r\n\r\n/** @public */\r\nexport class MongoDBNamespace {\r\n  db: string;\r\n  collection?: string;\r\n  /**\r\n   * Create a namespace object\r\n   *\r\n   * @param db - database name\r\n   * @param collection - collection name\r\n   */\r\n  constructor(db: string, collection?: string) {\r\n    this.db = db;\r\n    this.collection = collection;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\r\n  }\r\n\r\n  withCollection(collection: string): MongoDBNamespace {\r\n    return new MongoDBNamespace(this.db, collection);\r\n  }\r\n\r\n  static fromString(namespace?: string): MongoDBNamespace {\r\n    if (!namespace) {\r\n      // TODO(NODE-3483): Replace with MongoNamespaceError\r\n      throw new MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\r\n    }\r\n\r\n    const [db, ...collection] = namespace.split('.');\r\n    return new MongoDBNamespace(db, collection.join('.'));\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport function* makeCounter(seed = 0): Generator<number> {\r\n  let count = seed;\r\n  while (true) {\r\n    const newCount = count;\r\n    count += 1;\r\n    yield newCount;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper function for either accepting a callback, or returning a promise\r\n * @internal\r\n *\r\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\r\n * @param wrapper - A function that wraps the callback\r\n * @returns Returns void if a callback is supplied, else returns a Promise.\r\n */\r\nexport function maybePromise<T>(\r\n  callback: Callback<T> | undefined,\r\n  wrapper: (fn: Callback<T>) => void\r\n): Promise<T> | void {\r\n  const Promise = PromiseProvider.get();\r\n  let result: Promise<T> | void;\r\n  if (typeof callback !== 'function') {\r\n    result = new Promise<any>((resolve, reject) => {\r\n      callback = (err, res) => {\r\n        if (err) return reject(err);\r\n        resolve(res);\r\n      };\r\n    });\r\n  }\r\n\r\n  wrapper((err, res) => {\r\n    if (err != null) {\r\n      try {\r\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n        callback!(err);\r\n      } catch (error) {\r\n        process.nextTick(() => {\r\n          throw error;\r\n        });\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    callback!(err, res);\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n/** @internal */\r\nexport function databaseNamespace(ns: string): string {\r\n  return ns.split('.')[0];\r\n}\r\n\r\n/**\r\n * Synchronously Generate a UUIDv4\r\n * @internal\r\n */\r\nexport function uuidV4(): Buffer {\r\n  const result = crypto.randomBytes(16);\r\n  result[6] = (result[6] & 0x0f) | 0x40;\r\n  result[8] = (result[8] & 0x3f) | 0x80;\r\n  return result;\r\n}\r\n\r\n/**\r\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\r\n * @internal\r\n */\r\nexport function maxWireVersion(topologyOrServer?: Connection | Topology | Server): number {\r\n  if (topologyOrServer) {\r\n    if (topologyOrServer.loadBalanced) {\r\n      // Since we do not have a monitor, we assume the load balanced server is always\r\n      // pointed at the latest mongodb version. There is a risk that for on-prem\r\n      // deployments that don't upgrade immediately that this could alert to the\r\n      // application that a feature is avaiable that is actually not.\r\n      return MAX_SUPPORTED_WIRE_VERSION;\r\n    }\r\n    if (topologyOrServer.hello) {\r\n      return topologyOrServer.hello.maxWireVersion;\r\n    }\r\n\r\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\r\n      const lastHello = topologyOrServer.lastHello();\r\n      if (lastHello) {\r\n        return lastHello.maxWireVersion;\r\n      }\r\n    }\r\n\r\n    if (\r\n      topologyOrServer.description &&\r\n      'maxWireVersion' in topologyOrServer.description &&\r\n      topologyOrServer.description.maxWireVersion != null\r\n    ) {\r\n      return topologyOrServer.description.maxWireVersion;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Checks that collation is supported by server.\r\n * @internal\r\n *\r\n * @param server - to check against\r\n * @param cmd - object where collation may be specified\r\n */\r\nexport function collationNotSupported(server: Server, cmd: Document): boolean {\r\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\r\n}\r\n\r\n/**\r\n * Applies the function `eachFn` to each item in `arr`, in parallel.\r\n * @internal\r\n *\r\n * @param arr - An array of items to asynchronously iterate over\r\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\r\n * @param callback - The callback called after every item has been iterated\r\n */\r\nexport function eachAsync<T = Document>(\r\n  arr: T[],\r\n  eachFn: (item: T, callback: (err?: AnyError) => void) => void,\r\n  callback: Callback\r\n): void {\r\n  arr = arr || [];\r\n\r\n  let idx = 0;\r\n  let awaiting = 0;\r\n  for (idx = 0; idx < arr.length; ++idx) {\r\n    awaiting++;\r\n    eachFn(arr[idx], eachCallback);\r\n  }\r\n\r\n  if (awaiting === 0) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  function eachCallback(err?: AnyError) {\r\n    awaiting--;\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (idx === arr.length && awaiting <= 0) {\r\n      callback();\r\n    }\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport function eachAsyncSeries<T = any>(\r\n  arr: T[],\r\n  eachFn: (item: T, callback: (err?: AnyError) => void) => void,\r\n  callback: Callback\r\n): void {\r\n  arr = arr || [];\r\n\r\n  let idx = 0;\r\n  let awaiting = arr.length;\r\n  if (awaiting === 0) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  function eachCallback(err?: AnyError) {\r\n    idx++;\r\n    awaiting--;\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (idx === arr.length && awaiting <= 0) {\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    eachFn(arr[idx], eachCallback);\r\n  }\r\n\r\n  eachFn(arr[idx], eachCallback);\r\n}\r\n\r\n/** @internal */\r\nexport function arrayStrictEqual(arr: unknown[], arr2: unknown[]): boolean {\r\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\r\n    return false;\r\n  }\r\n\r\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\r\n}\r\n\r\n/** @internal */\r\nexport function errorStrictEqual(lhs?: AnyError, rhs?: AnyError): boolean {\r\n  if (lhs === rhs) {\r\n    return true;\r\n  }\r\n\r\n  if (!lhs || !rhs) {\r\n    return lhs === rhs;\r\n  }\r\n\r\n  if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\r\n    return false;\r\n  }\r\n\r\n  if (lhs.constructor.name !== rhs.constructor.name) {\r\n    return false;\r\n  }\r\n\r\n  if (lhs.message !== rhs.message) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\ninterface StateTable {\r\n  [key: string]: string[];\r\n}\r\ninterface ObjectWithState {\r\n  s: { state: string };\r\n  emit(event: 'stateChanged', state: string, newState: string): void;\r\n}\r\ninterface StateTransitionFunction {\r\n  (target: ObjectWithState, newState: string): void;\r\n}\r\n\r\n/** @public */\r\nexport type EventEmitterWithState = {\r\n  /** @internal */\r\n  stateChanged(previous: string, current: string): void;\r\n};\r\n\r\n/** @internal */\r\nexport function makeStateMachine(stateTable: StateTable): StateTransitionFunction {\r\n  return function stateTransition(target, newState) {\r\n    const legalStates = stateTable[target.s.state];\r\n    if (legalStates && legalStates.indexOf(newState) < 0) {\r\n      throw new MongoRuntimeError(\r\n        `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`\r\n      );\r\n    }\r\n\r\n    target.emit('stateChanged', target.s.state, newState);\r\n    target.s.state = newState;\r\n  };\r\n}\r\n\r\n/** @public */\r\nexport interface ClientMetadata {\r\n  driver: {\r\n    name: string;\r\n    version: string;\r\n  };\r\n  os: {\r\n    type: string;\r\n    name: NodeJS.Platform;\r\n    architecture: string;\r\n    version: string;\r\n  };\r\n  platform: string;\r\n  version?: string;\r\n  application?: {\r\n    name: string;\r\n  };\r\n}\r\n\r\n/** @public */\r\nexport interface ClientMetadataOptions {\r\n  driverInfo?: {\r\n    name?: string;\r\n    version?: string;\r\n    platform?: string;\r\n  };\r\n  appName?: string;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-var-requires\r\nconst NODE_DRIVER_VERSION = require('../package.json').version;\r\n\r\nexport function makeClientMetadata(options?: ClientMetadataOptions): ClientMetadata {\r\n  options = options ?? {};\r\n\r\n  const metadata: ClientMetadata = {\r\n    driver: {\r\n      name: 'nodejs',\r\n      version: NODE_DRIVER_VERSION\r\n    },\r\n    os: {\r\n      type: os.type(),\r\n      name: process.platform,\r\n      architecture: process.arch,\r\n      version: os.release()\r\n    },\r\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\r\n  };\r\n\r\n  // support optionally provided wrapping driver info\r\n  if (options.driverInfo) {\r\n    if (options.driverInfo.name) {\r\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\r\n    }\r\n\r\n    if (options.driverInfo.version) {\r\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\r\n    }\r\n\r\n    if (options.driverInfo.platform) {\r\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\r\n    }\r\n  }\r\n\r\n  if (options.appName) {\r\n    // MongoDB requires the appName not exceed a byte length of 128\r\n    const buffer = Buffer.from(options.appName);\r\n    metadata.application = {\r\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\r\n    };\r\n  }\r\n\r\n  return metadata;\r\n}\r\n\r\n/** @internal */\r\nexport function now(): number {\r\n  const hrtime = process.hrtime();\r\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\r\n}\r\n\r\n/** @internal */\r\nexport function calculateDurationInMs(started: number): number {\r\n  if (typeof started !== 'number') {\r\n    throw new MongoInvalidArgumentError('Numeric value required to calculate duration');\r\n  }\r\n\r\n  const elapsed = now() - started;\r\n  return elapsed < 0 ? 0 : elapsed;\r\n}\r\n\r\nexport interface InterruptibleAsyncIntervalOptions {\r\n  /** The interval to execute a method on */\r\n  interval: number;\r\n  /** A minimum interval that must elapse before the method is called */\r\n  minInterval: number;\r\n  /** Whether the method should be called immediately when the interval is started  */\r\n  immediate: boolean;\r\n\r\n  /**\r\n   * Only used for testing unreliable timer environments\r\n   * @internal\r\n   */\r\n  clock: () => number;\r\n}\r\n\r\n/** @internal */\r\nexport interface InterruptibleAsyncInterval {\r\n  wake(): void;\r\n  stop(): void;\r\n}\r\n\r\n/**\r\n * Creates an interval timer which is able to be woken up sooner than\r\n * the interval. The timer will also debounce multiple calls to wake\r\n * ensuring that the function is only ever called once within a minimum\r\n * interval window.\r\n * @internal\r\n *\r\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\r\n */\r\nexport function makeInterruptibleAsyncInterval(\r\n  fn: (callback: Callback) => void,\r\n  options?: Partial<InterruptibleAsyncIntervalOptions>\r\n): InterruptibleAsyncInterval {\r\n  let timerId: NodeJS.Timeout | undefined;\r\n  let lastCallTime: number;\r\n  let cannotBeExpedited = false;\r\n  let stopped = false;\r\n\r\n  options = options ?? {};\r\n  const interval = options.interval || 1000;\r\n  const minInterval = options.minInterval || 500;\r\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\r\n  const clock = typeof options.clock === 'function' ? options.clock : now;\r\n\r\n  function wake() {\r\n    const currentTime = clock();\r\n    const nextScheduledCallTime = lastCallTime + interval;\r\n    const timeUntilNextCall = nextScheduledCallTime - currentTime;\r\n\r\n    // For the streaming protocol: there is nothing obviously stopping this\r\n    // interval from being woken up again while we are waiting \"infinitely\"\r\n    // for `fn` to be called again`. Since the function effectively\r\n    // never completes, the `timeUntilNextCall` will continue to grow\r\n    // negatively unbounded, so it will never trigger a reschedule here.\r\n\r\n    // This is possible in virtualized environments like AWS Lambda where our\r\n    // clock is unreliable. In these cases the timer is \"running\" but never\r\n    // actually completes, so we want to execute immediately and then attempt\r\n    // to reschedule.\r\n    if (timeUntilNextCall < 0) {\r\n      executeAndReschedule();\r\n      return;\r\n    }\r\n\r\n    // debounce multiple calls to wake within the `minInterval`\r\n    if (cannotBeExpedited) {\r\n      return;\r\n    }\r\n\r\n    // reschedule a call as soon as possible, ensuring the call never happens\r\n    // faster than the `minInterval`\r\n    if (timeUntilNextCall > minInterval) {\r\n      reschedule(minInterval);\r\n      cannotBeExpedited = true;\r\n    }\r\n  }\r\n\r\n  function stop() {\r\n    stopped = true;\r\n    if (timerId) {\r\n      clearTimeout(timerId);\r\n      timerId = undefined;\r\n    }\r\n\r\n    lastCallTime = 0;\r\n    cannotBeExpedited = false;\r\n  }\r\n\r\n  function reschedule(ms?: number) {\r\n    if (stopped) return;\r\n    if (timerId) {\r\n      clearTimeout(timerId);\r\n    }\r\n\r\n    timerId = setTimeout(executeAndReschedule, ms || interval);\r\n  }\r\n\r\n  function executeAndReschedule() {\r\n    cannotBeExpedited = false;\r\n    lastCallTime = clock();\r\n\r\n    fn(err => {\r\n      if (err) throw err;\r\n      reschedule(interval);\r\n    });\r\n  }\r\n\r\n  if (immediate) {\r\n    executeAndReschedule();\r\n  } else {\r\n    lastCallTime = clock();\r\n    reschedule(undefined);\r\n  }\r\n\r\n  return { wake, stop };\r\n}\r\n\r\n/** @internal */\r\nexport function hasAtomicOperators(doc: Document | Document[]): boolean {\r\n  if (Array.isArray(doc)) {\r\n    for (const document of doc) {\r\n      if (hasAtomicOperators(document)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  const keys = Object.keys(doc);\r\n  return keys.length > 0 && keys[0][0] === '$';\r\n}\r\n\r\n/**\r\n * Merge inherited properties from parent into options, prioritizing values from options,\r\n * then values from parent.\r\n * @internal\r\n */\r\nexport function resolveOptions<T extends CommandOperationOptions>(\r\n  parent: OperationParent | undefined,\r\n  options?: T\r\n): T {\r\n  const result: T = Object.assign({}, options, resolveBSONOptions(options, parent));\r\n\r\n  // Users cannot pass a readConcern/writeConcern to operations in a transaction\r\n  const session = options?.session;\r\n  if (!session?.inTransaction()) {\r\n    const readConcern = ReadConcern.fromOptions(options) ?? parent?.readConcern;\r\n    if (readConcern) {\r\n      result.readConcern = readConcern;\r\n    }\r\n\r\n    const writeConcern = WriteConcern.fromOptions(options) ?? parent?.writeConcern;\r\n    if (writeConcern) {\r\n      result.writeConcern = writeConcern;\r\n    }\r\n  }\r\n\r\n  const readPreference = ReadPreference.fromOptions(options) ?? parent?.readPreference;\r\n  if (readPreference) {\r\n    result.readPreference = readPreference;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function isSuperset(set: Set<any> | any[], subset: Set<any> | any[]): boolean {\r\n  set = Array.isArray(set) ? new Set(set) : set;\r\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\r\n  for (const elem of subset) {\r\n    if (!set.has(elem)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Checks if the document is a Hello request\r\n * @internal\r\n */\r\nexport function isHello(doc: Document): boolean {\r\n  return doc[LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\r\n}\r\n\r\n/** Returns the items that are uniquely in setA */\r\nexport function setDifference<T>(setA: Iterable<T>, setB: Iterable<T>): Set<T> {\r\n  const difference = new Set<T>(setA);\r\n  for (const elem of setB) {\r\n    difference.delete(elem);\r\n  }\r\n  return difference;\r\n}\r\n\r\nexport function isRecord<T extends readonly string[]>(\r\n  value: unknown,\r\n  requiredKeys: T\r\n): value is Record<T[number], any>;\r\nexport function isRecord(value: unknown): value is Record<string, any>;\r\nexport function isRecord(\r\n  value: unknown,\r\n  requiredKeys: string[] | undefined = undefined\r\n): value is Record<string, any> {\r\n  const toString = Object.prototype.toString;\r\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\r\n  const isObject = (v: unknown) => toString.call(v) === '[object Object]';\r\n  if (!isObject(value)) {\r\n    return false;\r\n  }\r\n\r\n  const ctor = (value as any).constructor;\r\n  if (ctor && ctor.prototype) {\r\n    if (!isObject(ctor.prototype)) {\r\n      return false;\r\n    }\r\n\r\n    // Check to see if some method exists from the Object exists\r\n    if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (requiredKeys) {\r\n    const keys = Object.keys(value as Record<string, any>);\r\n    return isSuperset(keys, requiredKeys);\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Make a deep copy of an object\r\n *\r\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\r\n * but instead something that is good enough for the purposes of\r\n * command monitoring.\r\n */\r\nexport function deepCopy<T>(value: T): T {\r\n  if (value == null) {\r\n    return value;\r\n  } else if (Array.isArray(value)) {\r\n    return value.map(item => deepCopy(item)) as unknown as T;\r\n  } else if (isRecord(value)) {\r\n    const res = {} as any;\r\n    for (const key in value) {\r\n      res[key] = deepCopy(value[key]);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  const ctor = (value as any).constructor;\r\n  if (ctor) {\r\n    switch (ctor.name.toLowerCase()) {\r\n      case 'date':\r\n        return new ctor(Number(value));\r\n      case 'map':\r\n        return new Map(value as any) as unknown as T;\r\n      case 'set':\r\n        return new Set(value as any) as unknown as T;\r\n      case 'buffer':\r\n        return Buffer.from(value as unknown as Buffer) as unknown as T;\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n/** @internal */\r\nconst kBuffers = Symbol('buffers');\r\n/** @internal */\r\nconst kLength = Symbol('length');\r\n\r\n/**\r\n * A pool of Buffers which allow you to read them as if they were one\r\n * @internal\r\n */\r\nexport class BufferPool {\r\n  [kBuffers]: Buffer[];\r\n  [kLength]: number;\r\n\r\n  constructor() {\r\n    this[kBuffers] = [];\r\n    this[kLength] = 0;\r\n  }\r\n\r\n  get length(): number {\r\n    return this[kLength];\r\n  }\r\n\r\n  /** Adds a buffer to the internal buffer pool list */\r\n  append(buffer: Buffer): void {\r\n    this[kBuffers].push(buffer);\r\n    this[kLength] += buffer.length;\r\n  }\r\n\r\n  /** Returns the requested number of bytes without consuming them */\r\n  peek(size: number): Buffer {\r\n    return this.read(size, false);\r\n  }\r\n\r\n  /** Reads the requested number of bytes, optionally consuming them */\r\n  read(size: number, consume = true): Buffer {\r\n    if (typeof size !== 'number' || size < 0) {\r\n      throw new MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\r\n    }\r\n\r\n    if (size > this[kLength]) {\r\n      return Buffer.alloc(0);\r\n    }\r\n\r\n    let result: Buffer;\r\n\r\n    // read the whole buffer\r\n    if (size === this.length) {\r\n      result = Buffer.concat(this[kBuffers]);\r\n\r\n      if (consume) {\r\n        this[kBuffers] = [];\r\n        this[kLength] = 0;\r\n      }\r\n    }\r\n\r\n    // size is within first buffer, no need to concat\r\n    else if (size <= this[kBuffers][0].length) {\r\n      result = this[kBuffers][0].slice(0, size);\r\n      if (consume) {\r\n        this[kBuffers][0] = this[kBuffers][0].slice(size);\r\n        this[kLength] -= size;\r\n      }\r\n    }\r\n\r\n    // size is beyond first buffer, need to track and copy\r\n    else {\r\n      result = Buffer.allocUnsafe(size);\r\n\r\n      let idx;\r\n      let offset = 0;\r\n      let bytesToCopy = size;\r\n      for (idx = 0; idx < this[kBuffers].length; ++idx) {\r\n        let bytesCopied;\r\n        if (bytesToCopy > this[kBuffers][idx].length) {\r\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\r\n          offset += bytesCopied;\r\n        } else {\r\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\r\n          if (consume) {\r\n            this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\r\n          }\r\n          offset += bytesCopied;\r\n          break;\r\n        }\r\n\r\n        bytesToCopy -= bytesCopied;\r\n      }\r\n\r\n      // compact the internal buffer array\r\n      if (consume) {\r\n        this[kBuffers] = this[kBuffers].slice(idx);\r\n        this[kLength] -= size;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\n/** @public */\r\nexport class HostAddress {\r\n  host;\r\n  port;\r\n  // Driver only works with unix socket path to connect\r\n  // SDAM operates only on tcp addresses\r\n  socketPath;\r\n  isIPv6;\r\n\r\n  constructor(hostString: string) {\r\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\r\n    const { hostname, port } = new URL(`mongodb://${escapedHost}`);\r\n\r\n    if (hostname.endsWith('.sock')) {\r\n      // heuristically determine if we're working with a domain socket\r\n      this.socketPath = decodeURIComponent(hostname);\r\n    } else if (typeof hostname === 'string') {\r\n      this.isIPv6 = false;\r\n\r\n      let normalized = decodeURIComponent(hostname).toLowerCase();\r\n      if (normalized.startsWith('[') && normalized.endsWith(']')) {\r\n        this.isIPv6 = true;\r\n        normalized = normalized.substring(1, hostname.length - 1);\r\n      }\r\n\r\n      this.host = normalized.toLowerCase();\r\n\r\n      if (typeof port === 'number') {\r\n        this.port = port;\r\n      } else if (typeof port === 'string' && port !== '') {\r\n        this.port = Number.parseInt(port, 10);\r\n      } else {\r\n        this.port = 27017;\r\n      }\r\n\r\n      if (this.port === 0) {\r\n        throw new MongoParseError('Invalid port (zero) with hostname');\r\n      }\r\n    } else {\r\n      throw new MongoInvalidArgumentError('Either socketPath or host must be defined.');\r\n    }\r\n    Object.freeze(this);\r\n  }\r\n\r\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\r\n    return this.inspect();\r\n  }\r\n\r\n  inspect(): string {\r\n    return `new HostAddress('${this.toString(true)}')`;\r\n  }\r\n\r\n  /**\r\n   * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\r\n   */\r\n  toString(ipv6Brackets = false): string {\r\n    if (typeof this.host === 'string') {\r\n      if (this.isIPv6 && ipv6Brackets) {\r\n        return `[${this.host}]:${this.port}`;\r\n      }\r\n      return `${this.host}:${this.port}`;\r\n    }\r\n    return `${this.socketPath}`;\r\n  }\r\n\r\n  static fromString(s: string): HostAddress {\r\n    return new HostAddress(s);\r\n  }\r\n\r\n  static fromHostPort(host: string, port: number): HostAddress {\r\n    if (host.includes(':')) {\r\n      host = `[${host}]`; // IPv6 address\r\n    }\r\n    return HostAddress.fromString(`${host}:${port}`);\r\n  }\r\n\r\n  static fromSrvRecord({ name, port }: SrvRecord): HostAddress {\r\n    return HostAddress.fromHostPort(name, port);\r\n  }\r\n}\r\n\r\nexport const DEFAULT_PK_FACTORY = {\r\n  // We prefer not to rely on ObjectId having a createPk method\r\n  createPk(): ObjectId {\r\n    return new ObjectId();\r\n  }\r\n};\r\n\r\n/**\r\n * When the driver used emitWarning the code will be equal to this.\r\n * @public\r\n *\r\n * @example\r\n * ```js\r\n * process.on('warning', (warning) => {\r\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\r\n * })\r\n * ```\r\n */\r\nexport const MONGODB_WARNING_CODE = 'MONGODB DRIVER' as const;\r\n\r\n/** @internal */\r\nexport function emitWarning(message: string): void {\r\n  return process.emitWarning(message, { code: MONGODB_WARNING_CODE } as any);\r\n}\r\n\r\nconst emittedWarnings = new Set();\r\n/**\r\n * Will emit a warning once for the duration of the application.\r\n * Uses the message to identify if it has already been emitted\r\n * so using string interpolation can cause multiple emits\r\n * @internal\r\n */\r\nexport function emitWarningOnce(message: string): void {\r\n  if (!emittedWarnings.has(message)) {\r\n    emittedWarnings.add(message);\r\n    return emitWarning(message);\r\n  }\r\n}\r\n\r\n/**\r\n * Takes a JS object and joins the values into a string separated by ', '\r\n */\r\nexport function enumToString(en: Record<string, unknown>): string {\r\n  return Object.values(en).join(', ');\r\n}\r\n\r\n/**\r\n * Determine if a server supports retryable writes.\r\n *\r\n * @internal\r\n */\r\nexport function supportsRetryableWrites(server?: Server): boolean {\r\n  if (!server) {\r\n    return false;\r\n  }\r\n\r\n  if (server.loadBalanced) {\r\n    // Loadbalanced topologies will always support retry writes\r\n    return true;\r\n  }\r\n\r\n  if (server.description.logicalSessionTimeoutMinutes != null) {\r\n    // that supports sessions\r\n    if (server.description.type !== ServerType.Standalone) {\r\n      // and that is not a standalone\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function parsePackageVersion({ version }: { version: string }): {\r\n  major: number;\r\n  minor: number;\r\n  patch: number;\r\n} {\r\n  const [major, minor, patch] = version.split('.').map((n: string) => Number.parseInt(n, 10));\r\n  return { major, minor, patch };\r\n}\r\n\r\n/**\r\n * Fisher–Yates Shuffle\r\n *\r\n * Reference: https://bost.ocks.org/mike/shuffle/\r\n * @param sequence - items to be shuffled\r\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\r\n */\r\nexport function shuffle<T>(sequence: Iterable<T>, limit = 0): Array<T> {\r\n  const items = Array.from(sequence); // shallow copy in order to never shuffle the input\r\n\r\n  if (limit > items.length) {\r\n    throw new MongoRuntimeError('Limit must be less than the number of items');\r\n  }\r\n\r\n  let remainingItemsToShuffle = items.length;\r\n  const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\r\n  while (remainingItemsToShuffle > lowerBound) {\r\n    // Pick a remaining element\r\n    const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\r\n    remainingItemsToShuffle -= 1;\r\n\r\n    // And swap it with the current element\r\n    const swapHold = items[remainingItemsToShuffle];\r\n    items[remainingItemsToShuffle] = items[randomIndex];\r\n    items[randomIndex] = swapHold;\r\n  }\r\n\r\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\r\n}\r\n\r\n// TODO: this should be codified in command construction\r\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\r\nexport function commandSupportsReadConcern(command: Document, options?: Document): boolean {\r\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\r\n    return true;\r\n  }\r\n\r\n  if (\r\n    command.mapReduce &&\r\n    options &&\r\n    options.out &&\r\n    (options.out.inline === 1 || options.out === 'inline')\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}