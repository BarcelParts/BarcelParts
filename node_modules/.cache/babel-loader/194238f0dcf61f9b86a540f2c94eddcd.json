{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst common_1 = require(\"./common\"); // max staleness constants\n\n\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90; //  Minimum version to try writes on secondaries.\n\nexports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n/**\n * Returns a server selector that selects for writable servers\n */\n\nfunction writableServerSelector() {\n  return (topologyDescription, servers) => latencyWindowReducer(topologyDescription, servers.filter(s => s.isWritable));\n}\n\nexports.writableServerSelector = writableServerSelector;\n/**\n * The purpose of this selector is to select the same server, only\n * if it is in a state that it can have commands sent to it.\n */\n\nfunction sameServerSelector(description) {\n  return (topologyDescription, servers) => {\n    if (!description) return []; // Filter the servers to match the provided description only if\n    // the type is not unknown.\n\n    return servers.filter(sd => {\n      return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;\n    });\n  };\n}\n\nexports.sameServerSelector = sameServerSelector;\n/**\n * Returns a server selector that uses a read preference to select a\n * server potentially for a write on a secondary.\n */\n\nfunction secondaryWritableServerSelector(wireVersion, readPreference) {\n  // If server version < 5.0, read preference always primary.\n  // If server version >= 5.0...\n  // - If read preference is supplied, use that.\n  // - If no read preference is supplied, use primary.\n  if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {\n    return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);\n  }\n\n  return readPreferenceServerSelector(readPreference);\n}\n\nexports.secondaryWritableServerSelector = secondaryWritableServerSelector;\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\n\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n\n  if (maxStaleness < maxStalenessVariance) {\n    throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`);\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);\n  }\n\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {\n    const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      var _a;\n\n      const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n    return servers.reduce((result, server) => {\n      var _a;\n\n      const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\n\n\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\n\n\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\n\n\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n} // filters\n\n\nfunction primaryFilter(server) {\n  return server.type === common_1.ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== common_1.ServerType.Unknown;\n}\n\nfunction loadBalancerFilter(server) {\n  return server.type === common_1.ServerType.LoadBalancer;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\n\n\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');\n  }\n\n  return (topologyDescription, servers) => {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);\n    }\n\n    if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n\n    if (topologyDescription.type === common_1.TopologyType.Unknown) {\n      return [];\n    }\n\n    if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n\n    if (mode === read_preference_1.ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n\n    if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n\nexports.readPreferenceServerSelector = readPreferenceServerSelector;","map":{"version":3,"mappings":"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","names":["IDLE_WRITE_PERIOD","SMALLEST_MAX_STALENESS_SECONDS","exports","writableServerSelector","topologyDescription","servers","latencyWindowReducer","filter","s","isWritable","sameServerSelector","description","sd","address","type","common_1","Unknown","secondaryWritableServerSelector","wireVersion","readPreference","readPreferenceServerSelector","read_preference_1","primary","maxStalenessReducer","maxStalenessSeconds","maxStaleness","maxStalenessVariance","heartbeatFrequencyMS","error_1","ReplicaSetWithPrimary","Array","from","values","primaryFilter","reduce","result","server","stalenessMS","lastUpdateTime","lastWriteDate","staleness","_a","push","ReplicaSetNoPrimary","length","sMax","max","tagSetMatch","tagSet","serverTags","keys","Object","serverTagKeys","i","key","indexOf","tagSetReducer","tags","isArray","serversMatchingTagset","matched","low","min","roundTripTime","Math","high","localThresholdMS","RSPrimary","secondaryFilter","RSSecondary","nearestFilter","knownFilter","loadBalancerFilter","LoadBalancer","isValid","commonWireVersion","minWireVersion","LoadBalanced","Single","Sharded","mode","PRIMARY","PRIMARY_PREFERRED","NEAREST","selectedServers","SECONDARY_PREFERRED"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\sdam\\server_selection.ts"],"sourcesContent":["import { MongoCompatibilityError, MongoInvalidArgumentError } from '../error';\nimport { ReadPreference } from '../read_preference';\nimport { ServerType, TopologyType } from './common';\nimport type { ServerDescription, TagSet } from './server_description';\nimport type { TopologyDescription } from './topology_description';\n\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n\n//  Minimum version to try writes on secondaries.\nexport const MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n\n/** @public */\nexport type ServerSelector = (\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n) => ServerDescription[];\n\n/**\n * Returns a server selector that selects for writable servers\n */\nexport function writableServerSelector(): ServerSelector {\n  return (\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] =>\n    latencyWindowReducer(\n      topologyDescription,\n      servers.filter((s: ServerDescription) => s.isWritable)\n    );\n}\n\n/**\n * The purpose of this selector is to select the same server, only\n * if it is in a state that it can have commands sent to it.\n */\nexport function sameServerSelector(description?: ServerDescription): ServerSelector {\n  return (\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] => {\n    if (!description) return [];\n    // Filter the servers to match the provided description only if\n    // the type is not unknown.\n    return servers.filter(sd => {\n      return sd.address === description.address && sd.type !== ServerType.Unknown;\n    });\n  };\n}\n\n/**\n * Returns a server selector that uses a read preference to select a\n * server potentially for a write on a secondary.\n */\nexport function secondaryWritableServerSelector(\n  wireVersion?: number,\n  readPreference?: ReadPreference\n): ServerSelector {\n  // If server version < 5.0, read preference always primary.\n  // If server version >= 5.0...\n  // - If read preference is supplied, use that.\n  // - If no read preference is supplied, use primary.\n  if (\n    !readPreference ||\n    !wireVersion ||\n    (wireVersion && wireVersion < MIN_SECONDARY_WRITE_WIRE_VERSION)\n  ) {\n    return readPreferenceServerSelector(ReadPreference.primary);\n  }\n  return readPreferenceServerSelector(readPreference);\n}\n\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(\n  readPreference: ReadPreference,\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance =\n    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoInvalidArgumentError(\n      `Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`\n    );\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoInvalidArgumentError(\n      `Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`\n    );\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary: ServerDescription = Array.from(topologyDescription.servers.values()).filter(\n      primaryFilter\n    )[0];\n\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n      const stalenessMS =\n        server.lastUpdateTime -\n        server.lastWriteDate -\n        (primary.lastUpdateTime - primary.lastWriteDate) +\n        topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max: ServerDescription, s: ServerDescription) =>\n      s.lastWriteDate > max.lastWriteDate ? s : max\n    );\n\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n      const stalenessMS =\n        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\nfunction tagSetMatch(tagSet: TagSet, serverTags: TagSet) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\nfunction tagSetReducer(\n  readPreference: ReadPreference,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  if (\n    readPreference.tags == null ||\n    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)\n  ) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce(\n      (matched: ServerDescription[], server: ServerDescription) => {\n        if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n        return matched;\n      },\n      []\n    );\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  const low = servers.reduce(\n    (min: number, server: ServerDescription) =>\n      min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min),\n    -1\n  );\n\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n\n// filters\nfunction primaryFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server: ServerDescription): boolean {\n  return server.type !== ServerType.Unknown;\n}\n\nfunction loadBalancerFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.LoadBalancer;\n}\n\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\nexport function readPreferenceServerSelector(readPreference: ReadPreference): ServerSelector {\n  if (!readPreference.isValid()) {\n    throw new MongoInvalidArgumentError('Invalid read preference specified');\n  }\n\n  return (\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] => {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (\n      commonWireVersion &&\n      readPreference.minWireVersion &&\n      readPreference.minWireVersion > commonWireVersion\n    ) {\n      throw new MongoCompatibilityError(\n        `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`\n      );\n    }\n\n    if (topologyDescription.type === TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (\n      topologyDescription.type === TopologyType.Single ||\n      topologyDescription.type === TopologyType.Sharded\n    ) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(\n      topologyDescription,\n      tagSetReducer(\n        readPreference,\n        maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))\n      )\n    );\n\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n"]},"metadata":{},"sourceType":"script"}