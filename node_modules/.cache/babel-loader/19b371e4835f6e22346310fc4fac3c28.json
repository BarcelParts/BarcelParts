{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TopologyDescription = void 0;\n\nconst WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst common_1 = require(\"./common\");\n\nconst server_description_1 = require(\"./server_description\"); // constants related to compatibility checks\n\n\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set([common_1.ServerType.RSSecondary, common_1.ServerType.RSArbiter, common_1.ServerType.RSOther]);\n/**\r\n * Representation of a deployment of servers\r\n * @public\r\n */\n\nclass TopologyDescription {\n  /**\r\n   * Create a TopologyDescription\r\n   */\n  constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    var _a, _b;\n\n    options = options !== null && options !== void 0 ? options : {};\n    this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n    this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;\n    this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 0;\n\n    if (setName) {\n      this.setName = setName;\n    }\n\n    if (maxSetVersion) {\n      this.maxSetVersion = maxSetVersion;\n    }\n\n    if (maxElectionId) {\n      this.maxElectionId = maxElectionId;\n    }\n\n    if (commonWireVersion) {\n      this.commonWireVersion = commonWireVersion;\n    } // determine server compatibility\n\n\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    } // Whenever a client updates the TopologyDescription from a hello response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n\n\n    this.logicalSessionTimeoutMinutes = undefined;\n\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = undefined;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        } // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n\n\n        this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n      }\n    }\n  }\n  /**\r\n   * Returns a new TopologyDescription based on the SrvPollingEvent\r\n   * @internal\r\n   */\n\n\n  updateFromSrvPollingEvent(ev) {\n    let srvMaxHosts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    /** The SRV addresses defines the set of addresses we should be using */\n    const incomingHostnames = ev.hostnames();\n    const currentHostnames = new Set(this.servers.keys());\n    const hostnamesToAdd = new Set(incomingHostnames);\n    const hostnamesToRemove = new Set();\n\n    for (const hostname of currentHostnames) {\n      // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\n      hostnamesToAdd.delete(hostname);\n\n      if (!incomingHostnames.has(hostname)) {\n        // If the SRV Records no longer include this hostname\n        // we have to stop using it\n        hostnamesToRemove.add(hostname);\n      }\n    }\n\n    if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\n      // No new hosts to add and none to remove\n      return this;\n    }\n\n    const serverDescriptions = new Map(this.servers);\n\n    for (const removedHost of hostnamesToRemove) {\n      serverDescriptions.delete(removedHost);\n    }\n\n    if (hostnamesToAdd.size > 0) {\n      if (srvMaxHosts === 0) {\n        // Add all!\n        for (const hostToAdd of hostnamesToAdd) {\n          serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));\n        }\n      } else if (serverDescriptions.size < srvMaxHosts) {\n        // Add only the amount needed to get us back to srvMaxHosts\n        const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\n\n        for (const selectedHostToAdd of selectedHosts) {\n          serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));\n        }\n      }\n    }\n\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n  /**\r\n   * Returns a copy of this description updated with a given ServerDescription\r\n   * @internal\r\n   */\n\n\n  update(serverDescription) {\n    const address = serverDescription.address; // potentially mutated values\n\n    let {\n      type: topologyType,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion\n    } = this;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new server_description_1.ServerDescription(address, undefined);\n    }\n\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers); // update common wire version\n\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    } // update the actual server description\n\n\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === common_1.TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n        heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n        localThresholdMS: this.localThresholdMS\n      });\n    }\n\n    if (topologyType === common_1.TopologyType.Unknown) {\n      if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n\n    return;\n  }\n  /**\r\n   * Determines if the topology description has any known servers\r\n   */\n\n\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== common_1.ServerType.Unknown);\n  }\n  /**\r\n   * Determines if this topology description has a data-bearing server available.\r\n   */\n\n\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n  /**\r\n   * Determines if the topology has a definition for the provided address\r\n   * @internal\r\n   */\n\n\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n\n}\n\nexports.TopologyDescription = TopologyDescription;\n\nfunction topologyTypeForServerType(serverType) {\n  switch (serverType) {\n    case common_1.ServerType.Standalone:\n      return common_1.TopologyType.Single;\n\n    case common_1.ServerType.Mongos:\n      return common_1.TopologyType.Sharded;\n\n    case common_1.ServerType.RSPrimary:\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n\n    case common_1.ServerType.RSOther:\n    case common_1.ServerType.RSSecondary:\n      return common_1.TopologyType.ReplicaSetNoPrimary;\n\n    default:\n      return common_1.TopologyType.Unknown;\n  }\n} // TODO: improve these docs when ObjectId is properly typed\n\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new server_description_1.ServerDescription(server.address)); // There can only be one primary\n\n      break;\n    }\n  } // Discover new hosts from this primary's response.\n\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === common_1.ServerType.RSPrimary) {\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return common_1.TopologyType.ReplicaSetNoPrimary;\n}","map":{"version":3,"mappings":"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","names":["MIN_SUPPORTED_SERVER_VERSION","WIRE_CONSTANTS","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","MONGOS_OR_UNKNOWN","Set","common_1","Mongos","Unknown","MONGOS_OR_STANDALONE","Standalone","NON_PRIMARY_RS_MEMBERS","RSSecondary","RSArbiter","RSOther","TopologyDescription","constructor","topologyType","serverDescriptions","setName","maxSetVersion","maxElectionId","commonWireVersion","options","type","servers","Map","stale","compatible","heartbeatFrequencyMS","_a","localThresholdMS","_b","serverDescription","values","LoadBalancer","minWireVersion","compatibilityError","address","maxWireVersion","logicalSessionTimeoutMinutes","undefined","server","isReadable","Math","min","updateFromSrvPollingEvent","ev","srvMaxHosts","incomingHostnames","hostnames","currentHostnames","keys","hostnamesToAdd","hostnamesToRemove","hostname","delete","has","add","size","removedHost","hostToAdd","set","server_description_1","selectedHosts","selectedHostToAdd","update","serverType","Single","topologyTypeForServerType","Sharded","ReplicaSetNoPrimary","RSPrimary","result","updateRsFromPrimary","updateRsNoPrimaryFromMember","ReplicaSetWithPrimary","checkHasPrimary","updateRsWithPrimaryFromMember","error","descriptionsWithError","Array","from","filter","sd","length","hasKnownServers","some","hasDataBearingServers","isDataBearing","hasServer","exports","compareObjectId","oid1","oid2","id","Buffer","oid1Buffer","oid2Buffer","compare","oid1String","toString","oid2String","localeCompare","electionId","setVersion","allHosts","forEach","currentAddresses","responseAddresses","addr","indexOf","error_1","me"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\sdam\\topology_description.ts"],"sourcesContent":["import type { Document, ObjectId } from '../bson';\r\nimport * as WIRE_CONSTANTS from '../cmap/wire_protocol/constants';\r\nimport { MongoError, MongoRuntimeError } from '../error';\r\nimport { shuffle } from '../utils';\r\nimport { ServerType, TopologyType } from './common';\r\nimport { ServerDescription } from './server_description';\r\nimport type { SrvPollingEvent } from './srv_polling';\r\n\r\n// constants related to compatibility checks\r\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\r\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\r\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\r\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\r\n\r\nconst MONGOS_OR_UNKNOWN = new Set<ServerType>([ServerType.Mongos, ServerType.Unknown]);\r\nconst MONGOS_OR_STANDALONE = new Set<ServerType>([ServerType.Mongos, ServerType.Standalone]);\r\nconst NON_PRIMARY_RS_MEMBERS = new Set<ServerType>([\r\n  ServerType.RSSecondary,\r\n  ServerType.RSArbiter,\r\n  ServerType.RSOther\r\n]);\r\n\r\n/** @public */\r\nexport interface TopologyDescriptionOptions {\r\n  heartbeatFrequencyMS?: number;\r\n  localThresholdMS?: number;\r\n}\r\n\r\n/**\r\n * Representation of a deployment of servers\r\n * @public\r\n */\r\nexport class TopologyDescription {\r\n  type: TopologyType;\r\n  setName?: string;\r\n  maxSetVersion?: number;\r\n  maxElectionId?: ObjectId;\r\n  servers: Map<string, ServerDescription>;\r\n  stale: boolean;\r\n  compatible: boolean;\r\n  compatibilityError?: string;\r\n  logicalSessionTimeoutMinutes?: number;\r\n  heartbeatFrequencyMS: number;\r\n  localThresholdMS: number;\r\n  commonWireVersion?: number;\r\n\r\n  /**\r\n   * Create a TopologyDescription\r\n   */\r\n  constructor(\r\n    topologyType: TopologyType,\r\n    serverDescriptions?: Map<string, ServerDescription>,\r\n    setName?: string,\r\n    maxSetVersion?: number,\r\n    maxElectionId?: ObjectId,\r\n    commonWireVersion?: number,\r\n    options?: TopologyDescriptionOptions\r\n  ) {\r\n    options = options ?? {};\r\n\r\n    this.type = topologyType ?? TopologyType.Unknown;\r\n    this.servers = serverDescriptions ?? new Map();\r\n    this.stale = false;\r\n    this.compatible = true;\r\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;\r\n    this.localThresholdMS = options.localThresholdMS ?? 0;\r\n\r\n    if (setName) {\r\n      this.setName = setName;\r\n    }\r\n\r\n    if (maxSetVersion) {\r\n      this.maxSetVersion = maxSetVersion;\r\n    }\r\n\r\n    if (maxElectionId) {\r\n      this.maxElectionId = maxElectionId;\r\n    }\r\n\r\n    if (commonWireVersion) {\r\n      this.commonWireVersion = commonWireVersion;\r\n    }\r\n\r\n    // determine server compatibility\r\n    for (const serverDescription of this.servers.values()) {\r\n      // Load balancer mode is always compatible.\r\n      if (\r\n        serverDescription.type === ServerType.Unknown ||\r\n        serverDescription.type === ServerType.LoadBalancer\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\r\n        this.compatible = false;\r\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\r\n      }\r\n\r\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\r\n        this.compatible = false;\r\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Whenever a client updates the TopologyDescription from a hello response, it MUST set\r\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\r\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\r\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\r\n    // set to null.\r\n    this.logicalSessionTimeoutMinutes = undefined;\r\n    for (const [, server] of this.servers) {\r\n      if (server.isReadable) {\r\n        if (server.logicalSessionTimeoutMinutes == null) {\r\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\r\n          this.logicalSessionTimeoutMinutes = undefined;\r\n          break;\r\n        }\r\n\r\n        if (this.logicalSessionTimeoutMinutes == null) {\r\n          // First server with a non null logicalSessionsTimeout\r\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\r\n          continue;\r\n        }\r\n\r\n        // Always select the smaller of the:\r\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\r\n        this.logicalSessionTimeoutMinutes = Math.min(\r\n          this.logicalSessionTimeoutMinutes,\r\n          server.logicalSessionTimeoutMinutes\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new TopologyDescription based on the SrvPollingEvent\r\n   * @internal\r\n   */\r\n  updateFromSrvPollingEvent(ev: SrvPollingEvent, srvMaxHosts = 0): TopologyDescription {\r\n    /** The SRV addresses defines the set of addresses we should be using */\r\n    const incomingHostnames = ev.hostnames();\r\n    const currentHostnames = new Set(this.servers.keys());\r\n\r\n    const hostnamesToAdd = new Set<string>(incomingHostnames);\r\n    const hostnamesToRemove = new Set<string>();\r\n    for (const hostname of currentHostnames) {\r\n      // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\r\n      hostnamesToAdd.delete(hostname);\r\n      if (!incomingHostnames.has(hostname)) {\r\n        // If the SRV Records no longer include this hostname\r\n        // we have to stop using it\r\n        hostnamesToRemove.add(hostname);\r\n      }\r\n    }\r\n\r\n    if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\r\n      // No new hosts to add and none to remove\r\n      return this;\r\n    }\r\n\r\n    const serverDescriptions = new Map(this.servers);\r\n    for (const removedHost of hostnamesToRemove) {\r\n      serverDescriptions.delete(removedHost);\r\n    }\r\n\r\n    if (hostnamesToAdd.size > 0) {\r\n      if (srvMaxHosts === 0) {\r\n        // Add all!\r\n        for (const hostToAdd of hostnamesToAdd) {\r\n          serverDescriptions.set(hostToAdd, new ServerDescription(hostToAdd));\r\n        }\r\n      } else if (serverDescriptions.size < srvMaxHosts) {\r\n        // Add only the amount needed to get us back to srvMaxHosts\r\n        const selectedHosts = shuffle(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\r\n        for (const selectedHostToAdd of selectedHosts) {\r\n          serverDescriptions.set(selectedHostToAdd, new ServerDescription(selectedHostToAdd));\r\n        }\r\n      }\r\n    }\r\n\r\n    return new TopologyDescription(\r\n      this.type,\r\n      serverDescriptions,\r\n      this.setName,\r\n      this.maxSetVersion,\r\n      this.maxElectionId,\r\n      this.commonWireVersion,\r\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns a copy of this description updated with a given ServerDescription\r\n   * @internal\r\n   */\r\n  update(serverDescription: ServerDescription): TopologyDescription {\r\n    const address = serverDescription.address;\r\n\r\n    // potentially mutated values\r\n    let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;\r\n\r\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\r\n      serverDescription = new ServerDescription(address, undefined);\r\n    }\r\n\r\n    const serverType = serverDescription.type;\r\n    const serverDescriptions = new Map(this.servers);\r\n\r\n    // update common wire version\r\n    if (serverDescription.maxWireVersion !== 0) {\r\n      if (commonWireVersion == null) {\r\n        commonWireVersion = serverDescription.maxWireVersion;\r\n      } else {\r\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\r\n      }\r\n    }\r\n\r\n    // update the actual server description\r\n    serverDescriptions.set(address, serverDescription);\r\n\r\n    if (topologyType === TopologyType.Single) {\r\n      // once we are defined as single, that never changes\r\n      return new TopologyDescription(\r\n        TopologyType.Single,\r\n        serverDescriptions,\r\n        setName,\r\n        maxSetVersion,\r\n        maxElectionId,\r\n        commonWireVersion,\r\n        { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\r\n      );\r\n    }\r\n\r\n    if (topologyType === TopologyType.Unknown) {\r\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\r\n        serverDescriptions.delete(address);\r\n      } else {\r\n        topologyType = topologyTypeForServerType(serverType);\r\n      }\r\n    }\r\n\r\n    if (topologyType === TopologyType.Sharded) {\r\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\r\n        serverDescriptions.delete(address);\r\n      }\r\n    }\r\n\r\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\r\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\r\n        serverDescriptions.delete(address);\r\n      }\r\n\r\n      if (serverType === ServerType.RSPrimary) {\r\n        const result = updateRsFromPrimary(\r\n          serverDescriptions,\r\n          serverDescription,\r\n          setName,\r\n          maxSetVersion,\r\n          maxElectionId\r\n        );\r\n\r\n        topologyType = result[0];\r\n        setName = result[1];\r\n        maxSetVersion = result[2];\r\n        maxElectionId = result[3];\r\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\r\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\r\n        topologyType = result[0];\r\n        setName = result[1];\r\n      }\r\n    }\r\n\r\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\r\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\r\n        serverDescriptions.delete(address);\r\n        topologyType = checkHasPrimary(serverDescriptions);\r\n      } else if (serverType === ServerType.RSPrimary) {\r\n        const result = updateRsFromPrimary(\r\n          serverDescriptions,\r\n          serverDescription,\r\n          setName,\r\n          maxSetVersion,\r\n          maxElectionId\r\n        );\r\n\r\n        topologyType = result[0];\r\n        setName = result[1];\r\n        maxSetVersion = result[2];\r\n        maxElectionId = result[3];\r\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\r\n        topologyType = updateRsWithPrimaryFromMember(\r\n          serverDescriptions,\r\n          serverDescription,\r\n          setName\r\n        );\r\n      } else {\r\n        topologyType = checkHasPrimary(serverDescriptions);\r\n      }\r\n    }\r\n\r\n    return new TopologyDescription(\r\n      topologyType,\r\n      serverDescriptions,\r\n      setName,\r\n      maxSetVersion,\r\n      maxElectionId,\r\n      commonWireVersion,\r\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\r\n    );\r\n  }\r\n\r\n  get error(): MongoError | undefined {\r\n    const descriptionsWithError = Array.from(this.servers.values()).filter(\r\n      (sd: ServerDescription) => sd.error\r\n    );\r\n\r\n    if (descriptionsWithError.length > 0) {\r\n      return descriptionsWithError[0].error;\r\n    }\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Determines if the topology description has any known servers\r\n   */\r\n  get hasKnownServers(): boolean {\r\n    return Array.from(this.servers.values()).some(\r\n      (sd: ServerDescription) => sd.type !== ServerType.Unknown\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determines if this topology description has a data-bearing server available.\r\n   */\r\n  get hasDataBearingServers(): boolean {\r\n    return Array.from(this.servers.values()).some((sd: ServerDescription) => sd.isDataBearing);\r\n  }\r\n\r\n  /**\r\n   * Determines if the topology has a definition for the provided address\r\n   * @internal\r\n   */\r\n  hasServer(address: string): boolean {\r\n    return this.servers.has(address);\r\n  }\r\n}\r\n\r\nfunction topologyTypeForServerType(serverType: ServerType): TopologyType {\r\n  switch (serverType) {\r\n    case ServerType.Standalone:\r\n      return TopologyType.Single;\r\n    case ServerType.Mongos:\r\n      return TopologyType.Sharded;\r\n    case ServerType.RSPrimary:\r\n      return TopologyType.ReplicaSetWithPrimary;\r\n    case ServerType.RSOther:\r\n    case ServerType.RSSecondary:\r\n      return TopologyType.ReplicaSetNoPrimary;\r\n    default:\r\n      return TopologyType.Unknown;\r\n  }\r\n}\r\n\r\n// TODO: improve these docs when ObjectId is properly typed\r\nfunction compareObjectId(oid1: Document, oid2: Document): number {\r\n  if (oid1 == null) {\r\n    return -1;\r\n  }\r\n\r\n  if (oid2 == null) {\r\n    return 1;\r\n  }\r\n\r\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\r\n    const oid1Buffer = oid1.id;\r\n    const oid2Buffer = oid2.id;\r\n    return oid1Buffer.compare(oid2Buffer);\r\n  }\r\n\r\n  const oid1String = oid1.toString();\r\n  const oid2String = oid2.toString();\r\n  return oid1String.localeCompare(oid2String);\r\n}\r\n\r\nfunction updateRsFromPrimary(\r\n  serverDescriptions: Map<string, ServerDescription>,\r\n  serverDescription: ServerDescription,\r\n  setName?: string,\r\n  maxSetVersion?: number,\r\n  maxElectionId?: ObjectId\r\n): [TopologyType, string?, number?, ObjectId?] {\r\n  setName = setName || serverDescription.setName;\r\n  if (setName !== serverDescription.setName) {\r\n    serverDescriptions.delete(serverDescription.address);\r\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\r\n  }\r\n\r\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\r\n  if (serverDescription.setVersion && electionId) {\r\n    if (maxSetVersion && maxElectionId) {\r\n      if (\r\n        maxSetVersion > serverDescription.setVersion ||\r\n        compareObjectId(maxElectionId, electionId) > 0\r\n      ) {\r\n        // this primary is stale, we must remove it\r\n        serverDescriptions.set(\r\n          serverDescription.address,\r\n          new ServerDescription(serverDescription.address)\r\n        );\r\n\r\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\r\n      }\r\n    }\r\n\r\n    maxElectionId = serverDescription.electionId;\r\n  }\r\n\r\n  if (\r\n    serverDescription.setVersion != null &&\r\n    (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\r\n  ) {\r\n    maxSetVersion = serverDescription.setVersion;\r\n  }\r\n\r\n  // We've heard from the primary. Is it the same primary as before?\r\n  for (const [address, server] of serverDescriptions) {\r\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\r\n      // Reset old primary's type to Unknown.\r\n      serverDescriptions.set(address, new ServerDescription(server.address));\r\n\r\n      // There can only be one primary\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Discover new hosts from this primary's response.\r\n  serverDescription.allHosts.forEach((address: string) => {\r\n    if (!serverDescriptions.has(address)) {\r\n      serverDescriptions.set(address, new ServerDescription(address));\r\n    }\r\n  });\r\n\r\n  // Remove hosts not in the response.\r\n  const currentAddresses = Array.from(serverDescriptions.keys());\r\n  const responseAddresses = serverDescription.allHosts;\r\n  currentAddresses\r\n    .filter((addr: string) => responseAddresses.indexOf(addr) === -1)\r\n    .forEach((address: string) => {\r\n      serverDescriptions.delete(address);\r\n    });\r\n\r\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\r\n}\r\n\r\nfunction updateRsWithPrimaryFromMember(\r\n  serverDescriptions: Map<string, ServerDescription>,\r\n  serverDescription: ServerDescription,\r\n  setName?: string\r\n): TopologyType {\r\n  if (setName == null) {\r\n    // TODO(NODE-3483): should be an appropriate runtime error\r\n    throw new MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\r\n  }\r\n\r\n  if (\r\n    setName !== serverDescription.setName ||\r\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\r\n  ) {\r\n    serverDescriptions.delete(serverDescription.address);\r\n  }\r\n\r\n  return checkHasPrimary(serverDescriptions);\r\n}\r\n\r\nfunction updateRsNoPrimaryFromMember(\r\n  serverDescriptions: Map<string, ServerDescription>,\r\n  serverDescription: ServerDescription,\r\n  setName?: string\r\n): [TopologyType, string?] {\r\n  const topologyType = TopologyType.ReplicaSetNoPrimary;\r\n  setName = setName || serverDescription.setName;\r\n  if (setName !== serverDescription.setName) {\r\n    serverDescriptions.delete(serverDescription.address);\r\n    return [topologyType, setName];\r\n  }\r\n\r\n  serverDescription.allHosts.forEach((address: string) => {\r\n    if (!serverDescriptions.has(address)) {\r\n      serverDescriptions.set(address, new ServerDescription(address));\r\n    }\r\n  });\r\n\r\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\r\n    serverDescriptions.delete(serverDescription.address);\r\n  }\r\n\r\n  return [topologyType, setName];\r\n}\r\n\r\nfunction checkHasPrimary(serverDescriptions: Map<string, ServerDescription>): TopologyType {\r\n  for (const serverDescription of serverDescriptions.values()) {\r\n    if (serverDescription.type === ServerType.RSPrimary) {\r\n      return TopologyType.ReplicaSetWithPrimary;\r\n    }\r\n  }\r\n\r\n  return TopologyType.ReplicaSetNoPrimary;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}