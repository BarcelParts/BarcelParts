{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadPreference = exports.ReadPreferenceMode = void 0;\n\nconst error_1 = require(\"./error\");\n/** @public */\n\n\nexports.ReadPreferenceMode = Object.freeze({\n  primary: 'primary',\n  primaryPreferred: 'primaryPreferred',\n  secondary: 'secondary',\n  secondaryPreferred: 'secondaryPreferred',\n  nearest: 'nearest'\n});\n/**\n * The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is\n * used to construct connections.\n * @public\n *\n * @see https://docs.mongodb.com/manual/core/read-preference/\n */\n\nclass ReadPreference {\n  /**\n   * @param mode - A string describing the read preference mode (primary|primaryPreferred|secondary|secondaryPreferred|nearest)\n   * @param tags - A tag set used to target reads to members with the specified tag(s). tagSet is not available if using read preference mode primary.\n   * @param options - Additional read preference options\n   */\n  constructor(mode, tags, options) {\n    if (!ReadPreference.isValid(mode)) {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);\n    }\n\n    if (options == null && typeof tags === 'object' && !Array.isArray(tags)) {\n      options = tags;\n      tags = undefined;\n    } else if (tags && !Array.isArray(tags)) {\n      throw new error_1.MongoInvalidArgumentError('ReadPreference tags must be an array');\n    }\n\n    this.mode = mode;\n    this.tags = tags;\n    this.hedge = options === null || options === void 0 ? void 0 : options.hedge;\n    this.maxStalenessSeconds = undefined;\n    this.minWireVersion = undefined;\n    options = options !== null && options !== void 0 ? options : {};\n\n    if (options.maxStalenessSeconds != null) {\n      if (options.maxStalenessSeconds <= 0) {\n        throw new error_1.MongoInvalidArgumentError('maxStalenessSeconds must be a positive integer');\n      }\n\n      this.maxStalenessSeconds = options.maxStalenessSeconds; // NOTE: The minimum required wire version is 5 for this read preference. If the existing\n      //       topology has a lower value then a MongoError will be thrown during server selection.\n\n      this.minWireVersion = 5;\n    }\n\n    if (this.mode === ReadPreference.PRIMARY) {\n      if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {\n        throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with tags');\n      }\n\n      if (this.maxStalenessSeconds) {\n        throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with maxStalenessSeconds');\n      }\n\n      if (this.hedge) {\n        throw new error_1.MongoInvalidArgumentError('Primary read preference cannot be combined with hedge');\n      }\n    }\n  } // Support the deprecated `preference` property introduced in the porcelain layer\n\n\n  get preference() {\n    return this.mode;\n  }\n\n  static fromString(mode) {\n    return new ReadPreference(mode);\n  }\n  /**\n   * Construct a ReadPreference given an options object.\n   *\n   * @param options - The options object from which to extract the read preference.\n   */\n\n\n  static fromOptions(options) {\n    var _a, _b, _c;\n\n    if (!options) return;\n    const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : (_b = options.session) === null || _b === void 0 ? void 0 : _b.transaction.options.readPreference;\n    const readPreferenceTags = options.readPreferenceTags;\n\n    if (readPreference == null) {\n      return;\n    }\n\n    if (typeof readPreference === 'string') {\n      return new ReadPreference(readPreference, readPreferenceTags, {\n        maxStalenessSeconds: options.maxStalenessSeconds,\n        hedge: options.hedge\n      });\n    } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === 'object') {\n      const mode = readPreference.mode || readPreference.preference;\n\n      if (mode && typeof mode === 'string') {\n        return new ReadPreference(mode, (_c = readPreference.tags) !== null && _c !== void 0 ? _c : readPreferenceTags, {\n          maxStalenessSeconds: readPreference.maxStalenessSeconds,\n          hedge: options.hedge\n        });\n      }\n    }\n\n    if (readPreferenceTags) {\n      readPreference.tags = readPreferenceTags;\n    }\n\n    return readPreference;\n  }\n  /**\n   * Replaces options.readPreference with a ReadPreference instance\n   */\n\n\n  static translate(options) {\n    if (options.readPreference == null) return options;\n    const r = options.readPreference;\n\n    if (typeof r === 'string') {\n      options.readPreference = new ReadPreference(r);\n    } else if (r && !(r instanceof ReadPreference) && typeof r === 'object') {\n      const mode = r.mode || r.preference;\n\n      if (mode && typeof mode === 'string') {\n        options.readPreference = new ReadPreference(mode, r.tags, {\n          maxStalenessSeconds: r.maxStalenessSeconds\n        });\n      }\n    } else if (!(r instanceof ReadPreference)) {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${r}`);\n    }\n\n    return options;\n  }\n  /**\n   * Validate if a mode is legal\n   *\n   * @param mode - The string representing the read preference mode.\n   */\n\n\n  static isValid(mode) {\n    const VALID_MODES = new Set([ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST, null]);\n    return VALID_MODES.has(mode);\n  }\n  /**\n   * Validate if a mode is legal\n   *\n   * @param mode - The string representing the read preference mode.\n   */\n\n\n  isValid(mode) {\n    return ReadPreference.isValid(typeof mode === 'string' ? mode : this.mode);\n  }\n  /**\n   * Indicates that this readPreference needs the \"secondaryOk\" bit when sent over the wire\n   * @deprecated Use secondaryOk instead\n   * @see https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#op-query\n   */\n\n\n  slaveOk() {\n    return this.secondaryOk();\n  }\n  /**\n   * Indicates that this readPreference needs the \"SecondaryOk\" bit when sent over the wire\n   * @see https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#op-query\n   */\n\n\n  secondaryOk() {\n    const NEEDS_SECONDARYOK = new Set([ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST]);\n    return NEEDS_SECONDARYOK.has(this.mode);\n  }\n  /**\n   * Check if the two ReadPreferences are equivalent\n   *\n   * @param readPreference - The read preference with which to check equality\n   */\n\n\n  equals(readPreference) {\n    return readPreference.mode === this.mode;\n  }\n  /** Return JSON representation */\n\n\n  toJSON() {\n    const readPreference = {\n      mode: this.mode\n    };\n    if (Array.isArray(this.tags)) readPreference.tags = this.tags;\n    if (this.maxStalenessSeconds) readPreference.maxStalenessSeconds = this.maxStalenessSeconds;\n    if (this.hedge) readPreference.hedge = this.hedge;\n    return readPreference;\n  }\n\n}\n\nexports.ReadPreference = ReadPreference;\nReadPreference.PRIMARY = exports.ReadPreferenceMode.primary;\nReadPreference.PRIMARY_PREFERRED = exports.ReadPreferenceMode.primaryPreferred;\nReadPreference.SECONDARY = exports.ReadPreferenceMode.secondary;\nReadPreference.SECONDARY_PREFERRED = exports.ReadPreferenceMode.secondaryPreferred;\nReadPreference.NEAREST = exports.ReadPreferenceMode.nearest;\nReadPreference.primary = new ReadPreference(exports.ReadPreferenceMode.primary);\nReadPreference.primaryPreferred = new ReadPreference(exports.ReadPreferenceMode.primaryPreferred);\nReadPreference.secondary = new ReadPreference(exports.ReadPreferenceMode.secondary);\nReadPreference.secondaryPreferred = new ReadPreference(exports.ReadPreferenceMode.secondaryPreferred);\nReadPreference.nearest = new ReadPreference(exports.ReadPreferenceMode.nearest);","map":{"version":3,"mappings":"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","names":["exports","Object","freeze","primary","primaryPreferred","secondary","secondaryPreferred","nearest","ReadPreference","constructor","mode","tags","options","isValid","error_1","JSON","stringify","Array","isArray","undefined","hedge","maxStalenessSeconds","minWireVersion","PRIMARY","length","preference","fromString","fromOptions","readPreference","_a","session","_b","transaction","readPreferenceTags","_c","translate","r","VALID_MODES","Set","PRIMARY_PREFERRED","SECONDARY","SECONDARY_PREFERRED","NEAREST","has","slaveOk","secondaryOk","NEEDS_SECONDARYOK","equals","toJSON"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\read_preference.ts"],"sourcesContent":["import type { Document } from './bson';\nimport { MongoInvalidArgumentError } from './error';\nimport type { TagSet } from './sdam/server_description';\nimport type { ClientSession } from './sessions';\n\n/** @public */\nexport type ReadPreferenceLike = ReadPreference | ReadPreferenceMode;\n\n/** @public */\nexport const ReadPreferenceMode = Object.freeze({\n  primary: 'primary',\n  primaryPreferred: 'primaryPreferred',\n  secondary: 'secondary',\n  secondaryPreferred: 'secondaryPreferred',\n  nearest: 'nearest'\n} as const);\n\n/** @public */\nexport type ReadPreferenceMode = typeof ReadPreferenceMode[keyof typeof ReadPreferenceMode];\n\n/** @public */\nexport interface HedgeOptions {\n  /** Explicitly enable or disable hedged reads. */\n  enabled?: boolean;\n}\n\n/** @public */\nexport interface ReadPreferenceOptions {\n  /** Max secondary read staleness in seconds, Minimum value is 90 seconds.*/\n  maxStalenessSeconds?: number;\n  /** Server mode in which the same query is dispatched in parallel to multiple replica set members. */\n  hedge?: HedgeOptions;\n}\n\n/** @public */\nexport interface ReadPreferenceLikeOptions extends ReadPreferenceOptions {\n  readPreference?:\n    | ReadPreferenceLike\n    | {\n        mode?: ReadPreferenceMode;\n        preference?: ReadPreferenceMode;\n        tags?: TagSet[];\n        maxStalenessSeconds?: number;\n      };\n}\n\n/** @public */\nexport interface ReadPreferenceFromOptions extends ReadPreferenceLikeOptions {\n  session?: ClientSession;\n  readPreferenceTags?: TagSet[];\n  hedge?: HedgeOptions;\n}\n\n/**\n * The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is\n * used to construct connections.\n * @public\n *\n * @see https://docs.mongodb.com/manual/core/read-preference/\n */\nexport class ReadPreference {\n  mode: ReadPreferenceMode;\n  tags?: TagSet[];\n  hedge?: HedgeOptions;\n  maxStalenessSeconds?: number;\n  minWireVersion?: number;\n\n  public static PRIMARY = ReadPreferenceMode.primary;\n  public static PRIMARY_PREFERRED = ReadPreferenceMode.primaryPreferred;\n  public static SECONDARY = ReadPreferenceMode.secondary;\n  public static SECONDARY_PREFERRED = ReadPreferenceMode.secondaryPreferred;\n  public static NEAREST = ReadPreferenceMode.nearest;\n\n  public static primary = new ReadPreference(ReadPreferenceMode.primary);\n  public static primaryPreferred = new ReadPreference(ReadPreferenceMode.primaryPreferred);\n  public static secondary = new ReadPreference(ReadPreferenceMode.secondary);\n  public static secondaryPreferred = new ReadPreference(ReadPreferenceMode.secondaryPreferred);\n  public static nearest = new ReadPreference(ReadPreferenceMode.nearest);\n\n  /**\n   * @param mode - A string describing the read preference mode (primary|primaryPreferred|secondary|secondaryPreferred|nearest)\n   * @param tags - A tag set used to target reads to members with the specified tag(s). tagSet is not available if using read preference mode primary.\n   * @param options - Additional read preference options\n   */\n  constructor(mode: ReadPreferenceMode, tags?: TagSet[], options?: ReadPreferenceOptions) {\n    if (!ReadPreference.isValid(mode)) {\n      throw new MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);\n    }\n    if (options == null && typeof tags === 'object' && !Array.isArray(tags)) {\n      options = tags;\n      tags = undefined;\n    } else if (tags && !Array.isArray(tags)) {\n      throw new MongoInvalidArgumentError('ReadPreference tags must be an array');\n    }\n\n    this.mode = mode;\n    this.tags = tags;\n    this.hedge = options?.hedge;\n    this.maxStalenessSeconds = undefined;\n    this.minWireVersion = undefined;\n\n    options = options ?? {};\n    if (options.maxStalenessSeconds != null) {\n      if (options.maxStalenessSeconds <= 0) {\n        throw new MongoInvalidArgumentError('maxStalenessSeconds must be a positive integer');\n      }\n\n      this.maxStalenessSeconds = options.maxStalenessSeconds;\n\n      // NOTE: The minimum required wire version is 5 for this read preference. If the existing\n      //       topology has a lower value then a MongoError will be thrown during server selection.\n      this.minWireVersion = 5;\n    }\n\n    if (this.mode === ReadPreference.PRIMARY) {\n      if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {\n        throw new MongoInvalidArgumentError('Primary read preference cannot be combined with tags');\n      }\n\n      if (this.maxStalenessSeconds) {\n        throw new MongoInvalidArgumentError(\n          'Primary read preference cannot be combined with maxStalenessSeconds'\n        );\n      }\n\n      if (this.hedge) {\n        throw new MongoInvalidArgumentError(\n          'Primary read preference cannot be combined with hedge'\n        );\n      }\n    }\n  }\n\n  // Support the deprecated `preference` property introduced in the porcelain layer\n  get preference(): ReadPreferenceMode {\n    return this.mode;\n  }\n\n  static fromString(mode: string): ReadPreference {\n    return new ReadPreference(mode as ReadPreferenceMode);\n  }\n\n  /**\n   * Construct a ReadPreference given an options object.\n   *\n   * @param options - The options object from which to extract the read preference.\n   */\n  static fromOptions(options?: ReadPreferenceFromOptions): ReadPreference | undefined {\n    if (!options) return;\n    const readPreference =\n      options.readPreference ?? options.session?.transaction.options.readPreference;\n    const readPreferenceTags = options.readPreferenceTags;\n\n    if (readPreference == null) {\n      return;\n    }\n\n    if (typeof readPreference === 'string') {\n      return new ReadPreference(readPreference as ReadPreferenceMode, readPreferenceTags, {\n        maxStalenessSeconds: options.maxStalenessSeconds,\n        hedge: options.hedge\n      });\n    } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === 'object') {\n      const mode = readPreference.mode || readPreference.preference;\n      if (mode && typeof mode === 'string') {\n        return new ReadPreference(\n          mode as ReadPreferenceMode,\n          readPreference.tags ?? readPreferenceTags,\n          {\n            maxStalenessSeconds: readPreference.maxStalenessSeconds,\n            hedge: options.hedge\n          }\n        );\n      }\n    }\n\n    if (readPreferenceTags) {\n      readPreference.tags = readPreferenceTags;\n    }\n\n    return readPreference as ReadPreference;\n  }\n\n  /**\n   * Replaces options.readPreference with a ReadPreference instance\n   */\n  static translate(options: ReadPreferenceLikeOptions): ReadPreferenceLikeOptions {\n    if (options.readPreference == null) return options;\n    const r = options.readPreference;\n\n    if (typeof r === 'string') {\n      options.readPreference = new ReadPreference(r as ReadPreferenceMode);\n    } else if (r && !(r instanceof ReadPreference) && typeof r === 'object') {\n      const mode = r.mode || r.preference;\n      if (mode && typeof mode === 'string') {\n        options.readPreference = new ReadPreference(mode as ReadPreferenceMode, r.tags, {\n          maxStalenessSeconds: r.maxStalenessSeconds\n        });\n      }\n    } else if (!(r instanceof ReadPreference)) {\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${r}`);\n    }\n\n    return options;\n  }\n\n  /**\n   * Validate if a mode is legal\n   *\n   * @param mode - The string representing the read preference mode.\n   */\n  static isValid(mode: string): boolean {\n    const VALID_MODES = new Set([\n      ReadPreference.PRIMARY,\n      ReadPreference.PRIMARY_PREFERRED,\n      ReadPreference.SECONDARY,\n      ReadPreference.SECONDARY_PREFERRED,\n      ReadPreference.NEAREST,\n      null\n    ]);\n\n    return VALID_MODES.has(mode as ReadPreferenceMode);\n  }\n\n  /**\n   * Validate if a mode is legal\n   *\n   * @param mode - The string representing the read preference mode.\n   */\n  isValid(mode?: string): boolean {\n    return ReadPreference.isValid(typeof mode === 'string' ? mode : this.mode);\n  }\n\n  /**\n   * Indicates that this readPreference needs the \"secondaryOk\" bit when sent over the wire\n   * @deprecated Use secondaryOk instead\n   * @see https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#op-query\n   */\n  slaveOk(): boolean {\n    return this.secondaryOk();\n  }\n\n  /**\n   * Indicates that this readPreference needs the \"SecondaryOk\" bit when sent over the wire\n   * @see https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#op-query\n   */\n  secondaryOk(): boolean {\n    const NEEDS_SECONDARYOK = new Set<string>([\n      ReadPreference.PRIMARY_PREFERRED,\n      ReadPreference.SECONDARY,\n      ReadPreference.SECONDARY_PREFERRED,\n      ReadPreference.NEAREST\n    ]);\n\n    return NEEDS_SECONDARYOK.has(this.mode);\n  }\n\n  /**\n   * Check if the two ReadPreferences are equivalent\n   *\n   * @param readPreference - The read preference with which to check equality\n   */\n  equals(readPreference: ReadPreference): boolean {\n    return readPreference.mode === this.mode;\n  }\n\n  /** Return JSON representation */\n  toJSON(): Document {\n    const readPreference = { mode: this.mode } as Document;\n    if (Array.isArray(this.tags)) readPreference.tags = this.tags;\n    if (this.maxStalenessSeconds) readPreference.maxStalenessSeconds = this.maxStalenessSeconds;\n    if (this.hedge) readPreference.hedge = this.hedge;\n    return readPreference;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}