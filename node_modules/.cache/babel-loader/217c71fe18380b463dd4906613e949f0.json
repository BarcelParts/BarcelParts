{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst bson_1 = require(\"../../bson\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst auth_provider_1 = require(\"./auth_provider\");\n\nconst providers_1 = require(\"./providers\");\n\nclass ScramSHA extends auth_provider_1.AuthProvider {\n  constructor(cryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n\n    if (!credentials) {\n      return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n\n    if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n      (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      } // store the nonce for later use\n\n\n      Object.assign(authContext, {\n        nonce\n      });\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const {\n    connection,\n    credentials\n  } = authContext;\n\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property'));\n  }\n\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));\n  }\n\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n\n  if (cryptoMethod === 'sha256') {\n    processedPassword = 'kModuleError' in deps_1.saslprep ? password : (0, deps_1.saslprep)(password);\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n\n  if (iterations && iterations < 4096) {\n    callback( // TODO(NODE-3483)\n    new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n\n  if (rnonce.startsWith('nonce')) {\n    // TODO(NODE-3483)\n    callback(new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  } // Set up start of proof\n\n\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new bson_1.Binary(Buffer.from(clientFinal))\n  };\n  connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n    const err = resolveError(_err, r);\n\n    if (err) {\n      return callback(err);\n    }\n\n    const parsedResponse = parsePayload(r.payload.value());\n\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new error_1.MongoRuntimeError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n} // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\n\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n\n  if (result) {\n    if (result.$err || result.errmsg) return new error_1.MongoServerError(result);\n  }\n\n  return;\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n\n}\n\nexports.ScramSHA1 = ScramSHA1;\n\nclass ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n\n}\n\nexports.ScramSHA256 = ScramSHA256;","map":{"version":3,"mappings":"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","names":["ScramSHA","auth_provider_1","constructor","cryptoMethod","prepare","handshakeDoc","authContext","callback","credentials","error_1","deps_1","crypto","randomBytes","err","nonce","Object","assign","request","speculativeAuthenticate","makeFirstMessage","db","source","undefined","auth","response","continueScramConversation","executeScram","cleanUsername","username","replace","clientFirstMessageBare","Buffer","concat","from","toString","mechanism","providers_1","MONGODB_SCRAM_SHA1","MONGODB_SCRAM_SHA256","saslStart","payload","bson_1","autoAuthorize","options","skipEmptyExchange","connection","saslStartCmd","command","_err","result","resolveError","password","processedPassword","passwordDigest","e","isBuffer","dict","parsePayload","value","iterations","parseInt","i","salt","s","rnonce","r","startsWith","withoutProof","saltedPassword","HI","clientKey","HMAC","serverKey","storedKey","H","authMessage","join","clientSignature","clientProof","xor","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","parsedResponse","compareDigest","v","done","retrySaslContinueCmd","alloc","parts","split","length","valueParts","md5","createHash","update","digest","a","b","Math","max","res","push","method","text","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","$err","errmsg","ScramSHA1","exports","ScramSHA256"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\cmap\\auth\\scram.ts"],"sourcesContent":["import * as crypto from 'crypto';\n\nimport { Binary, Document } from '../../bson';\nimport { saslprep } from '../../deps';\nimport {\n  AnyError,\n  MongoInvalidArgumentError,\n  MongoMissingCredentialsError,\n  MongoRuntimeError,\n  MongoServerError\n} from '../../error';\nimport { Callback, emitWarning, ns } from '../../utils';\nimport type { HandshakeDocument } from '../connect';\nimport { AuthContext, AuthProvider } from './auth_provider';\nimport type { MongoCredentials } from './mongo_credentials';\nimport { AuthMechanism } from './providers';\n\ntype CryptoMethod = 'sha1' | 'sha256';\n\nclass ScramSHA extends AuthProvider {\n  cryptoMethod: CryptoMethod;\n  constructor(cryptoMethod: CryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  override prepare(handshakeDoc: HandshakeDocument, authContext: AuthContext, callback: Callback) {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n      return callback(new MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n    if (cryptoMethod === 'sha256' && saslprep == null) {\n      emitWarning('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      }\n\n      // store the nonce for later use\n      Object.assign(authContext, { nonce });\n\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n\n      callback(undefined, request);\n    });\n  }\n\n  override auth(authContext: AuthContext, callback: Callback) {\n    const response = authContext.response;\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(\n        this.cryptoMethod,\n        response.speculativeAuthenticate,\n        authContext,\n        callback\n      );\n\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n}\n\nfunction cleanUsername(username: string) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username: string, nonce: Buffer) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([\n    Buffer.from('n=', 'utf8'),\n    Buffer.from(username, 'utf8'),\n    Buffer.from(',r=', 'utf8'),\n    Buffer.from(nonce.toString('base64'), 'utf8')\n  ]);\n}\n\nfunction makeFirstMessage(\n  cryptoMethod: CryptoMethod,\n  credentials: MongoCredentials,\n  nonce: Buffer\n) {\n  const username = cleanUsername(credentials.username);\n  const mechanism =\n    cryptoMethod === 'sha1' ? AuthMechanism.MONGODB_SCRAM_SHA1 : AuthMechanism.MONGODB_SCRAM_SHA256;\n\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(\n      Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])\n    ),\n    autoAuthorize: 1,\n    options: { skipEmptyExchange: true }\n  };\n}\n\nfunction executeScram(cryptoMethod: CryptoMethod, authContext: AuthContext, callback: Callback) {\n  const { connection, credentials } = authContext;\n  if (!credentials) {\n    return callback(new MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n  if (!authContext.nonce) {\n    return callback(\n      new MongoInvalidArgumentError('AuthContext must contain a valid nonce property')\n    );\n  }\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(ns(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(\n  cryptoMethod: CryptoMethod,\n  response: Document,\n  authContext: AuthContext,\n  callback: Callback\n) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  if (!credentials) {\n    return callback(new MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n  if (!authContext.nonce) {\n    return callback(new MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));\n  }\n  const nonce = authContext.nonce;\n\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n\n  let processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword = 'kModuleError' in saslprep ? password : saslprep(password);\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload)\n    ? new Binary(response.payload)\n    : response.payload;\n  const dict = parsePayload(payload.value());\n\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    callback(\n      // TODO(NODE-3483)\n      new MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`),\n      false\n    );\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    // TODO(NODE-3483)\n    callback(new MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  }\n\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(\n    processedPassword,\n    Buffer.from(salt, 'base64'),\n    iterations,\n    cryptoMethod\n  );\n\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(\n    ','\n  );\n\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n\n  connection.command(ns(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n    const err = resolveError(_err, r);\n    if (err) {\n      return callback(err);\n    }\n\n    const parsedResponse = parsePayload(r.payload.value());\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoRuntimeError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n\n    connection.command(ns(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n  });\n}\n\nfunction parsePayload(payload: string) {\n  const dict: Document = {};\n  const parts = payload.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username: string, password: string) {\n  if (typeof username !== 'string') {\n    throw new MongoInvalidArgumentError('Username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoInvalidArgumentError('Password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoInvalidArgumentError('Password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n\n// XOR two buffers\nfunction xor(a: Buffer, b: Buffer) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method: CryptoMethod, text: Buffer) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method: CryptoMethod, key: Buffer, text: Buffer | string) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\ninterface HICache {\n  [key: string]: Buffer;\n}\n\nlet _hiCache: HICache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data: string, salt: Buffer, iterations: number, cryptoMethod: CryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(\n    data,\n    salt,\n    iterations,\n    hiLengthMap[cryptoMethod],\n    cryptoMethod\n  );\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs: Buffer, rhs: Uint8Array) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err?: AnyError, result?: Document) {\n  if (err) return err;\n  if (result) {\n    if (result.$err || result.errmsg) return new MongoServerError(result);\n  }\n  return;\n}\n\nexport class ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n}\n\nexport class ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n}\n"]},"metadata":{},"sourceType":"script"}