{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnorderedBulkOperation = void 0;\n\nconst BSON = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst common_1 = require(\"./common\");\n/** @public */\n\n\nclass UnorderedBulkOperation extends common_1.BulkOperationBase {\n  constructor(collection, options) {\n    super(collection, options, false);\n  }\n\n  handleWriteError(callback, writeResult) {\n    if (this.s.batches.length) {\n      return false;\n    }\n\n    return super.handleWriteError(callback, writeResult);\n  }\n\n  addToOperationsList(batchType, document) {\n    // Get the bsonSize\n    const bsonSize = BSON.calculateObjectSize(document, {\n      checkKeys: false,\n      // Since we don't know what the user selected for BSON options here,\n      // err on the safe side, and check the size with ignoreUndefined: false.\n      ignoreUndefined: false\n    }); // Throw error if the doc is bigger than the max BSON size\n\n    if (bsonSize >= this.s.maxBsonObjectSize) {\n      // TODO(NODE-3483): Change this to MongoBSONError\n      throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);\n    } // Holds the current batch\n\n\n    this.s.currentBatch = undefined; // Get the right type of batch\n\n    if (batchType === common_1.BatchType.INSERT) {\n      this.s.currentBatch = this.s.currentInsertBatch;\n    } else if (batchType === common_1.BatchType.UPDATE) {\n      this.s.currentBatch = this.s.currentUpdateBatch;\n    } else if (batchType === common_1.BatchType.DELETE) {\n      this.s.currentBatch = this.s.currentRemoveBatch;\n    }\n\n    const maxKeySize = this.s.maxKeySize; // Create a new batch object if we don't have a current one\n\n    if (this.s.currentBatch == null) {\n      this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);\n    } // Check if we need to create a new batch\n\n\n    if ( // New batch if we exceed the max batch op size\n    this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\n    // since we can't sent an empty batch\n    this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch\n    this.s.currentBatch.batchType !== batchType) {\n      // Save the batch to the execution stack\n      this.s.batches.push(this.s.currentBatch); // Create a new batch\n\n      this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);\n    } // We have an array of documents\n\n\n    if (Array.isArray(document)) {\n      throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');\n    }\n\n    this.s.currentBatch.operations.push(document);\n    this.s.currentBatch.originalIndexes.push(this.s.currentIndex);\n    this.s.currentIndex = this.s.currentIndex + 1; // Save back the current Batch to the right type\n\n    if (batchType === common_1.BatchType.INSERT) {\n      this.s.currentInsertBatch = this.s.currentBatch;\n      this.s.bulkResult.insertedIds.push({\n        index: this.s.bulkResult.insertedIds.length,\n        _id: document._id\n      });\n    } else if (batchType === common_1.BatchType.UPDATE) {\n      this.s.currentUpdateBatch = this.s.currentBatch;\n    } else if (batchType === common_1.BatchType.DELETE) {\n      this.s.currentRemoveBatch = this.s.currentBatch;\n    } // Update current batch size\n\n\n    this.s.currentBatch.size += 1;\n    this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;\n    return this;\n  }\n\n}\n\nexports.UnorderedBulkOperation = UnorderedBulkOperation;","map":{"version":3,"mappings":"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","names":["UnorderedBulkOperation","common_1","constructor","collection","options","handleWriteError","callback","writeResult","s","batches","length","addToOperationsList","batchType","document","bsonSize","BSON","calculateObjectSize","checkKeys","ignoreUndefined","maxBsonObjectSize","error_1","currentBatch","undefined","INSERT","currentInsertBatch","UPDATE","currentUpdateBatch","DELETE","currentRemoveBatch","maxKeySize","currentIndex","size","maxWriteBatchSize","sizeBytes","maxBatchSizeBytes","push","Array","isArray","operations","originalIndexes","bulkResult","insertedIds","index","_id","exports"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\bulk\\unordered.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport * as BSON from '../bson';\nimport type { Collection } from '../collection';\nimport { MongoInvalidArgumentError } from '../error';\nimport type { DeleteStatement } from '../operations/delete';\nimport type { UpdateStatement } from '../operations/update';\nimport type { Callback } from '../utils';\nimport { Batch, BatchType, BulkOperationBase, BulkWriteOptions, BulkWriteResult } from './common';\n\n/** @public */\nexport class UnorderedBulkOperation extends BulkOperationBase {\n  constructor(collection: Collection, options: BulkWriteOptions) {\n    super(collection, options, false);\n  }\n\n  override handleWriteError(callback: Callback, writeResult: BulkWriteResult): boolean {\n    if (this.s.batches.length) {\n      return false;\n    }\n\n    return super.handleWriteError(callback, writeResult);\n  }\n\n  addToOperationsList(\n    batchType: BatchType,\n    document: Document | UpdateStatement | DeleteStatement\n  ): this {\n    // Get the bsonSize\n    const bsonSize = BSON.calculateObjectSize(document, {\n      checkKeys: false,\n\n      // Since we don't know what the user selected for BSON options here,\n      // err on the safe side, and check the size with ignoreUndefined: false.\n      ignoreUndefined: false\n    } as any);\n\n    // Throw error if the doc is bigger than the max BSON size\n    if (bsonSize >= this.s.maxBsonObjectSize) {\n      // TODO(NODE-3483): Change this to MongoBSONError\n      throw new MongoInvalidArgumentError(\n        `Document is larger than the maximum size ${this.s.maxBsonObjectSize}`\n      );\n    }\n\n    // Holds the current batch\n    this.s.currentBatch = undefined;\n    // Get the right type of batch\n    if (batchType === BatchType.INSERT) {\n      this.s.currentBatch = this.s.currentInsertBatch;\n    } else if (batchType === BatchType.UPDATE) {\n      this.s.currentBatch = this.s.currentUpdateBatch;\n    } else if (batchType === BatchType.DELETE) {\n      this.s.currentBatch = this.s.currentRemoveBatch;\n    }\n\n    const maxKeySize = this.s.maxKeySize;\n\n    // Create a new batch object if we don't have a current one\n    if (this.s.currentBatch == null) {\n      this.s.currentBatch = new Batch(batchType, this.s.currentIndex);\n    }\n\n    // Check if we need to create a new batch\n    if (\n      // New batch if we exceed the max batch op size\n      this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize ||\n      // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\n      // since we can't sent an empty batch\n      (this.s.currentBatch.size > 0 &&\n        this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes) ||\n      // New batch if the new op does not have the same op type as the current batch\n      this.s.currentBatch.batchType !== batchType\n    ) {\n      // Save the batch to the execution stack\n      this.s.batches.push(this.s.currentBatch);\n\n      // Create a new batch\n      this.s.currentBatch = new Batch(batchType, this.s.currentIndex);\n    }\n\n    // We have an array of documents\n    if (Array.isArray(document)) {\n      throw new MongoInvalidArgumentError('Operation passed in cannot be an Array');\n    }\n\n    this.s.currentBatch.operations.push(document);\n    this.s.currentBatch.originalIndexes.push(this.s.currentIndex);\n    this.s.currentIndex = this.s.currentIndex + 1;\n\n    // Save back the current Batch to the right type\n    if (batchType === BatchType.INSERT) {\n      this.s.currentInsertBatch = this.s.currentBatch;\n      this.s.bulkResult.insertedIds.push({\n        index: this.s.bulkResult.insertedIds.length,\n        _id: (document as Document)._id\n      });\n    } else if (batchType === BatchType.UPDATE) {\n      this.s.currentUpdateBatch = this.s.currentBatch;\n    } else if (batchType === BatchType.DELETE) {\n      this.s.currentRemoveBatch = this.s.currentBatch;\n    }\n\n    // Update current batch size\n    this.s.currentBatch.size += 1;\n    this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;\n\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}