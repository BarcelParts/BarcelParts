{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CancellationToken = exports.TypedEventEmitter = exports.BSONType = void 0;\n\nconst events_1 = require(\"events\");\n/** @public */\n\n\nexports.BSONType = Object.freeze({\n  double: 1,\n  string: 2,\n  object: 3,\n  array: 4,\n  binData: 5,\n  undefined: 6,\n  objectId: 7,\n  bool: 8,\n  date: 9,\n  null: 10,\n  regex: 11,\n  dbPointer: 12,\n  javascript: 13,\n  symbol: 14,\n  javascriptWithScope: 15,\n  int: 16,\n  timestamp: 17,\n  long: 18,\n  decimal: 19,\n  minKey: -1,\n  maxKey: 127\n});\n/**\n * Typescript type safe event emitter\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass TypedEventEmitter extends events_1.EventEmitter {}\n\nexports.TypedEventEmitter = TypedEventEmitter;\n/** @public */\n\nclass CancellationToken extends TypedEventEmitter {}\n\nexports.CancellationToken = CancellationToken;","map":{"version":3,"mappings":";;;;;;;AACA;AAmKA;;;AACaA,mBAAWC,MAAM,CAACC,MAAP,CAAc;AACpCC,QAAM,EAAE,CAD4B;AAEpCC,QAAM,EAAE,CAF4B;AAGpCC,QAAM,EAAE,CAH4B;AAIpCC,OAAK,EAAE,CAJ6B;AAKpCC,SAAO,EAAE,CAL2B;AAMpCC,WAAS,EAAE,CANyB;AAOpCC,UAAQ,EAAE,CAP0B;AAQpCC,MAAI,EAAE,CAR8B;AASpCC,MAAI,EAAE,CAT8B;AAUpCC,MAAI,EAAE,EAV8B;AAWpCC,OAAK,EAAE,EAX6B;AAYpCC,WAAS,EAAE,EAZyB;AAapCC,YAAU,EAAE,EAbwB;AAcpCC,QAAM,EAAE,EAd4B;AAepCC,qBAAmB,EAAE,EAfe;AAgBpCC,KAAG,EAAE,EAhB+B;AAiBpCC,WAAS,EAAE,EAjByB;AAkBpCC,MAAI,EAAE,EAlB8B;AAmBpCC,SAAO,EAAE,EAnB2B;AAoBpCC,QAAM,EAAE,CAAC,CApB2B;AAqBpCC,QAAM,EAAE;AArB4B,CAAd,CAAX;AAgRb;;;;AAIA;;AACA,MAAaC,iBAAb,SAAyEC,qBAAzE,CAAqF;;AAArFzB;AAEA;;AACA,MAAa0B,iBAAb,SAAuCF,iBAAvC,CAA4E;;AAA5ExB","names":["exports","Object","freeze","double","string","object","array","binData","undefined","objectId","bool","date","null","regex","dbPointer","javascript","symbol","javascriptWithScope","int","timestamp","long","decimal","minKey","maxKey","TypedEventEmitter","events_1","CancellationToken"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\mongo_types.ts"],"sourcesContent":["import type { ObjectIdLike } from 'bson';\r\nimport { EventEmitter } from 'events';\r\n\r\nimport type {\r\n  Binary,\r\n  BSONRegExp,\r\n  Decimal128,\r\n  Document,\r\n  Double,\r\n  Int32,\r\n  Long,\r\n  ObjectId,\r\n  Timestamp\r\n} from './bson';\r\nimport type { Sort } from './sort';\r\n\r\n/** @internal */\r\nexport type TODO_NODE_3286 = any;\r\n\r\n/** Given an object shaped type, return the type of the _id field or default to ObjectId @public */\r\nexport type InferIdType<TSchema> = TSchema extends { _id: infer IdType }\r\n  ? // user has defined a type for _id\r\n    Record<any, never> extends IdType\r\n    ? never // explicitly forbid empty objects as the type of _id\r\n    : IdType\r\n  : TSchema extends { _id?: infer IdType }\r\n  ? // optional _id defined - return ObjectId | IdType\r\n    unknown extends IdType\r\n    ? ObjectId // infer the _id type as ObjectId if the type of _id is unknown\r\n    : IdType\r\n  : ObjectId; // user has not defined _id on schema\r\n\r\n/** Add an _id field to an object shaped type @public */\r\nexport type WithId<TSchema> = EnhancedOmit<TSchema, '_id'> & { _id: InferIdType<TSchema> };\r\n\r\n/**\r\n * Add an optional _id field to an object shaped type\r\n * @public\r\n */\r\nexport type OptionalId<TSchema> = EnhancedOmit<TSchema, '_id'> & { _id?: InferIdType<TSchema> };\r\n\r\n/**\r\n * Adds an optional _id field to an object shaped type, unless the _id field is requried on that type.\r\n * In the case _id is required, this method continues to require_id.\r\n *\r\n * @public\r\n *\r\n * @privateRemarks\r\n * `ObjectId extends TSchema['_id']` is a confusing ordering at first glance. Rather than ask\r\n * `TSchema['_id'] extends ObjectId` which translated to \"Is the _id property ObjectId?\"\r\n * we instead ask \"Does ObjectId look like (have the same shape) as the _id?\"\r\n */\r\nexport type OptionalUnlessRequiredId<TSchema> = TSchema extends { _id: any }\r\n  ? TSchema\r\n  : OptionalId<TSchema>;\r\n\r\n/** TypeScript Omit (Exclude to be specific) does not work for objects with an \"any\" indexed type, and breaks discriminated unions @public */\r\nexport type EnhancedOmit<TRecordOrUnion, KeyUnion> = string extends keyof TRecordOrUnion\r\n  ? TRecordOrUnion // TRecordOrUnion has indexed type e.g. { _id: string; [k: string]: any; } or it is \"any\"\r\n  : TRecordOrUnion extends any\r\n  ? Pick<TRecordOrUnion, Exclude<keyof TRecordOrUnion, KeyUnion>> // discriminated unions\r\n  : never;\r\n\r\n/** Remove the _id field from an object shaped type @public */\r\nexport type WithoutId<TSchema> = Omit<TSchema, '_id'>;\r\n\r\n/** A MongoDB filter can be some portion of the schema or a set of operators @public */\r\nexport type Filter<TSchema> =\r\n  | Partial<TSchema>\r\n  | ({\r\n      [Property in Join<NestedPaths<WithId<TSchema>>, '.'>]?: Condition<\r\n        PropertyType<WithId<TSchema>, Property>\r\n      >;\r\n    } & RootFilterOperators<WithId<TSchema>>);\r\n\r\n/** @public */\r\nexport type Condition<T> = AlternativeType<T> | FilterOperators<AlternativeType<T>>;\r\n\r\n/**\r\n * It is possible to search using alternative types in mongodb e.g.\r\n * string types can be searched using a regex in mongo\r\n * array types can be searched using their element type\r\n * @public\r\n */\r\nexport type AlternativeType<T> = T extends ReadonlyArray<infer U>\r\n  ? T | RegExpOrString<U>\r\n  : RegExpOrString<T>;\r\n\r\n/** @public */\r\nexport type RegExpOrString<T> = T extends string ? BSONRegExp | RegExp | T : T;\r\n\r\n/** @public */\r\nexport interface RootFilterOperators<TSchema> extends Document {\r\n  $and?: Filter<TSchema>[];\r\n  $nor?: Filter<TSchema>[];\r\n  $or?: Filter<TSchema>[];\r\n  $text?: {\r\n    $search: string;\r\n    $language?: string;\r\n    $caseSensitive?: boolean;\r\n    $diacriticSensitive?: boolean;\r\n  };\r\n  $where?: string | ((this: TSchema) => boolean);\r\n  $comment?: string | Document;\r\n}\r\n\r\n/**\r\n * @public\r\n * A type that extends Document but forbids anything that \"looks like\" an object id.\r\n */\r\nexport type NonObjectIdLikeDocument = {\r\n  [key in keyof ObjectIdLike]?: never;\r\n} & Document;\r\n\r\n/** @public */\r\nexport interface FilterOperators<TValue> extends NonObjectIdLikeDocument {\r\n  // Comparison\r\n  $eq?: TValue;\r\n  $gt?: TValue;\r\n  $gte?: TValue;\r\n  $in?: ReadonlyArray<TValue>;\r\n  $lt?: TValue;\r\n  $lte?: TValue;\r\n  $ne?: TValue;\r\n  $nin?: ReadonlyArray<TValue>;\r\n  // Logical\r\n  $not?: TValue extends string ? FilterOperators<TValue> | RegExp : FilterOperators<TValue>;\r\n  // Element\r\n  /**\r\n   * When `true`, `$exists` matches the documents that contain the field,\r\n   * including documents where the field value is null.\r\n   */\r\n  $exists?: boolean;\r\n  $type?: BSONType | BSONTypeAlias;\r\n  // Evaluation\r\n  $expr?: Record<string, any>;\r\n  $jsonSchema?: Record<string, any>;\r\n  $mod?: TValue extends number ? [number, number] : never;\r\n  $regex?: TValue extends string ? RegExp | BSONRegExp | string : never;\r\n  $options?: TValue extends string ? string : never;\r\n  // Geospatial\r\n  $geoIntersects?: { $geometry: Document };\r\n  $geoWithin?: Document;\r\n  $near?: Document;\r\n  $nearSphere?: Document;\r\n  $maxDistance?: number;\r\n  // Array\r\n  $all?: ReadonlyArray<any>;\r\n  $elemMatch?: Document;\r\n  $size?: TValue extends ReadonlyArray<any> ? number : never;\r\n  // Bitwise\r\n  $bitsAllClear?: BitwiseFilter;\r\n  $bitsAllSet?: BitwiseFilter;\r\n  $bitsAnyClear?: BitwiseFilter;\r\n  $bitsAnySet?: BitwiseFilter;\r\n  $rand?: Record<string, never>;\r\n}\r\n\r\n/** @public */\r\nexport type BitwiseFilter =\r\n  | number /** numeric bit mask */\r\n  | Binary /** BinData bit mask */\r\n  | ReadonlyArray<number>; /** `[ <position1>, <position2>, ... ]` */\r\n\r\n/** @public */\r\nexport const BSONType = Object.freeze({\r\n  double: 1,\r\n  string: 2,\r\n  object: 3,\r\n  array: 4,\r\n  binData: 5,\r\n  undefined: 6,\r\n  objectId: 7,\r\n  bool: 8,\r\n  date: 9,\r\n  null: 10,\r\n  regex: 11,\r\n  dbPointer: 12,\r\n  javascript: 13,\r\n  symbol: 14,\r\n  javascriptWithScope: 15,\r\n  int: 16,\r\n  timestamp: 17,\r\n  long: 18,\r\n  decimal: 19,\r\n  minKey: -1,\r\n  maxKey: 127\r\n} as const);\r\n\r\n/** @public */\r\nexport type BSONType = typeof BSONType[keyof typeof BSONType];\r\n/** @public */\r\nexport type BSONTypeAlias = keyof typeof BSONType;\r\n\r\n/**\r\n * @public\r\n * Projection is flexible to permit the wide array of aggregation operators\r\n * @deprecated since v4.1.0: Since projections support all aggregation operations we have no plans to narrow this type further\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport type Projection<TSchema extends Document = Document> = Document;\r\n\r\n/**\r\n * @public\r\n * @deprecated since v4.1.0: Since projections support all aggregation operations we have no plans to narrow this type further\r\n */\r\nexport type ProjectionOperators = Document;\r\n\r\n/** @public */\r\nexport type IsAny<Type, ResultIfAny, ResultIfNotAny> = true extends false & Type\r\n  ? ResultIfAny\r\n  : ResultIfNotAny;\r\n\r\n/** @public */\r\nexport type Flatten<Type> = Type extends ReadonlyArray<infer Item> ? Item : Type;\r\n\r\n/** @public */\r\nexport type SchemaMember<T, V> = { [P in keyof T]?: V } | { [key: string]: V };\r\n\r\n/** @public */\r\nexport type IntegerType = number | Int32 | Long;\r\n\r\n/** @public */\r\nexport type NumericType = IntegerType | Decimal128 | Double;\r\n\r\n/** @public */\r\nexport type FilterOperations<T> = T extends Record<string, any>\r\n  ? { [key in keyof T]?: FilterOperators<T[key]> }\r\n  : FilterOperators<T>;\r\n\r\n/** @public */\r\nexport type KeysOfAType<TSchema, Type> = {\r\n  [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? key : never;\r\n}[keyof TSchema];\r\n\r\n/** @public */\r\nexport type KeysOfOtherType<TSchema, Type> = {\r\n  [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? never : key;\r\n}[keyof TSchema];\r\n\r\n/** @public */\r\nexport type AcceptedFields<TSchema, FieldType, AssignableType> = {\r\n  readonly [key in KeysOfAType<TSchema, FieldType>]?: AssignableType;\r\n};\r\n\r\n/** It avoids using fields with not acceptable types @public */\r\nexport type NotAcceptedFields<TSchema, FieldType> = {\r\n  readonly [key in KeysOfOtherType<TSchema, FieldType>]?: never;\r\n};\r\n\r\n/** @public */\r\nexport type OnlyFieldsOfType<TSchema, FieldType = any, AssignableType = FieldType> = IsAny<\r\n  TSchema[keyof TSchema],\r\n  Record<string, FieldType>,\r\n  AcceptedFields<TSchema, FieldType, AssignableType> &\r\n    NotAcceptedFields<TSchema, FieldType> &\r\n    Record<string, AssignableType>\r\n>;\r\n\r\n/** @public */\r\nexport type MatchKeysAndValues<TSchema> = Readonly<Partial<TSchema>> & Record<string, any>;\r\n\r\n/** @public */\r\nexport type AddToSetOperators<Type> = {\r\n  $each?: Array<Flatten<Type>>;\r\n};\r\n\r\n/** @public */\r\nexport type ArrayOperator<Type> = {\r\n  $each?: Array<Flatten<Type>>;\r\n  $slice?: number;\r\n  $position?: number;\r\n  $sort?: Sort;\r\n};\r\n\r\n/** @public */\r\nexport type SetFields<TSchema> = ({\r\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any> | undefined>]?:\r\n    | OptionalId<Flatten<TSchema[key]>>\r\n    | AddToSetOperators<Array<OptionalId<Flatten<TSchema[key]>>>>;\r\n} & NotAcceptedFields<TSchema, ReadonlyArray<any> | undefined>) & {\r\n  readonly [key: string]: AddToSetOperators<any> | any;\r\n};\r\n\r\n/** @public */\r\nexport type PushOperator<TSchema> = ({\r\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:\r\n    | Flatten<TSchema[key]>\r\n    | ArrayOperator<Array<Flatten<TSchema[key]>>>;\r\n} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\r\n  readonly [key: string]: ArrayOperator<any> | any;\r\n};\r\n\r\n/** @public */\r\nexport type PullOperator<TSchema> = ({\r\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:\r\n    | Partial<Flatten<TSchema[key]>>\r\n    | FilterOperations<Flatten<TSchema[key]>>;\r\n} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\r\n  readonly [key: string]: FilterOperators<any> | any;\r\n};\r\n\r\n/** @public */\r\nexport type PullAllOperator<TSchema> = ({\r\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: TSchema[key];\r\n} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\r\n  readonly [key: string]: ReadonlyArray<any>;\r\n};\r\n\r\n/** @public */\r\nexport type UpdateFilter<TSchema> = {\r\n  $currentDate?: OnlyFieldsOfType<\r\n    TSchema,\r\n    Date | Timestamp,\r\n    true | { $type: 'date' | 'timestamp' }\r\n  >;\r\n  $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\r\n  $min?: MatchKeysAndValues<TSchema>;\r\n  $max?: MatchKeysAndValues<TSchema>;\r\n  $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\r\n  $rename?: Record<string, string>;\r\n  $set?: MatchKeysAndValues<TSchema>;\r\n  $setOnInsert?: MatchKeysAndValues<TSchema>;\r\n  $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;\r\n  $addToSet?: SetFields<TSchema>;\r\n  $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;\r\n  $pull?: PullOperator<TSchema>;\r\n  $push?: PushOperator<TSchema>;\r\n  $pullAll?: PullAllOperator<TSchema>;\r\n  $bit?: OnlyFieldsOfType<\r\n    TSchema,\r\n    NumericType | undefined,\r\n    { and: IntegerType } | { or: IntegerType } | { xor: IntegerType }\r\n  >;\r\n} & Document;\r\n\r\n/** @public */\r\nexport type Nullable<AnyType> = AnyType | null | undefined;\r\n\r\n/** @public */\r\nexport type OneOrMore<T> = T | ReadonlyArray<T>;\r\n\r\n/** @public */\r\nexport type GenericListener = (...args: any[]) => void;\r\n\r\n/**\r\n * Event description type\r\n * @public\r\n */\r\nexport type EventsDescription = Record<string, GenericListener>;\r\n\r\n/** @public */\r\nexport type CommonEvents = 'newListener' | 'removeListener';\r\n\r\n/**\r\n * Typescript type safe event emitter\r\n * @public\r\n */\r\nexport declare interface TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {\r\n  addListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\r\n  addListener(\r\n    event: CommonEvents,\r\n    listener: (eventName: string | symbol, listener: GenericListener) => void\r\n  ): this;\r\n  addListener(event: string | symbol, listener: GenericListener): this;\r\n\r\n  on<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\r\n  on(\r\n    event: CommonEvents,\r\n    listener: (eventName: string | symbol, listener: GenericListener) => void\r\n  ): this;\r\n  on(event: string | symbol, listener: GenericListener): this;\r\n\r\n  once<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\r\n  once(\r\n    event: CommonEvents,\r\n    listener: (eventName: string | symbol, listener: GenericListener) => void\r\n  ): this;\r\n  once(event: string | symbol, listener: GenericListener): this;\r\n\r\n  removeListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\r\n  removeListener(\r\n    event: CommonEvents,\r\n    listener: (eventName: string | symbol, listener: GenericListener) => void\r\n  ): this;\r\n  removeListener(event: string | symbol, listener: GenericListener): this;\r\n\r\n  off<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\r\n  off(\r\n    event: CommonEvents,\r\n    listener: (eventName: string | symbol, listener: GenericListener) => void\r\n  ): this;\r\n  off(event: string | symbol, listener: GenericListener): this;\r\n\r\n  removeAllListeners<EventKey extends keyof Events>(\r\n    event?: EventKey | CommonEvents | symbol | string\r\n  ): this;\r\n\r\n  listeners<EventKey extends keyof Events>(\r\n    event: EventKey | CommonEvents | symbol | string\r\n  ): Events[EventKey][];\r\n\r\n  rawListeners<EventKey extends keyof Events>(\r\n    event: EventKey | CommonEvents | symbol | string\r\n  ): Events[EventKey][];\r\n\r\n  emit<EventKey extends keyof Events>(\r\n    event: EventKey | symbol,\r\n    ...args: Parameters<Events[EventKey]>\r\n  ): boolean;\r\n\r\n  listenerCount<EventKey extends keyof Events>(\r\n    type: EventKey | CommonEvents | symbol | string\r\n  ): number;\r\n\r\n  prependListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\r\n  prependListener(\r\n    event: CommonEvents,\r\n    listener: (eventName: string | symbol, listener: GenericListener) => void\r\n  ): this;\r\n  prependListener(event: string | symbol, listener: GenericListener): this;\r\n\r\n  prependOnceListener<EventKey extends keyof Events>(\r\n    event: EventKey,\r\n    listener: Events[EventKey]\r\n  ): this;\r\n  prependOnceListener(\r\n    event: CommonEvents,\r\n    listener: (eventName: string | symbol, listener: GenericListener) => void\r\n  ): this;\r\n  prependOnceListener(event: string | symbol, listener: GenericListener): this;\r\n\r\n  eventNames(): string[];\r\n  getMaxListeners(): number;\r\n  setMaxListeners(n: number): this;\r\n}\r\n\r\n/**\r\n * Typescript type safe event emitter\r\n * @public\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport class TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {}\r\n\r\n/** @public */\r\nexport class CancellationToken extends TypedEventEmitter<{ cancel(): void }> {}\r\n\r\n/**\r\n * Helper types for dot-notation filter attributes\r\n */\r\n\r\n/** @public */\r\nexport type Join<T extends unknown[], D extends string> = T extends []\r\n  ? ''\r\n  : T extends [string | number]\r\n  ? `${T[0]}`\r\n  : T extends [string | number, ...infer R]\r\n  ? `${T[0]}${D}${Join<R, D>}`\r\n  : string;\r\n\r\n/** @public */\r\nexport type PropertyType<Type, Property extends string> = string extends Property\r\n  ? unknown\r\n  : Property extends keyof Type\r\n  ? Type[Property]\r\n  : Property extends `${number}`\r\n  ? Type extends ReadonlyArray<infer ArrayType>\r\n    ? ArrayType\r\n    : unknown\r\n  : Property extends `${infer Key}.${infer Rest}`\r\n  ? Key extends `${number}`\r\n    ? Type extends ReadonlyArray<infer ArrayType>\r\n      ? PropertyType<ArrayType, Rest>\r\n      : unknown\r\n    : Key extends keyof Type\r\n    ? Type[Key] extends Map<string, infer MapType>\r\n      ? MapType\r\n      : PropertyType<Type[Key], Rest>\r\n    : unknown\r\n  : unknown;\r\n\r\n/**\r\n * @public\r\n * returns tuple of strings (keys to be joined on '.') that represent every path into a schema\r\n * https://docs.mongodb.com/manual/tutorial/query-embedded-documents/\r\n */\r\nexport type NestedPaths<Type> = Type extends\r\n  | string\r\n  | number\r\n  | boolean\r\n  | Date\r\n  | RegExp\r\n  | Buffer\r\n  | Uint8Array\r\n  | ((...args: any[]) => any)\r\n  | { _bsontype: string }\r\n  ? []\r\n  : Type extends ReadonlyArray<infer ArrayType>\r\n  ? [number, ...NestedPaths<ArrayType>]\r\n  : Type extends Map<string, any>\r\n  ? [string]\r\n  : // eslint-disable-next-line @typescript-eslint/ban-types\r\n  Type extends object\r\n  ? {\r\n      [Key in Extract<keyof Type, string>]: Type[Key] extends Type // type of value extends the parent\r\n        ? [Key]\r\n        : // for a recursive union type, the child will never extend the parent type.\r\n        // but the parent will still extend the child\r\n        Type extends Type[Key]\r\n        ? [Key]\r\n        : Type[Key] extends ReadonlyArray<infer ArrayType> // handling recursive types with arrays\r\n        ? Type extends ArrayType // is the type of the parent the same as the type of the array?\r\n          ? [Key] // yes, it's a recursive array type\r\n          : // for unions, the child type extends the parent\r\n          ArrayType extends Type\r\n          ? [Key] // we have a recursive array union\r\n          : // child is an array, but it's not a recursive array\r\n            [Key, ...NestedPaths<Type[Key]>]\r\n        : // child is not structured the same as the parent\r\n          [Key, ...NestedPaths<Type[Key]>];\r\n    }[Extract<keyof Type, string>]\r\n  : [];\r\n"]},"metadata":{},"sourceType":"script"}