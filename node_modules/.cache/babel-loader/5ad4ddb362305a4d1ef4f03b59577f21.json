{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesCursor = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\n\nconst abstract_cursor_1 = require(\"../cursor/abstract_cursor\");\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst common_functions_1 = require(\"./common_functions\");\n\nconst execute_operation_1 = require(\"./execute_operation\");\n\nconst operation_1 = require(\"./operation\");\n\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version', // text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes\n'2dsphereIndexVersion', // 2d indexes\n'bits', 'min', 'max', // geoHaystack Indexes\n'bucketSize', // wildcard indexes\n'wildcardProjection']);\n\nfunction makeIndexSpec(indexSpec, options) {\n  const indexParameters = (0, utils_1.parseIndexOptions)(indexSpec); // Generate the index name\n\n  const name = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n  const finalIndexSpec = {\n    name,\n    key: indexParameters.fieldHash\n  }; // merge valid index options into the index spec\n\n  for (const optionName in options) {\n    if (VALID_INDEX_OPTIONS.has(optionName)) {\n      finalIndexSpec[optionName] = options[optionName];\n    }\n  }\n\n  return finalIndexSpec;\n}\n/** @internal */\n\n\nclass IndexesOperation extends operation_1.AbstractOperation {\n  constructor(collection, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = this.options;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {\n      full: true,\n      ...options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\n\nclass CreateIndexesOperation extends command_1.CommandOperation {\n  constructor(parent, collectionName, indexes, options) {\n    super(parent, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionName = collectionName;\n    this.indexes = indexes;\n  }\n\n  execute(server, session, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server); // Ensure we generate the correct name if the parameter is not set\n\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(new error_1.MongoCompatibilityError(`Server ${server.name}, which reports wire version ${serverWireVersion}, ` + 'does not support collation'));\n        return;\n      }\n\n      if (indexes[i].name == null) {\n        const keys = [];\n\n        for (const name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        } // Set the name\n\n\n        indexes[i].name = keys.join('_');\n      }\n    }\n\n    const cmd = {\n      createIndexes: this.collectionName,\n      indexes\n    };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n\n      cmd.commitQuorum = options.commitQuorum;\n    } // collation is set on each index, it should not be defined at the root\n\n\n    this.options.collation = undefined;\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames);\n    });\n  }\n\n}\n\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\n\nclass CreateIndexOperation extends CreateIndexesOperation {\n  constructor(parent, collectionName, indexSpec, options) {\n    // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n\n}\n\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\n\nclass EnsureIndexOperation extends CreateIndexOperation {\n  constructor(db, collectionName, indexSpec, options) {\n    super(db, collectionName, indexSpec, options);\n    this.readPreference = read_preference_1.ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n\n  execute(server, session, callback) {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({\n      session\n    });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n\n      super.execute(server, session, callback);\n    });\n  }\n\n}\n\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\n\nclass DropIndexOperation extends command_1.CommandOperation {\n  constructor(collection, indexName, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n\n  execute(server, session, callback) {\n    const cmd = {\n      dropIndexes: this.collection.collectionName,\n      index: this.indexName\n    };\n    super.executeCommand(server, session, cmd, callback);\n  }\n\n}\n\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\n\nclass DropIndexesOperation extends DropIndexOperation {\n  constructor(collection, options) {\n    super(collection, '*', options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n\n}\n\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\n\nclass ListIndexesOperation extends command_1.CommandOperation {\n  constructor(collection, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n\n  execute(server, session, callback) {\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const cursor = this.options.batchSize ? {\n      batchSize: this.options.batchSize\n    } : {};\n    const command = {\n      listIndexes: this.collectionNamespace.collection,\n      cursor\n    }; // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n    if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @public */\n\nclass ListIndexesCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(collection, options) {\n    super((0, utils_1.getTopology)(collection), collection.s.namespace, options);\n    this.parent = collection;\n    this.options = options;\n  }\n\n  clone() {\n    return new ListIndexesCursor(this.parent, { ...this.options,\n      ...this.cursorOptions\n    });\n  }\n  /** @internal */\n\n\n  _initialize(session, callback) {\n    const operation = new ListIndexesOperation(this.parent, { ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    (0, execute_operation_1.executeOperation)(this.parent, operation, (err, response) => {\n      if (err || response == null) return callback(err); // TODO: NODE-2882\n\n      callback(undefined, {\n        server: operation.server,\n        session,\n        response\n      });\n    });\n  }\n\n}\n\nexports.ListIndexesCursor = ListIndexesCursor;\n/** @internal */\n\nclass IndexExistsOperation extends operation_1.AbstractOperation {\n  constructor(collection, indexes, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const indexes = this.indexes;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, (err, indexInformation) => {\n      // If we have an error return\n      if (err != null) return callback(err); // Let's check for the index names\n\n      if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null); // Check in list of indexes\n\n      for (let i = 0; i < indexes.length; i++) {\n        if (indexInformation[indexes[i]] == null) {\n          return callback(undefined, false);\n        }\n      } // All keys found return true\n\n\n      return callback(undefined, true);\n    });\n  }\n\n}\n\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\n\nclass IndexInformationOperation extends operation_1.AbstractOperation {\n  constructor(db, name, options) {\n    super(options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.db = db;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    const db = this.db;\n    const name = this.name;\n    (0, common_functions_1.indexInformation)(db, name, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexInformationOperation = IndexInformationOperation;\n(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);\n(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":"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","names":["VALID_INDEX_OPTIONS","Set","makeIndexSpec","indexSpec","options","indexParameters","name","finalIndexSpec","key","fieldHash","optionName","has","IndexesOperation","operation_1","constructor","collection","execute","server","session","callback","coll","s","db","collectionName","full","readPreference","exports","CreateIndexesOperation","command_1","parent","indexes","serverWireVersion","i","length","collation","error_1","keys","push","join","cmd","createIndexes","commitQuorum","undefined","executeCommand","err","indexNames","map","index","CreateIndexOperation","EnsureIndexOperation","read_preference_1","primary","indexName","cursor","listIndexes","toArray","code","NamespaceNotFound","Array","isArray","some","DropIndexOperation","dropIndexes","DropIndexesOperation","ListIndexesOperation","collectionNamespace","namespace","batchSize","command","comment","ListIndexesCursor","abstract_cursor_1","clone","cursorOptions","_initialize","operation","response","IndexExistsOperation","indexInformation","IndexInformationOperation","READ_OPERATION","RETRYABLE","CURSOR_CREATING","WRITE_OPERATION"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\operations\\indexes.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport { AbstractCursor } from '../cursor/abstract_cursor';\nimport type { Db } from '../db';\nimport { MongoCompatibilityError, MONGODB_ERROR_CODES, MongoServerError } from '../error';\nimport type { OneOrMore } from '../mongo_types';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport {\n  Callback,\n  getTopology,\n  maxWireVersion,\n  MongoDBNamespace,\n  parseIndexOptions\n} from '../utils';\nimport {\n  CollationOptions,\n  CommandOperation,\n  CommandOperationOptions,\n  OperationParent\n} from './command';\nimport { indexInformation, IndexInformationOptions } from './common_functions';\nimport { executeOperation, ExecutionResult } from './execute_operation';\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\n\nconst VALID_INDEX_OPTIONS = new Set([\n  'background',\n  'unique',\n  'name',\n  'partialFilterExpression',\n  'sparse',\n  'hidden',\n  'expireAfterSeconds',\n  'storageEngine',\n  'collation',\n  'version',\n\n  // text indexes\n  'weights',\n  'default_language',\n  'language_override',\n  'textIndexVersion',\n\n  // 2d-sphere indexes\n  '2dsphereIndexVersion',\n\n  // 2d indexes\n  'bits',\n  'min',\n  'max',\n\n  // geoHaystack Indexes\n  'bucketSize',\n\n  // wildcard indexes\n  'wildcardProjection'\n]);\n\n/** @public */\nexport type IndexDirection = -1 | 1 | '2d' | '2dsphere' | 'text' | 'geoHaystack' | number;\n\n/** @public */\nexport type IndexSpecification = OneOrMore<\n  | string\n  | [string, IndexDirection]\n  | { [key: string]: IndexDirection }\n  | [string, IndexDirection][]\n  | { [key: string]: IndexDirection }[]\n>;\n\n/** @public */\nexport interface IndexDescription\n  extends Pick<\n    CreateIndexesOptions,\n    | 'background'\n    | 'unique'\n    | 'partialFilterExpression'\n    | 'sparse'\n    | 'hidden'\n    | 'expireAfterSeconds'\n    | 'storageEngine'\n    | 'version'\n    | 'weights'\n    | 'default_language'\n    | 'language_override'\n    | 'textIndexVersion'\n    | '2dsphereIndexVersion'\n    | 'bits'\n    | 'min'\n    | 'max'\n    | 'bucketSize'\n    | 'wildcardProjection'\n  > {\n  collation?: CollationOptions;\n  name?: string;\n  key: Document;\n}\n\n/** @public */\nexport interface CreateIndexesOptions extends CommandOperationOptions {\n  /** Creates the index in the background, yielding whenever possible. */\n  background?: boolean;\n  /** Creates an unique index. */\n  unique?: boolean;\n  /** Override the autogenerated index name (useful if the resulting name is larger than 128 bytes) */\n  name?: string;\n  /** Creates a partial index based on the given filter object (MongoDB 3.2 or higher) */\n  partialFilterExpression?: Document;\n  /** Creates a sparse index. */\n  sparse?: boolean;\n  /** Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher) */\n  expireAfterSeconds?: number;\n  /** Allows users to configure the storage engine on a per-index basis when creating an index. (MongoDB 3.0 or higher) */\n  storageEngine?: Document;\n  /** (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes. */\n  commitQuorum?: number | string;\n  /** Specifies the index version number, either 0 or 1. */\n  version?: number;\n  // text indexes\n  weights?: Document;\n  default_language?: string;\n  language_override?: string;\n  textIndexVersion?: number;\n  // 2d-sphere indexes\n  '2dsphereIndexVersion'?: number;\n  // 2d indexes\n  bits?: number;\n  /** For geospatial indexes set the lower bound for the co-ordinates. */\n  min?: number;\n  /** For geospatial indexes set the high bound for the co-ordinates. */\n  max?: number;\n  // geoHaystack Indexes\n  bucketSize?: number;\n  // wildcard indexes\n  wildcardProjection?: Document;\n  /** Specifies that the index should exist on the target collection but should not be used by the query planner when executing operations. (MongoDB 4.4 or higher) */\n  hidden?: boolean;\n}\n\nfunction makeIndexSpec(indexSpec: IndexSpecification, options: any): IndexDescription {\n  const indexParameters = parseIndexOptions(indexSpec);\n\n  // Generate the index name\n  const name = typeof options.name === 'string' ? options.name : indexParameters.name;\n\n  // Set up the index\n  const finalIndexSpec: Document = { name, key: indexParameters.fieldHash };\n\n  // merge valid index options into the index spec\n  for (const optionName in options) {\n    if (VALID_INDEX_OPTIONS.has(optionName)) {\n      finalIndexSpec[optionName] = options[optionName];\n    }\n  }\n\n  return finalIndexSpec as IndexDescription;\n}\n\n/** @internal */\nexport class IndexesOperation extends AbstractOperation<Document[]> {\n  override options: IndexInformationOptions;\n  collection: Collection;\n\n  constructor(collection: Collection, options: IndexInformationOptions) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document[]>\n  ): void {\n    const coll = this.collection;\n    const options = this.options;\n\n    indexInformation(\n      coll.s.db,\n      coll.collectionName,\n      { full: true, ...options, readPreference: this.readPreference, session },\n      callback\n    );\n  }\n}\n\n/** @internal */\nexport class CreateIndexesOperation<\n  T extends string | string[] = string[]\n> extends CommandOperation<T> {\n  override options: CreateIndexesOptions;\n  collectionName: string;\n  indexes: IndexDescription[];\n\n  constructor(\n    parent: OperationParent,\n    collectionName: string,\n    indexes: IndexDescription[],\n    options?: CreateIndexesOptions\n  ) {\n    super(parent, options);\n\n    this.options = options ?? {};\n    this.collectionName = collectionName;\n\n    this.indexes = indexes;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<T>\n  ): void {\n    const options = this.options;\n    const indexes = this.indexes;\n\n    const serverWireVersion = maxWireVersion(server);\n\n    // Ensure we generate the correct name if the parameter is not set\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(\n          new MongoCompatibilityError(\n            `Server ${server.name}, which reports wire version ${serverWireVersion}, ` +\n              'does not support collation'\n          )\n        );\n        return;\n      }\n\n      if (indexes[i].name == null) {\n        const keys = [];\n\n        for (const name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        }\n\n        // Set the name\n        indexes[i].name = keys.join('_');\n      }\n    }\n\n    const cmd: Document = { createIndexes: this.collectionName, indexes };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(\n          new MongoCompatibilityError(\n            'Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'\n          )\n        );\n        return;\n      }\n      cmd.commitQuorum = options.commitQuorum;\n    }\n\n    // collation is set on each index, it should not be defined at the root\n    this.options.collation = undefined;\n\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames as T);\n    });\n  }\n}\n\n/** @internal */\nexport class CreateIndexOperation extends CreateIndexesOperation<string> {\n  constructor(\n    parent: OperationParent,\n    collectionName: string,\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions\n  ) {\n    // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<string>\n  ): void {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n}\n\n/** @internal */\nexport class EnsureIndexOperation extends CreateIndexOperation {\n  db: Db;\n\n  constructor(\n    db: Db,\n    collectionName: string,\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions\n  ) {\n    super(db, collectionName, indexSpec, options);\n\n    this.readPreference = ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n\n  override execute(server: Server, session: ClientSession | undefined, callback: Callback): void {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({ session });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && (err as MongoServerError).code !== MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n\n      super.execute(server, session, callback);\n    });\n  }\n}\n\n/** @public */\nexport type DropIndexesOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropIndexOperation extends CommandOperation<Document> {\n  override options: DropIndexesOptions;\n  collection: Collection;\n  indexName: string;\n\n  constructor(collection: Collection, indexName: string, options?: DropIndexesOptions) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document>\n  ): void {\n    const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };\n    super.executeCommand(server, session, cmd, callback);\n  }\n}\n\n/** @internal */\nexport class DropIndexesOperation extends DropIndexOperation {\n  constructor(collection: Collection, options: DropIndexesOptions) {\n    super(collection, '*', options);\n  }\n\n  override execute(server: Server, session: ClientSession | undefined, callback: Callback): void {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n}\n\n/** @public */\nexport interface ListIndexesOptions extends CommandOperationOptions {\n  /** The batchSize for the returned command cursor or if pre 2.8 the systems batch collection */\n  batchSize?: number;\n}\n\n/** @internal */\nexport class ListIndexesOperation extends CommandOperation<Document> {\n  override options: ListIndexesOptions;\n  collectionNamespace: MongoDBNamespace;\n\n  constructor(collection: Collection, options?: ListIndexesOptions) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document>\n  ): void {\n    const serverWireVersion = maxWireVersion(server);\n\n    const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};\n\n    const command: Document = { listIndexes: this.collectionNamespace.collection, cursor };\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n}\n\n/** @public */\nexport class ListIndexesCursor extends AbstractCursor {\n  parent: Collection;\n  options?: ListIndexesOptions;\n\n  constructor(collection: Collection, options?: ListIndexesOptions) {\n    super(getTopology(collection), collection.s.namespace, options);\n    this.parent = collection;\n    this.options = options;\n  }\n\n  clone(): ListIndexesCursor {\n    return new ListIndexesCursor(this.parent, {\n      ...this.options,\n      ...this.cursorOptions\n    });\n  }\n\n  /** @internal */\n  _initialize(session: ClientSession | undefined, callback: Callback<ExecutionResult>): void {\n    const operation = new ListIndexesOperation(this.parent, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n\n    executeOperation(this.parent, operation, (err, response) => {\n      if (err || response == null) return callback(err);\n\n      // TODO: NODE-2882\n      callback(undefined, { server: operation.server, session, response });\n    });\n  }\n}\n\n/** @internal */\nexport class IndexExistsOperation extends AbstractOperation<boolean> {\n  override options: IndexInformationOptions;\n  collection: Collection;\n  indexes: string | string[];\n\n  constructor(\n    collection: Collection,\n    indexes: string | string[],\n    options: IndexInformationOptions\n  ) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    const coll = this.collection;\n    const indexes = this.indexes;\n\n    indexInformation(\n      coll.s.db,\n      coll.collectionName,\n      { ...this.options, readPreference: this.readPreference, session },\n      (err, indexInformation) => {\n        // If we have an error return\n        if (err != null) return callback(err);\n        // Let's check for the index names\n        if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null);\n        // Check in list of indexes\n        for (let i = 0; i < indexes.length; i++) {\n          if (indexInformation[indexes[i]] == null) {\n            return callback(undefined, false);\n          }\n        }\n\n        // All keys found return true\n        return callback(undefined, true);\n      }\n    );\n  }\n}\n\n/** @internal */\nexport class IndexInformationOperation extends AbstractOperation<Document> {\n  override options: IndexInformationOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options?: IndexInformationOptions) {\n    super(options);\n    this.options = options ?? {};\n    this.db = db;\n    this.name = name;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document>\n  ): void {\n    const db = this.db;\n    const name = this.name;\n\n    indexInformation(\n      db,\n      name,\n      { ...this.options, readPreference: this.readPreference, session },\n      callback\n    );\n  }\n}\n\ndefineAspects(ListIndexesOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.CURSOR_CREATING\n]);\ndefineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(CreateIndexOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(EnsureIndexOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropIndexOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropIndexesOperation, [Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}