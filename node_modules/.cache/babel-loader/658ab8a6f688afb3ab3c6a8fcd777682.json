{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;\n\nconst net = require(\"net\");\n\nconst socks_1 = require(\"socks\");\n\nconst tls = require(\"tls\");\n\nconst bson_1 = require(\"../bson\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst auth_provider_1 = require(\"./auth/auth_provider\");\n\nconst gssapi_1 = require(\"./auth/gssapi\");\n\nconst mongocr_1 = require(\"./auth/mongocr\");\n\nconst mongodb_aws_1 = require(\"./auth/mongodb_aws\");\n\nconst plain_1 = require(\"./auth/plain\");\n\nconst providers_1 = require(\"./auth/providers\");\n\nconst scram_1 = require(\"./auth/scram\");\n\nconst x509_1 = require(\"./auth/x509\");\n\nconst connection_1 = require(\"./connection\");\n\nconst constants_2 = require(\"./wire_protocol/constants\");\n\nconst AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);\n\nfunction connect(options, callback) {\n  makeConnection({ ...options,\n    existingSocket: undefined\n  }, (err, socket) => {\n    var _a;\n\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nexports.connect = connect;\n\nfunction checkSupportedServer(hello, options) {\n  var _a;\n\n  const serverVersionHighEnough = hello && (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof bson_1.Int32) && hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = hello && (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof bson_1.Int32) && hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(hello.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;\n  return new error_1.MongoCompatibilityError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !AUTH_PROVIDERS.get(credentials.mechanism)) {\n      callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n\n    const start = new Date().getTime();\n    conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n        callback(new error_1.MongoServerError(response));\n        return;\n      }\n\n      if (!('isWritablePrimary' in response)) {\n        // Provide hello-style response document.\n        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n      }\n\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (options.loadBalanced) {\n        if (!response.serviceId) {\n          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));\n        }\n      } // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n\n\n      conn.hello = response;\n      conn.lastHelloMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n\n        if (!provider) {\n          return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n        }\n\n        provider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const {\n    serverApi\n  } = authContext.connection;\n  const handshakeDoc = {\n    [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: true,\n    helloOk: true,\n    client: options.metadata || (0, utils_1.makeClientMetadata)(options),\n    compression: compressors,\n    loadBalanced: options.loadBalanced\n  };\n  const credentials = authContext.credentials;\n\n  if (credentials) {\n    if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n      const provider = AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n\n      if (!provider) {\n        // This auth mechanism is always present.\n        return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n      }\n\n      return provider.prepare(handshakeDoc, authContext, callback);\n    }\n\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\n\n    if (!provider) {\n      return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n    }\n\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n\n  callback(undefined, handshakeDoc);\n}\n/** @public */\n\n\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\n\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\n\nfunction parseConnectOptions(options) {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  const result = {};\n\n  for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\nfunction parseSslOptions(options) {\n  const result = parseConnectOptions(options); // Merge in valid SSL options\n\n  for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options, _callback) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n  const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n  const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n  const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n  const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n  const connectTimeoutMS = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n  const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n  const keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 120000;\n  const existingSocket = options.existingSocket;\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection({ ...options,\n      connectTimeoutMS // Should always be present for Socks5\n\n    }, callback);\n  }\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\n\nfunction makeSocks5Connection(options, callback) {\n  var _a, _b;\n\n  const hostAddress = utils_1.HostAddress.fromHostPort((_a = options.proxyHost) !== null && _a !== void 0 ? _a : '', // proxyHost is guaranteed to set here\n  (_b = options.proxyPort) !== null && _b !== void 0 ? _b : 1080); // First, connect to the proxy server itself:\n\n  makeConnection({ ...options,\n    hostAddress,\n    tls: false,\n    proxyHost: undefined\n  }, (err, rawSocket) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const destination = parseConnectOptions(options);\n\n    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n    } // Then, establish the Socks5 proxy connection:\n\n\n    socks_1.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    }, (err, info) => {\n      if (err) {\n        return callback(connectionFailureError('error', err));\n      } // Finally, now treat the resulting duplex stream as the\n      // socket over which we send and receive wire protocol messages:\n\n\n      makeConnection({ ...options,\n        existingSocket: info.socket,\n        proxyHost: undefined\n      }, callback);\n    });\n  });\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"mappings":"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","names":["AUTH_PROVIDERS","Map","providers_1","MONGODB_AWS","mongodb_aws_1","MONGODB_CR","mongocr_1","MONGODB_GSSAPI","gssapi_1","MONGODB_PLAIN","plain_1","MONGODB_SCRAM_SHA1","scram_1","MONGODB_SCRAM_SHA256","MONGODB_X509","x509_1","connect","options","callback","makeConnection","existingSocket","undefined","err","socket","ConnectionType","connectionType","_a","connection_1","autoEncrypter","performInitialHandshake","exports","checkSupportedServer","hello","serverVersionHighEnough","maxWireVersion","bson_1","constants_2","serverVersionLowEnough","minWireVersion","message","hostAddress","JSON","stringify","error_1","conn","_callback","ret","destroy","credentials","mechanism","MONGODB_DEFAULT","get","authContext","auth_provider_1","prepareHandshakeDocument","handshakeDoc","handshakeOptions","Object","assign","connectTimeoutMS","socketTimeoutMS","start","Date","getTime","command","response","ok","isWritablePrimary","constants_1","helloOk","supportedServerErr","loadBalanced","serviceId","lastHelloMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","provider","auth","compressors","serverApi","connection","version","client","metadata","compression","username","saslSupportedMechs","source","prepare","parseConnectOptions","result","name","socketPath","path","host","port","parseSslOptions","servername","net","isIP","SOCKET_ERROR_EVENT_LIST","SOCKET_ERROR_EVENTS","Set","useTLS","tls","keepAlive","_b","_c","Reflect","_d","noDelay","_e","_f","rejectUnauthorized","_g","keepAliveInitialDelay","_h","Math","round","_j","proxyHost","makeSocks5Connection","tlsSocket","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","cancellationToken","removeListener","connectHandler","connectionFailureError","authorizationError","once","process","nextTick","utils_1","fromHostPort","proxyPort","rawSocket","destination","socks_1","existing_socket","timeout","proxy","type","userId","proxyUsername","password","proxyPassword","info"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\cmap\\connect.ts"],"sourcesContent":["import type { Socket, SocketConnectOpts } from 'net';\r\nimport * as net from 'net';\r\nimport { SocksClient } from 'socks';\r\nimport type { ConnectionOptions as TLSConnectionOpts, TLSSocket } from 'tls';\r\nimport * as tls from 'tls';\r\n\r\nimport type { Document } from '../bson';\r\nimport { Int32 } from '../bson';\r\nimport { LEGACY_HELLO_COMMAND } from '../constants';\r\nimport {\r\n  AnyError,\r\n  MongoCompatibilityError,\r\n  MongoInvalidArgumentError,\r\n  MongoNetworkError,\r\n  MongoNetworkTimeoutError,\r\n  MongoRuntimeError,\r\n  MongoServerError\r\n} from '../error';\r\nimport { Callback, ClientMetadata, HostAddress, makeClientMetadata, ns } from '../utils';\r\nimport { AuthContext, AuthProvider } from './auth/auth_provider';\r\nimport { GSSAPI } from './auth/gssapi';\r\nimport { MongoCR } from './auth/mongocr';\r\nimport { MongoDBAWS } from './auth/mongodb_aws';\r\nimport { Plain } from './auth/plain';\r\nimport { AuthMechanism } from './auth/providers';\r\nimport { ScramSHA1, ScramSHA256 } from './auth/scram';\r\nimport { X509 } from './auth/x509';\r\nimport { Connection, ConnectionOptions, CryptoConnection } from './connection';\r\nimport {\r\n  MAX_SUPPORTED_SERVER_VERSION,\r\n  MAX_SUPPORTED_WIRE_VERSION,\r\n  MIN_SUPPORTED_SERVER_VERSION,\r\n  MIN_SUPPORTED_WIRE_VERSION\r\n} from './wire_protocol/constants';\r\n\r\nconst AUTH_PROVIDERS = new Map<AuthMechanism | string, AuthProvider>([\r\n  [AuthMechanism.MONGODB_AWS, new MongoDBAWS()],\r\n  [AuthMechanism.MONGODB_CR, new MongoCR()],\r\n  [AuthMechanism.MONGODB_GSSAPI, new GSSAPI()],\r\n  [AuthMechanism.MONGODB_PLAIN, new Plain()],\r\n  [AuthMechanism.MONGODB_SCRAM_SHA1, new ScramSHA1()],\r\n  [AuthMechanism.MONGODB_SCRAM_SHA256, new ScramSHA256()],\r\n  [AuthMechanism.MONGODB_X509, new X509()]\r\n]);\r\n\r\n/** @public */\r\nexport type Stream = Socket | TLSSocket;\r\n\r\nexport function connect(options: ConnectionOptions, callback: Callback<Connection>): void {\r\n  makeConnection({ ...options, existingSocket: undefined }, (err, socket) => {\r\n    if (err || !socket) {\r\n      return callback(err);\r\n    }\r\n\r\n    let ConnectionType = options.connectionType ?? Connection;\r\n    if (options.autoEncrypter) {\r\n      ConnectionType = CryptoConnection;\r\n    }\r\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\r\n  });\r\n}\r\n\r\nfunction checkSupportedServer(hello: Document, options: ConnectionOptions) {\r\n  const serverVersionHighEnough =\r\n    hello &&\r\n    (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof Int32) &&\r\n    hello.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\r\n  const serverVersionLowEnough =\r\n    hello &&\r\n    (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof Int32) &&\r\n    hello.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\r\n\r\n  if (serverVersionHighEnough) {\r\n    if (serverVersionLowEnough) {\r\n      return null;\r\n    }\r\n\r\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(\r\n      hello.minWireVersion\r\n    )}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\r\n    return new MongoCompatibilityError(message);\r\n  }\r\n\r\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${\r\n    JSON.stringify(hello.maxWireVersion) ?? 0\r\n  }, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\r\n  return new MongoCompatibilityError(message);\r\n}\r\n\r\nfunction performInitialHandshake(\r\n  conn: Connection,\r\n  options: ConnectionOptions,\r\n  _callback: Callback\r\n) {\r\n  const callback: Callback<Document> = function (err, ret) {\r\n    if (err && conn) {\r\n      conn.destroy();\r\n    }\r\n    _callback(err, ret);\r\n  };\r\n\r\n  const credentials = options.credentials;\r\n  if (credentials) {\r\n    if (\r\n      !(credentials.mechanism === AuthMechanism.MONGODB_DEFAULT) &&\r\n      !AUTH_PROVIDERS.get(credentials.mechanism)\r\n    ) {\r\n      callback(\r\n        new MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`)\r\n      );\r\n      return;\r\n    }\r\n  }\r\n\r\n  const authContext = new AuthContext(conn, credentials, options);\r\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\r\n    if (err || !handshakeDoc) {\r\n      return callback(err);\r\n    }\r\n\r\n    const handshakeOptions: Document = Object.assign({}, options);\r\n    if (typeof options.connectTimeoutMS === 'number') {\r\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\r\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\r\n    }\r\n\r\n    const start = new Date().getTime();\r\n    conn.command(ns('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      if (response?.ok === 0) {\r\n        callback(new MongoServerError(response));\r\n        return;\r\n      }\r\n\r\n      if (!('isWritablePrimary' in response)) {\r\n        // Provide hello-style response document.\r\n        response.isWritablePrimary = response[LEGACY_HELLO_COMMAND];\r\n      }\r\n\r\n      if (response.helloOk) {\r\n        conn.helloOk = true;\r\n      }\r\n\r\n      const supportedServerErr = checkSupportedServer(response, options);\r\n      if (supportedServerErr) {\r\n        callback(supportedServerErr);\r\n        return;\r\n      }\r\n\r\n      if (options.loadBalanced) {\r\n        if (!response.serviceId) {\r\n          return callback(\r\n            new MongoCompatibilityError(\r\n              'Driver attempted to initialize in load balancing mode, ' +\r\n                'but the server does not support this mode.'\r\n            )\r\n          );\r\n        }\r\n      }\r\n\r\n      // NOTE: This is metadata attached to the connection while porting away from\r\n      //       handshake being done in the `Server` class. Likely, it should be\r\n      //       relocated, or at very least restructured.\r\n      conn.hello = response;\r\n      conn.lastHelloMS = new Date().getTime() - start;\r\n\r\n      if (!response.arbiterOnly && credentials) {\r\n        // store the response on auth context\r\n        authContext.response = response;\r\n\r\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\r\n        const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\r\n        if (!provider) {\r\n          return callback(\r\n            new MongoInvalidArgumentError(\r\n              `No AuthProvider for ${resolvedCredentials.mechanism} defined.`\r\n            )\r\n          );\r\n        }\r\n        provider.auth(authContext, err => {\r\n          if (err) return callback(err);\r\n          callback(undefined, conn);\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      callback(undefined, conn);\r\n    });\r\n  });\r\n}\r\n\r\nexport interface HandshakeDocument extends Document {\r\n  /**\r\n   * @deprecated Use hello instead\r\n   */\r\n  ismaster?: boolean;\r\n  hello?: boolean;\r\n  helloOk?: boolean;\r\n  client: ClientMetadata;\r\n  compression: string[];\r\n  saslSupportedMechs?: string;\r\n  loadBalanced: boolean;\r\n}\r\n\r\nfunction prepareHandshakeDocument(authContext: AuthContext, callback: Callback<HandshakeDocument>) {\r\n  const options = authContext.options;\r\n  const compressors = options.compressors ? options.compressors : [];\r\n  const { serverApi } = authContext.connection;\r\n\r\n  const handshakeDoc: HandshakeDocument = {\r\n    [serverApi?.version ? 'hello' : LEGACY_HELLO_COMMAND]: true,\r\n    helloOk: true,\r\n    client: options.metadata || makeClientMetadata(options),\r\n    compression: compressors,\r\n    loadBalanced: options.loadBalanced\r\n  };\r\n\r\n  const credentials = authContext.credentials;\r\n  if (credentials) {\r\n    if (credentials.mechanism === AuthMechanism.MONGODB_DEFAULT && credentials.username) {\r\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\r\n\r\n      const provider = AUTH_PROVIDERS.get(AuthMechanism.MONGODB_SCRAM_SHA256);\r\n      if (!provider) {\r\n        // This auth mechanism is always present.\r\n        return callback(\r\n          new MongoInvalidArgumentError(\r\n            `No AuthProvider for ${AuthMechanism.MONGODB_SCRAM_SHA256} defined.`\r\n          )\r\n        );\r\n      }\r\n      return provider.prepare(handshakeDoc, authContext, callback);\r\n    }\r\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\r\n    if (!provider) {\r\n      return callback(\r\n        new MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`)\r\n      );\r\n    }\r\n    return provider.prepare(handshakeDoc, authContext, callback);\r\n  }\r\n  callback(undefined, handshakeDoc);\r\n}\r\n\r\n/** @public */\r\nexport const LEGAL_TLS_SOCKET_OPTIONS = [\r\n  'ALPNProtocols',\r\n  'ca',\r\n  'cert',\r\n  'checkServerIdentity',\r\n  'ciphers',\r\n  'crl',\r\n  'ecdhCurve',\r\n  'key',\r\n  'minDHSize',\r\n  'passphrase',\r\n  'pfx',\r\n  'rejectUnauthorized',\r\n  'secureContext',\r\n  'secureProtocol',\r\n  'servername',\r\n  'session'\r\n] as const;\r\n\r\n/** @public */\r\nexport const LEGAL_TCP_SOCKET_OPTIONS = [\r\n  'family',\r\n  'hints',\r\n  'localAddress',\r\n  'localPort',\r\n  'lookup'\r\n] as const;\r\n\r\nfunction parseConnectOptions(options: ConnectionOptions): SocketConnectOpts {\r\n  const hostAddress = options.hostAddress;\r\n  if (!hostAddress) throw new MongoInvalidArgumentError('Option \"hostAddress\" is required');\r\n\r\n  const result: Partial<net.TcpNetConnectOpts & net.IpcNetConnectOpts> = {};\r\n  for (const name of LEGAL_TCP_SOCKET_OPTIONS) {\r\n    if (options[name] != null) {\r\n      (result as Document)[name] = options[name];\r\n    }\r\n  }\r\n\r\n  if (typeof hostAddress.socketPath === 'string') {\r\n    result.path = hostAddress.socketPath;\r\n    return result as net.IpcNetConnectOpts;\r\n  } else if (typeof hostAddress.host === 'string') {\r\n    result.host = hostAddress.host;\r\n    result.port = hostAddress.port;\r\n    return result as net.TcpNetConnectOpts;\r\n  } else {\r\n    // This should never happen since we set up HostAddresses\r\n    // But if we don't throw here the socket could hang until timeout\r\n    // TODO(NODE-3483)\r\n    throw new MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\r\n  }\r\n}\r\n\r\ntype MakeConnectionOptions = ConnectionOptions & { existingSocket?: Stream };\r\n\r\nfunction parseSslOptions(options: MakeConnectionOptions): TLSConnectionOpts {\r\n  const result: TLSConnectionOpts = parseConnectOptions(options);\r\n  // Merge in valid SSL options\r\n  for (const name of LEGAL_TLS_SOCKET_OPTIONS) {\r\n    if (options[name] != null) {\r\n      (result as Document)[name] = options[name];\r\n    }\r\n  }\r\n\r\n  if (options.existingSocket) {\r\n    result.socket = options.existingSocket;\r\n  }\r\n\r\n  // Set default sni servername to be the same as host\r\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\r\n    result.servername = result.host;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'] as const;\r\ntype ErrorHandlerEventName = typeof SOCKET_ERROR_EVENT_LIST[number] | 'cancel';\r\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\r\n\r\nfunction makeConnection(options: MakeConnectionOptions, _callback: Callback<Stream>) {\r\n  const useTLS = options.tls ?? false;\r\n  const keepAlive = options.keepAlive ?? true;\r\n  const socketTimeoutMS = options.socketTimeoutMS ?? Reflect.get(options, 'socketTimeout') ?? 0;\r\n  const noDelay = options.noDelay ?? true;\r\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\r\n  const rejectUnauthorized = options.rejectUnauthorized ?? true;\r\n  const keepAliveInitialDelay =\r\n    ((options.keepAliveInitialDelay ?? 120000) > socketTimeoutMS\r\n      ? Math.round(socketTimeoutMS / 2)\r\n      : options.keepAliveInitialDelay) ?? 120000;\r\n  const existingSocket = options.existingSocket;\r\n\r\n  let socket: Stream;\r\n  const callback: Callback<Stream> = function (err, ret) {\r\n    if (err && socket) {\r\n      socket.destroy();\r\n    }\r\n\r\n    _callback(err, ret);\r\n  };\r\n\r\n  if (options.proxyHost != null) {\r\n    // Currently, only Socks5 is supported.\r\n    return makeSocks5Connection(\r\n      {\r\n        ...options,\r\n        connectTimeoutMS // Should always be present for Socks5\r\n      },\r\n      callback\r\n    );\r\n  }\r\n\r\n  if (useTLS) {\r\n    const tlsSocket = tls.connect(parseSslOptions(options));\r\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\r\n      tlsSocket.disableRenegotiation();\r\n    }\r\n    socket = tlsSocket;\r\n  } else if (existingSocket) {\r\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\r\n    // so we only need to handle the non-TLS case here (where existingSocket\r\n    // gives us all we need out of the box).\r\n    socket = existingSocket;\r\n  } else {\r\n    socket = net.createConnection(parseConnectOptions(options));\r\n  }\r\n\r\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\r\n  socket.setTimeout(connectTimeoutMS);\r\n  socket.setNoDelay(noDelay);\r\n\r\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\r\n  let cancellationHandler: (err: Error) => void;\r\n  function errorHandler(eventName: ErrorHandlerEventName) {\r\n    return (err: Error) => {\r\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\r\n      if (cancellationHandler && options.cancellationToken) {\r\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\r\n      }\r\n\r\n      socket.removeListener(connectEvent, connectHandler);\r\n      callback(connectionFailureError(eventName, err));\r\n    };\r\n  }\r\n\r\n  function connectHandler() {\r\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\r\n    if (cancellationHandler && options.cancellationToken) {\r\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\r\n    }\r\n\r\n    if ('authorizationError' in socket) {\r\n      if (socket.authorizationError && rejectUnauthorized) {\r\n        return callback(socket.authorizationError);\r\n      }\r\n    }\r\n\r\n    socket.setTimeout(socketTimeoutMS);\r\n    callback(undefined, socket);\r\n  }\r\n\r\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\r\n  if (options.cancellationToken) {\r\n    cancellationHandler = errorHandler('cancel');\r\n    options.cancellationToken.once('cancel', cancellationHandler);\r\n  }\r\n\r\n  if (existingSocket) {\r\n    process.nextTick(connectHandler);\r\n  } else {\r\n    socket.once(connectEvent, connectHandler);\r\n  }\r\n}\r\n\r\nfunction makeSocks5Connection(options: MakeConnectionOptions, callback: Callback<Stream>) {\r\n  const hostAddress = HostAddress.fromHostPort(\r\n    options.proxyHost ?? '', // proxyHost is guaranteed to set here\r\n    options.proxyPort ?? 1080\r\n  );\r\n\r\n  // First, connect to the proxy server itself:\r\n  makeConnection(\r\n    {\r\n      ...options,\r\n      hostAddress,\r\n      tls: false,\r\n      proxyHost: undefined\r\n    },\r\n    (err, rawSocket) => {\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n\r\n      const destination = parseConnectOptions(options) as net.TcpNetConnectOpts;\r\n      if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\r\n        return callback(\r\n          new MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts')\r\n        );\r\n      }\r\n\r\n      // Then, establish the Socks5 proxy connection:\r\n      SocksClient.createConnection(\r\n        {\r\n          existing_socket: rawSocket,\r\n          timeout: options.connectTimeoutMS,\r\n          command: 'connect',\r\n          destination: {\r\n            host: destination.host,\r\n            port: destination.port\r\n          },\r\n          proxy: {\r\n            // host and port are ignored because we pass existing_socket\r\n            host: 'iLoveJavaScript',\r\n            port: 0,\r\n            type: 5,\r\n            userId: options.proxyUsername || undefined,\r\n            password: options.proxyPassword || undefined\r\n          }\r\n        },\r\n        (err: AnyError, info: { socket: Stream }) => {\r\n          if (err) {\r\n            return callback(connectionFailureError('error', err));\r\n          }\r\n\r\n          // Finally, now treat the resulting duplex stream as the\r\n          // socket over which we send and receive wire protocol messages:\r\n          makeConnection(\r\n            {\r\n              ...options,\r\n              existingSocket: info.socket,\r\n              proxyHost: undefined\r\n            },\r\n            callback\r\n          );\r\n        }\r\n      );\r\n    }\r\n  );\r\n}\r\n\r\nfunction connectionFailureError(type: ErrorHandlerEventName, err: Error) {\r\n  switch (type) {\r\n    case 'error':\r\n      return new MongoNetworkError(err);\r\n    case 'timeout':\r\n      return new MongoNetworkTimeoutError('connection timed out');\r\n    case 'close':\r\n      return new MongoNetworkError('connection closed');\r\n    case 'cancel':\r\n      return new MongoNetworkError('connection establishment was cancelled');\r\n    default:\r\n      return new MongoNetworkError('unknown network error');\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}