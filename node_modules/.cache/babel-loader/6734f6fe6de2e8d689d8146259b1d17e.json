{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Explain = exports.ExplainVerbosity = void 0;\n\nconst error_1 = require(\"./error\");\n/** @public */\n\n\nexports.ExplainVerbosity = Object.freeze({\n  queryPlanner: 'queryPlanner',\n  queryPlannerExtended: 'queryPlannerExtended',\n  executionStats: 'executionStats',\n  allPlansExecution: 'allPlansExecution'\n});\n/** @internal */\n\nclass Explain {\n  constructor(verbosity) {\n    if (typeof verbosity === 'boolean') {\n      this.verbosity = verbosity ? exports.ExplainVerbosity.allPlansExecution : exports.ExplainVerbosity.queryPlanner;\n    } else {\n      this.verbosity = verbosity;\n    }\n  }\n\n  static fromOptions(options) {\n    if ((options === null || options === void 0 ? void 0 : options.explain) == null) return;\n    const explain = options.explain;\n\n    if (typeof explain === 'boolean' || typeof explain === 'string') {\n      return new Explain(explain);\n    }\n\n    throw new error_1.MongoInvalidArgumentError('Field \"explain\" must be a string or a boolean');\n  }\n\n}\n\nexports.Explain = Explain;","map":{"version":3,"mappings":";;;;;;;AAAA;AAEA;;;AACaA,2BAAmBC,MAAM,CAACC,MAAP,CAAc;AAC5CC,cAAY,EAAE,cAD8B;AAE5CC,sBAAoB,EAAE,sBAFsB;AAG5CC,gBAAc,EAAE,gBAH4B;AAI5CC,mBAAiB,EAAE;AAJyB,CAAd,CAAnB;AAwBb;;AACA,MAAaC,OAAb,CAAoB;AAGlBC,cAAYC,SAAZ,EAA2C;AACzC,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EAAoC;AAClC,WAAKA,SAAL,GAAiBA,SAAS,GACtBT,yBAAiBM,iBADK,GAEtBN,yBAAiBG,YAFrB;AAGD,KAJD,MAIO;AACL,WAAKM,SAAL,GAAiBA,SAAjB;AACD;AACF;;AAEiB,SAAXC,WAAW,CAACC,OAAD,EAAyB;AACzC,QAAI,QAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEC,OAAT,KAAoB,IAAxB,EAA8B;AAE9B,UAAMA,OAAO,GAAGD,OAAO,CAACC,OAAxB;;AACA,QAAI,OAAOA,OAAP,KAAmB,SAAnB,IAAgC,OAAOA,OAAP,KAAmB,QAAvD,EAAiE;AAC/D,aAAO,IAAIL,OAAJ,CAAYK,OAAZ,CAAP;AACD;;AAED,UAAM,IAAIC,iCAAJ,CAA8B,+CAA9B,CAAN;AACD;;AAtBiB;;AAApBb","names":["exports","Object","freeze","queryPlanner","queryPlannerExtended","executionStats","allPlansExecution","Explain","constructor","verbosity","fromOptions","options","explain","error_1"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\explain.ts"],"sourcesContent":["import { MongoInvalidArgumentError } from './error';\n\n/** @public */\nexport const ExplainVerbosity = Object.freeze({\n  queryPlanner: 'queryPlanner',\n  queryPlannerExtended: 'queryPlannerExtended',\n  executionStats: 'executionStats',\n  allPlansExecution: 'allPlansExecution'\n} as const);\n\n/** @public */\nexport type ExplainVerbosity = string;\n\n/**\n * For backwards compatibility, true is interpreted as \"allPlansExecution\"\n * and false as \"queryPlanner\". Prior to server version 3.6, aggregate()\n * ignores the verbosity parameter and executes in \"queryPlanner\".\n * @public\n */\nexport type ExplainVerbosityLike = ExplainVerbosity | boolean;\n\n/** @public */\nexport interface ExplainOptions {\n  /** Specifies the verbosity mode for the explain output. */\n  explain?: ExplainVerbosityLike;\n}\n\n/** @internal */\nexport class Explain {\n  verbosity: ExplainVerbosity;\n\n  constructor(verbosity: ExplainVerbosityLike) {\n    if (typeof verbosity === 'boolean') {\n      this.verbosity = verbosity\n        ? ExplainVerbosity.allPlansExecution\n        : ExplainVerbosity.queryPlanner;\n    } else {\n      this.verbosity = verbosity;\n    }\n  }\n\n  static fromOptions(options?: ExplainOptions): Explain | undefined {\n    if (options?.explain == null) return;\n\n    const explain = options.explain;\n    if (typeof explain === 'boolean' || typeof explain === 'string') {\n      return new Explain(explain);\n    }\n\n    throw new MongoInvalidArgumentError('Field \"explain\" must be a string or a boolean');\n  }\n}\n"]},"metadata":{},"sourceType":"script"}