{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nexports.DB_AGGREGATE_COLLECTION = 1;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;\n/** @internal */\n\nclass AggregateOperation extends command_1.CommandOperation {\n  constructor(ns, pipeline, options) {\n    super(undefined, { ...options,\n      dbName: ns.db\n    });\n    this.options = options !== null && options !== void 0 ? options : {}; // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n\n    this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;\n    this.pipeline = pipeline; // determine if we have a write stage, override read preference if so\n\n    this.hasWriteStage = false;\n\n    if (typeof (options === null || options === void 0 ? void 0 : options.out) === 'string') {\n      this.pipeline = this.pipeline.concat({\n        $out: options.out\n      });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n\n    if (this.hasWriteStage) {\n      this.trySecondaryWrite = true;\n    }\n\n    if (this.explain && this.writeConcern) {\n      throw new error_1.MongoInvalidArgumentError('Option \"explain\" cannot be used on an aggregate call with writeConcern');\n    }\n\n    if ((options === null || options === void 0 ? void 0 : options.cursor) != null && typeof options.cursor !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');\n    }\n  }\n\n  get canRetryRead() {\n    return !this.hasWriteStage;\n  }\n\n  addToPipeline(stage) {\n    this.pipeline.push(stage);\n  }\n\n  execute(server, session, callback) {\n    const options = this.options;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const command = {\n      aggregate: this.target,\n      pipeline: this.pipeline\n    };\n\n    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n      this.readConcern = undefined;\n    }\n\n    if (serverWireVersion >= 5) {\n      if (this.hasWriteStage && this.writeConcern) {\n        Object.assign(command, {\n          writeConcern: this.writeConcern\n        });\n      }\n    }\n\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n\n    if (options.let) {\n      command.let = options.let;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    command.cursor = options.cursor || {};\n\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.AggregateOperation = AggregateOperation;\n(0, operation_1.defineAspects)(AggregateOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);","map":{"version":3,"mappings":"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","names":["exports","MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT","AggregateOperation","command_1","constructor","ns","pipeline","options","undefined","dbName","db","target","collection","hasWriteStage","out","concat","$out","length","finalStage","$merge","trySecondaryWrite","explain","writeConcern","error_1","cursor","canRetryRead","addToPipeline","stage","push","execute","server","session","callback","serverWireVersion","command","aggregate","readConcern","Object","assign","bypassDocumentValidation","allowDiskUse","hint","let","comment","batchSize","executeCommand","operation_1","READ_OPERATION","RETRYABLE","EXPLAINABLE","CURSOR_CREATING"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\operations\\aggregate.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { MongoInvalidArgumentError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { Callback, maxWireVersion, MongoDBNamespace } from '../utils';\nimport { CollationOptions, CommandOperation, CommandOperationOptions } from './command';\nimport { Aspect, defineAspects, Hint } from './operation';\n\n/** @internal */\nexport const DB_AGGREGATE_COLLECTION = 1 as const;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8 as const;\n\n/** @public */\nexport interface AggregateOptions extends CommandOperationOptions {\n  /** allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \\>). */\n  allowDiskUse?: boolean;\n  /** The number of documents to return per batch. See [aggregation documentation](https://docs.mongodb.com/manual/reference/command/aggregate). */\n  batchSize?: number;\n  /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */\n  bypassDocumentValidation?: boolean;\n  /** Return the query as cursor, on 2.6 \\> it returns as a real cursor on pre 2.6 it returns as an emulated cursor. */\n  cursor?: Document;\n  /** specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point. */\n  maxTimeMS?: number;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. */\n  maxAwaitTimeMS?: number;\n  /** Specify collation. */\n  collation?: CollationOptions;\n  /** Add an index selection hint to an aggregation command */\n  hint?: Hint;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n\n  out?: string;\n}\n\n/** @internal */\nexport class AggregateOperation<T = Document> extends CommandOperation<T> {\n  override options: AggregateOptions;\n  target: string | typeof DB_AGGREGATE_COLLECTION;\n  pipeline: Document[];\n  hasWriteStage: boolean;\n\n  constructor(ns: MongoDBNamespace, pipeline: Document[], options?: AggregateOptions) {\n    super(undefined, { ...options, dbName: ns.db });\n\n    this.options = options ?? {};\n\n    // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n    this.target = ns.collection || DB_AGGREGATE_COLLECTION;\n\n    this.pipeline = pipeline;\n\n    // determine if we have a write stage, override read preference if so\n    this.hasWriteStage = false;\n    if (typeof options?.out === 'string') {\n      this.pipeline = this.pipeline.concat({ $out: options.out });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n\n    if (this.hasWriteStage) {\n      this.trySecondaryWrite = true;\n    }\n\n    if (this.explain && this.writeConcern) {\n      throw new MongoInvalidArgumentError(\n        'Option \"explain\" cannot be used on an aggregate call with writeConcern'\n      );\n    }\n\n    if (options?.cursor != null && typeof options.cursor !== 'object') {\n      throw new MongoInvalidArgumentError('Cursor options must be an object');\n    }\n  }\n\n  override get canRetryRead(): boolean {\n    return !this.hasWriteStage;\n  }\n\n  addToPipeline(stage: Document): void {\n    this.pipeline.push(stage);\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<T>\n  ): void {\n    const options: AggregateOptions = this.options;\n    const serverWireVersion = maxWireVersion(server);\n    const command: Document = { aggregate: this.target, pipeline: this.pipeline };\n\n    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n      this.readConcern = undefined;\n    }\n\n    if (serverWireVersion >= 5) {\n      if (this.hasWriteStage && this.writeConcern) {\n        Object.assign(command, { writeConcern: this.writeConcern });\n      }\n    }\n\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n\n    if (options.let) {\n      command.let = options.let;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    command.cursor = options.cursor || {};\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n}\n\ndefineAspects(AggregateOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.EXPLAINABLE,\n  Aspect.CURSOR_CREATING\n]);\n"]},"metadata":{},"sourceType":"script"}