{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregationCursor = void 0;\n\nconst aggregate_1 = require(\"../operations/aggregate\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst utils_1 = require(\"../utils\");\n\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\n\n\nconst kPipeline = Symbol('pipeline');\n/** @internal */\n\nconst kOptions = Symbol('options');\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\n\nclass AggregationCursor extends abstract_cursor_1.AbstractCursor {\n  /** @internal */\n  constructor(topology, namespace) {\n    let pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(topology, namespace, options);\n    this[kPipeline] = pipeline;\n    this[kOptions] = options;\n  }\n\n  get pipeline() {\n    return this[kPipeline];\n  }\n\n  clone() {\n    const clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);\n    delete clonedOptions.session;\n    return new AggregationCursor(this.topology, this.namespace, this[kPipeline], { ...clonedOptions\n    });\n  }\n\n  map(transform) {\n    return super.map(transform);\n  }\n  /** @internal */\n\n\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], { ...this[kOptions],\n      ...this.cursorOptions,\n      session\n    });\n    (0, execute_operation_1.executeOperation)(this, aggregateOperation, (err, response) => {\n      if (err || response == null) return callback(err); // TODO: NODE-2882\n\n      callback(undefined, {\n        server: aggregateOperation.server,\n        session,\n        response\n      });\n    });\n  }\n\n  explain(verbosity, callback) {\n    if (typeof verbosity === 'function') callback = verbosity, verbosity = true;\n    if (verbosity == null) verbosity = true;\n    return (0, execute_operation_1.executeOperation)(this, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], { ...this[kOptions],\n      ...this.cursorOptions,\n      explain: verbosity\n    }), callback);\n  }\n\n  group($group) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $group\n    });\n    return this;\n  }\n  /** Add a limit stage to the aggregation pipeline */\n\n\n  limit($limit) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $limit\n    });\n    return this;\n  }\n  /** Add a match stage to the aggregation pipeline */\n\n\n  match($match) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $match\n    });\n    return this;\n  }\n  /** Add an out stage to the aggregation pipeline */\n\n\n  out($out) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $out\n    });\n    return this;\n  }\n  /**\n   * Add a project stage to the aggregation pipeline\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n   * You should specify a parameterized type to have assertions on your final results.\n   *\n   * @example\n   * ```typescript\n   * // Best way\n   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * // Flexible way\n   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n   * ```\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling project,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n   *\n   * // or always use chaining and save the final cursor\n   *\n   * const cursor = coll.aggregate().project<{ a: string }>({\n   *   _id: 0,\n   *   a: { $convert: { input: '$a', to: 'string' }\n   * }});\n   * ```\n   */\n\n\n  project($project) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $project\n    });\n    return this;\n  }\n  /** Add a lookup stage to the aggregation pipeline */\n\n\n  lookup($lookup) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $lookup\n    });\n    return this;\n  }\n  /** Add a redact stage to the aggregation pipeline */\n\n\n  redact($redact) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $redact\n    });\n    return this;\n  }\n  /** Add a skip stage to the aggregation pipeline */\n\n\n  skip($skip) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $skip\n    });\n    return this;\n  }\n  /** Add a sort stage to the aggregation pipeline */\n\n\n  sort($sort) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $sort\n    });\n    return this;\n  }\n  /** Add a unwind stage to the aggregation pipeline */\n\n\n  unwind($unwind) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $unwind\n    });\n    return this;\n  } // deprecated methods\n\n  /** @deprecated Add a geoNear stage to the aggregation pipeline */\n\n\n  geoNear($geoNear) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kPipeline].push({\n      $geoNear\n    });\n    return this;\n  }\n\n}\n\nexports.AggregationCursor = AggregationCursor;","map":{"version":3,"mappings":"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","names":["kPipeline","Symbol","kOptions","AggregationCursor","abstract_cursor_1","constructor","topology","namespace","pipeline","options","clone","clonedOptions","session","map","transform","_initialize","callback","aggregateOperation","aggregate_1","cursorOptions","err","response","undefined","server","explain","verbosity","group","$group","push","limit","$limit","match","$match","out","$out","project","$project","lookup","$lookup","redact","$redact","skip","$skip","sort","$sort","unwind","$unwind","geoNear","$geoNear","exports"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\cursor\\aggregation_cursor.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { ExplainVerbosityLike } from '../explain';\nimport { AggregateOperation, AggregateOptions } from '../operations/aggregate';\nimport { executeOperation, ExecutionResult } from '../operations/execute_operation';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport type { Sort } from '../sort';\nimport type { Callback, MongoDBNamespace } from '../utils';\nimport { mergeOptions } from '../utils';\nimport type { AbstractCursorOptions } from './abstract_cursor';\nimport { AbstractCursor, assertUninitialized } from './abstract_cursor';\n\n/** @public */\nexport interface AggregationCursorOptions extends AbstractCursorOptions, AggregateOptions {}\n\n/** @internal */\nconst kPipeline = Symbol('pipeline');\n/** @internal */\nconst kOptions = Symbol('options');\n\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\nexport class AggregationCursor<TSchema = any> extends AbstractCursor<TSchema> {\n  /** @internal */\n  [kPipeline]: Document[];\n  /** @internal */\n  [kOptions]: AggregateOptions;\n\n  /** @internal */\n  constructor(\n    topology: Topology,\n    namespace: MongoDBNamespace,\n    pipeline: Document[] = [],\n    options: AggregateOptions = {}\n  ) {\n    super(topology, namespace, options);\n\n    this[kPipeline] = pipeline;\n    this[kOptions] = options;\n  }\n\n  get pipeline(): Document[] {\n    return this[kPipeline];\n  }\n\n  clone(): AggregationCursor<TSchema> {\n    const clonedOptions = mergeOptions({}, this[kOptions]);\n    delete clonedOptions.session;\n    return new AggregationCursor(this.topology, this.namespace, this[kPipeline], {\n      ...clonedOptions\n    });\n  }\n\n  override map<T>(transform: (doc: TSchema) => T): AggregationCursor<T> {\n    return super.map(transform) as AggregationCursor<T>;\n  }\n\n  /** @internal */\n  _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void {\n    const aggregateOperation = new AggregateOperation(this.namespace, this[kPipeline], {\n      ...this[kOptions],\n      ...this.cursorOptions,\n      session\n    });\n\n    executeOperation(this, aggregateOperation, (err, response) => {\n      if (err || response == null) return callback(err);\n\n      // TODO: NODE-2882\n      callback(undefined, { server: aggregateOperation.server, session, response });\n    });\n  }\n\n  /** Execute the explain for the cursor */\n  explain(): Promise<Document>;\n  explain(callback: Callback): void;\n  explain(verbosity: ExplainVerbosityLike): Promise<Document>;\n  explain(\n    verbosity?: ExplainVerbosityLike | Callback,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof verbosity === 'function') (callback = verbosity), (verbosity = true);\n    if (verbosity == null) verbosity = true;\n\n    return executeOperation(\n      this,\n      new AggregateOperation(this.namespace, this[kPipeline], {\n        ...this[kOptions], // NOTE: order matters here, we may need to refine this\n        ...this.cursorOptions,\n        explain: verbosity\n      }),\n      callback\n    );\n  }\n\n  /** Add a group stage to the aggregation pipeline */\n  group<T = TSchema>($group: Document): AggregationCursor<T>;\n  group($group: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $group });\n    return this;\n  }\n\n  /** Add a limit stage to the aggregation pipeline */\n  limit($limit: number): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $limit });\n    return this;\n  }\n\n  /** Add a match stage to the aggregation pipeline */\n  match($match: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $match });\n    return this;\n  }\n\n  /** Add an out stage to the aggregation pipeline */\n  out($out: { db: string; coll: string } | string): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $out });\n    return this;\n  }\n\n  /**\n   * Add a project stage to the aggregation pipeline\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n   * You should specify a parameterized type to have assertions on your final results.\n   *\n   * @example\n   * ```typescript\n   * // Best way\n   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * // Flexible way\n   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n   * ```\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling project,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n   *\n   * // or always use chaining and save the final cursor\n   *\n   * const cursor = coll.aggregate().project<{ a: string }>({\n   *   _id: 0,\n   *   a: { $convert: { input: '$a', to: 'string' }\n   * }});\n   * ```\n   */\n  project<T extends Document = Document>($project: Document): AggregationCursor<T> {\n    assertUninitialized(this);\n    this[kPipeline].push({ $project });\n    return this as unknown as AggregationCursor<T>;\n  }\n\n  /** Add a lookup stage to the aggregation pipeline */\n  lookup($lookup: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $lookup });\n    return this;\n  }\n\n  /** Add a redact stage to the aggregation pipeline */\n  redact($redact: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $redact });\n    return this;\n  }\n\n  /** Add a skip stage to the aggregation pipeline */\n  skip($skip: number): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $skip });\n    return this;\n  }\n\n  /** Add a sort stage to the aggregation pipeline */\n  sort($sort: Sort): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $sort });\n    return this;\n  }\n\n  /** Add a unwind stage to the aggregation pipeline */\n  unwind($unwind: Document | string): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $unwind });\n    return this;\n  }\n\n  // deprecated methods\n  /** @deprecated Add a geoNear stage to the aggregation pipeline */\n  geoNear($geoNear: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $geoNear });\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}