{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSharded = exports.applyCommonQueryOptions = exports.getReadPreference = void 0;\n\nconst error_1 = require(\"../../error\");\n\nconst read_preference_1 = require(\"../../read_preference\");\n\nconst common_1 = require(\"../../sdam/common\");\n\nconst topology_description_1 = require(\"../../sdam/topology_description\");\n\nfunction getReadPreference(cmd, options) {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary; // If we have an option readPreference override the command one\n\n  if (options === null || options === void 0 ? void 0 : options.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n    throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n  }\n\n  return readPreference;\n}\n\nexports.getReadPreference = getReadPreference;\n\nfunction applyCommonQueryOptions(queryOptions, options) {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true\n  });\n\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n\n  return queryOptions;\n}\n\nexports.applyCommonQueryOptions = applyCommonQueryOptions;\n\nfunction isSharded(topologyOrServer) {\n  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n    return true;\n  } // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n\n\n  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n    const servers = Array.from(topologyOrServer.description.servers.values());\n    return servers.some(server => server.type === common_1.ServerType.Mongos);\n  }\n\n  return false;\n}\n\nexports.isSharded = isSharded;","map":{"version":3,"mappings":";;;;;;;AACA;;AAEA;;AACA;;AAIA;;AAQA,SAAgBA,iBAAhB,CAAkCC,GAAlC,EAAiDC,OAAjD,EAA+E;AAC7E;AACA,MAAIC,cAAc,GAAGF,GAAG,CAACE,cAAJ,IAAsBC,iCAAeC,OAA1D,CAF6E,CAG7E;;AACA,MAAIH,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEC,cAAb,EAA6B;AAC3BA,kBAAc,GAAGD,OAAO,CAACC,cAAzB;AACD;;AAED,MAAI,OAAOA,cAAP,KAA0B,QAA9B,EAAwC;AACtCA,kBAAc,GAAGC,iCAAeE,UAAf,CAA0BH,cAA1B,CAAjB;AACD;;AAED,MAAI,EAAEA,cAAc,YAAYC,gCAA5B,CAAJ,EAAiD;AAC/C,UAAM,IAAIG,iCAAJ,CACJ,2DADI,CAAN;AAGD;;AAED,SAAOJ,cAAP;AACD;;AAnBDK;;AAqBA,SAAgBC,uBAAhB,CACEC,YADF,EAEER,OAFF,EAEyB;AAEvBS,QAAM,CAACC,MAAP,CAAcF,YAAd,EAA4B;AAC1BG,OAAG,EAAE,OAAOX,OAAO,CAACW,GAAf,KAAuB,SAAvB,GAAmCX,OAAO,CAACW,GAA3C,GAAiD,KAD5B;AAE1BC,gBAAY,EAAE,OAAOZ,OAAO,CAACY,YAAf,KAAgC,SAAhC,GAA4CZ,OAAO,CAACY,YAApD,GAAmE,IAFvD;AAG1BC,iBAAa,EAAE,OAAOb,OAAO,CAACa,aAAf,KAAiC,SAAjC,GAA6Cb,OAAO,CAACa,aAArD,GAAqE,IAH1D;AAI1BC,kBAAc,EAAE,OAAOd,OAAO,CAACc,cAAf,KAAkC,SAAlC,GAA8Cd,OAAO,CAACc,cAAtD,GAAuE,KAJ7D;AAK1BC,cAAU,EAAE,OAAOf,OAAO,CAACe,UAAf,KAA8B,SAA9B,GAA0Cf,OAAO,CAACe,UAAlD,GAA+D,KALjD;AAM1BC,wBAAoB,EAClB,OAAOhB,OAAO,CAACgB,oBAAf,KAAwC,SAAxC,GAAoDhB,OAAO,CAACgB,oBAA5D,GAAmF;AAP3D,GAA5B;;AAUA,MAAIhB,OAAO,CAACiB,OAAZ,EAAqB;AACnBT,gBAAY,CAACS,OAAb,GAAuBjB,OAAO,CAACiB,OAA/B;AACD;;AAED,SAAOT,YAAP;AACD;;AAnBDF;;AAqBA,SAAgBY,SAAhB,CAA0BC,gBAA1B,EAA0E;AACxE,MAAIA,gBAAgB,CAACC,WAAjB,IAAgCD,gBAAgB,CAACC,WAAjB,CAA6BC,IAA7B,KAAsCC,oBAAWC,MAArF,EAA6F;AAC3F,WAAO,IAAP;AACD,GAHuE,CAKxE;AACA;;;AACA,MAAIJ,gBAAgB,CAACC,WAAjB,IAAgCD,gBAAgB,CAACC,WAAjB,YAAwCI,0CAA5E,EAAiG;AAC/F,UAAMC,OAAO,GAAwBC,KAAK,CAACC,IAAN,CAAWR,gBAAgB,CAACC,WAAjB,CAA6BK,OAA7B,CAAqCG,MAArC,EAAX,CAArC;AACA,WAAOH,OAAO,CAACI,IAAR,CAAcC,MAAD,IAA+BA,MAAM,CAACT,IAAP,KAAgBC,oBAAWC,MAAvE,CAAP;AACD;;AAED,SAAO,KAAP;AACD;;AAbDjB","names":["getReadPreference","cmd","options","readPreference","read_preference_1","primary","fromString","error_1","exports","applyCommonQueryOptions","queryOptions","Object","assign","raw","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","enableUtf8Validation","session","isSharded","topologyOrServer","description","type","common_1","Mongos","topology_description_1","servers","Array","from","values","some","server"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\shared.ts"],"sourcesContent":["import type { Document } from '../../bson';\nimport { MongoInvalidArgumentError } from '../../error';\nimport type { ReadPreferenceLike } from '../../read_preference';\nimport { ReadPreference } from '../../read_preference';\nimport { ServerType } from '../../sdam/common';\nimport type { Server } from '../../sdam/server';\nimport type { ServerDescription } from '../../sdam/server_description';\nimport type { Topology } from '../../sdam/topology';\nimport { TopologyDescription } from '../../sdam/topology_description';\nimport type { OpQueryOptions } from '../commands';\nimport type { CommandOptions, Connection } from '../connection';\n\nexport interface ReadPreferenceOption {\n  readPreference?: ReadPreferenceLike;\n}\n\nexport function getReadPreference(cmd: Document, options?: ReadPreferenceOption): ReadPreference {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || ReadPreference.primary;\n  // If we have an option readPreference override the command one\n  if (options?.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof ReadPreference)) {\n    throw new MongoInvalidArgumentError(\n      'Option \"readPreference\" must be a ReadPreference instance'\n    );\n  }\n\n  return readPreference;\n}\n\nexport function applyCommonQueryOptions(\n  queryOptions: OpQueryOptions,\n  options: CommandOptions\n): CommandOptions {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation:\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true\n  });\n\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n\n  return queryOptions;\n}\n\nexport function isSharded(topologyOrServer: Topology | Server | Connection): boolean {\n  if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {\n    return true;\n  }\n\n  // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n  if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {\n    const servers: ServerDescription[] = Array.from(topologyOrServer.description.servers.values());\n    return servers.some((server: ServerDescription) => server.type === ServerType.Mongos);\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}