{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst server_selection_1 = require(\"../sdam/server_selection\");\n\nconst utils_1 = require(\"../utils\");\n\nconst operation_1 = require(\"./operation\");\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction executeOperation(topologyProvider, operation, callback) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  return (0, utils_1.maybePromise)(callback, callback => {\n    let topology;\n\n    try {\n      topology = (0, utils_1.getTopology)(topologyProvider);\n    } catch (error) {\n      return callback(error);\n    }\n\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, {}, err => {\n        if (err) return callback(err);\n        executeOperation(topologyProvider, operation, callback);\n      });\n    } // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n\n\n    let session = operation.session;\n    let owner;\n\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = topology.startSession({\n          owner,\n          explicit: false\n        });\n      } else if (session.hasEnded) {\n        return callback(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return callback(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else if (session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n    }\n\n    try {\n      executeWithServerSelection(topology, session, operation, (error, result) => {\n        if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n          return session.endSession(endSessionError => callback(endSessionError !== null && endSessionError !== void 0 ? endSessionError : error, result));\n        }\n\n        callback(error, result);\n      });\n    } catch (error) {\n      if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n        session.endSession();\n      }\n\n      throw error;\n    }\n  });\n}\n\nexports.executeOperation = executeOperation;\n\nfunction executeWithServerSelection(topology, session, operation, callback) {\n  var _a, _b;\n\n  const readPreference = (_a = operation.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n  const inTransaction = !!(session === null || session === void 0 ? void 0 : session.inTransaction());\n\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    return callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n  }\n\n  if ((session === null || session === void 0 ? void 0 : session.isPinned) && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  let selector;\n\n  if (operation.hasAspect(operation_1.Aspect.CURSOR_ITERATING)) {\n    // Get more operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)((_b = operation.server) === null || _b === void 0 ? void 0 : _b.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  const serverSelectionOptions = {\n    session\n  };\n\n  function retryOperation(originalError) {\n    const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n\n    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n      return callback(new error_1.MongoServerError({\n        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        originalError\n      }));\n    }\n\n    if (isWriteOperation && !originalError.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {\n      return callback(originalError);\n    }\n\n    if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n      return callback(originalError);\n    }\n\n    if (originalError instanceof error_1.MongoNetworkError && (session === null || session === void 0 ? void 0 : session.isPinned) && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n      // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n      session.unpin({\n        force: true,\n        forceClear: true\n      });\n    } // select a new server, and attempt to retry the operation\n\n\n    topology.selectServer(selector, serverSelectionOptions, (error, server) => {\n      if (!error && isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n        return callback(new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes'));\n      }\n\n      if (error || !server) {\n        return callback(error !== null && error !== void 0 ? error : new error_1.MongoUnexpectedServerResponseError('Server selection failed without error'));\n      }\n\n      operation.execute(server, session, callback);\n    });\n  }\n\n  if (readPreference && !readPreference.equals(read_preference_1.ReadPreference.primary) && (session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  } // select a server, and execute the operation against it\n\n\n  topology.selectServer(selector, serverSelectionOptions, (error, server) => {\n    if (error || !server) {\n      return callback(error);\n    }\n\n    if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n      const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n      const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n\n      if (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n\n        return operation.execute(server, session, (error, result) => {\n          if (error instanceof error_1.MongoError) {\n            return retryOperation(error);\n          } else if (error) {\n            return callback(error);\n          }\n\n          callback(undefined, result);\n        });\n      }\n    }\n\n    return operation.execute(server, session, callback);\n  });\n}","map":{"version":3,"mappings":"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","names":["MMAPv1_RETRY_WRITES_ERROR_CODE","error_1","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","executeOperation","topologyProvider","operation","callback","operation_1","topology","error","shouldCheckForSessionSupport","selectServer","read_preference_1","primaryPreferred","err","session","owner","hasSessionSupport","Symbol","startSession","explicit","hasEnded","snapshotEnabled","capabilities","supportsSnapshotReads","executeWithServerSelection","result","endSession","endSessionError","exports","readPreference","_a","primary","inTransaction","equals","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","selector","hasAspect","CURSOR_ITERATING","server","_b","description","trySecondaryWrite","commonWireVersion","serverSelectionOptions","retryOperation","originalError","isWriteOperation","WRITE_OPERATION","isReadOperation","READ_OPERATION","code","message","errmsg","hasErrorLabel","RetryableWriteError","CURSOR_CREATING","force","forceClear","execute","RETRYABLE","willRetryRead","s","options","retryReads","canRetryRead","willRetryWrite","retryWrites","canRetryWrite","hasReadAspect","hasWriteAspect","incrementTransactionNumber","undefined"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\operations\\execute_operation.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport {\r\n  isRetryableReadError,\r\n  MongoCompatibilityError,\r\n  MONGODB_ERROR_CODES,\r\n  MongoError,\r\n  MongoErrorLabel,\r\n  MongoExpiredSessionError,\r\n  MongoNetworkError,\r\n  MongoRuntimeError,\r\n  MongoServerError,\r\n  MongoTransactionError,\r\n  MongoUnexpectedServerResponseError\r\n} from '../error';\r\nimport { ReadPreference } from '../read_preference';\r\nimport type { Server } from '../sdam/server';\r\nimport {\r\n  sameServerSelector,\r\n  secondaryWritableServerSelector,\r\n  ServerSelector\r\n} from '../sdam/server_selection';\r\nimport type { Topology } from '../sdam/topology';\r\nimport type { ClientSession } from '../sessions';\r\nimport {\r\n  Callback,\r\n  getTopology,\r\n  maybePromise,\r\n  supportsRetryableWrites,\r\n  TopologyProvider\r\n} from '../utils';\r\nimport { AbstractOperation, Aspect } from './operation';\r\n\r\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\r\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\r\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\r\n\r\ntype ResultTypeFromOperation<TOperation> = TOperation extends AbstractOperation<infer K>\r\n  ? K\r\n  : never;\r\n\r\n/** @internal */\r\nexport interface ExecutionResult {\r\n  /** The server selected for the operation */\r\n  server: Server;\r\n  /** The session used for this operation, may be implicitly created */\r\n  session?: ClientSession;\r\n  /** The raw server response for the operation */\r\n  response: Document;\r\n}\r\n\r\n/**\r\n * Executes the given operation with provided arguments.\r\n * @internal\r\n *\r\n * @remarks\r\n * This method reduces large amounts of duplication in the entire codebase by providing\r\n * a single point for determining whether callbacks or promises should be used. Additionally\r\n * it allows for a single point of entry to provide features such as implicit sessions, which\r\n * are required by the Driver Sessions specification in the event that a ClientSession is\r\n * not provided\r\n *\r\n * @param topology - The topology to execute this operation on\r\n * @param operation - The operation to execute\r\n * @param callback - The command result callback\r\n */\r\nexport function executeOperation<\r\n  T extends AbstractOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(topologyProvider: TopologyProvider, operation: T): Promise<TResult>;\r\nexport function executeOperation<\r\n  T extends AbstractOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(topologyProvider: TopologyProvider, operation: T, callback: Callback<TResult>): void;\r\nexport function executeOperation<\r\n  T extends AbstractOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(\r\n  topologyProvider: TopologyProvider,\r\n  operation: T,\r\n  callback?: Callback<TResult>\r\n): Promise<TResult> | void;\r\nexport function executeOperation<\r\n  T extends AbstractOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(\r\n  topologyProvider: TopologyProvider,\r\n  operation: T,\r\n  callback?: Callback<TResult>\r\n): Promise<TResult> | void {\r\n  if (!(operation instanceof AbstractOperation)) {\r\n    // TODO(NODE-3483): Extend MongoRuntimeError\r\n    throw new MongoRuntimeError('This method requires a valid operation instance');\r\n  }\r\n\r\n  return maybePromise(callback, callback => {\r\n    let topology: Topology;\r\n    try {\r\n      topology = getTopology(topologyProvider);\r\n    } catch (error) {\r\n      return callback(error);\r\n    }\r\n    if (topology.shouldCheckForSessionSupport()) {\r\n      return topology.selectServer(ReadPreference.primaryPreferred, {}, err => {\r\n        if (err) return callback(err);\r\n\r\n        executeOperation<T, TResult>(topologyProvider, operation, callback);\r\n      });\r\n    }\r\n\r\n    // The driver sessions spec mandates that we implicitly create sessions for operations\r\n    // that are not explicitly provided with a session.\r\n    let session = operation.session;\r\n    let owner: symbol | undefined;\r\n    if (topology.hasSessionSupport()) {\r\n      if (session == null) {\r\n        owner = Symbol();\r\n        session = topology.startSession({ owner, explicit: false });\r\n      } else if (session.hasEnded) {\r\n        return callback(new MongoExpiredSessionError('Use of expired sessions is not permitted'));\r\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\r\n        return callback(new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\r\n      }\r\n    } else if (session) {\r\n      // If the user passed an explicit session and we are still, after server selection,\r\n      // trying to run against a topology that doesn't support sessions we error out.\r\n      return callback(new MongoCompatibilityError('Current topology does not support sessions'));\r\n    }\r\n\r\n    try {\r\n      executeWithServerSelection<TResult>(topology, session, operation, (error, result) => {\r\n        if (session?.owner != null && session.owner === owner) {\r\n          return session.endSession(endSessionError => callback(endSessionError ?? error, result));\r\n        }\r\n\r\n        callback(error, result);\r\n      });\r\n    } catch (error) {\r\n      if (session?.owner != null && session.owner === owner) {\r\n        session.endSession();\r\n      }\r\n      throw error;\r\n    }\r\n  });\r\n}\r\n\r\nfunction executeWithServerSelection<TResult>(\r\n  topology: Topology,\r\n  session: ClientSession | undefined,\r\n  operation: AbstractOperation,\r\n  callback: Callback<TResult>\r\n) {\r\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\r\n  const inTransaction = !!session?.inTransaction();\r\n\r\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\r\n    return callback(\r\n      new MongoTransactionError(\r\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\r\n      )\r\n    );\r\n  }\r\n\r\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\r\n    session.unpin();\r\n  }\r\n\r\n  let selector: ReadPreference | ServerSelector;\r\n\r\n  if (operation.hasAspect(Aspect.CURSOR_ITERATING)) {\r\n    // Get more operations must always select the same server, but run through\r\n    // server selection to potentially force monitor checks if the server is\r\n    // in an unknown state.\r\n    selector = sameServerSelector(operation.server?.description);\r\n  } else if (operation.trySecondaryWrite) {\r\n    // If operation should try to write to secondary use the custom server selector\r\n    // otherwise provide the read preference.\r\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\r\n  } else {\r\n    selector = readPreference;\r\n  }\r\n\r\n  const serverSelectionOptions = { session };\r\n  function retryOperation(originalError: MongoError) {\r\n    const isWriteOperation = operation.hasAspect(Aspect.WRITE_OPERATION);\r\n    const isReadOperation = operation.hasAspect(Aspect.READ_OPERATION);\r\n\r\n    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\r\n      return callback(\r\n        new MongoServerError({\r\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\r\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\r\n          originalError\r\n        })\r\n      );\r\n    }\r\n\r\n    if (isWriteOperation && !originalError.hasErrorLabel(MongoErrorLabel.RetryableWriteError)) {\r\n      return callback(originalError);\r\n    }\r\n\r\n    if (isReadOperation && !isRetryableReadError(originalError)) {\r\n      return callback(originalError);\r\n    }\r\n\r\n    if (\r\n      originalError instanceof MongoNetworkError &&\r\n      session?.isPinned &&\r\n      !session.inTransaction() &&\r\n      operation.hasAspect(Aspect.CURSOR_CREATING)\r\n    ) {\r\n      // If we have a cursor and the initial command fails with a network error,\r\n      // we can retry it on another connection. So we need to check it back in, clear the\r\n      // pool for the service id, and retry again.\r\n      session.unpin({ force: true, forceClear: true });\r\n    }\r\n\r\n    // select a new server, and attempt to retry the operation\r\n    topology.selectServer(selector, serverSelectionOptions, (error?: Error, server?: Server) => {\r\n      if (!error && isWriteOperation && !supportsRetryableWrites(server)) {\r\n        return callback(\r\n          new MongoUnexpectedServerResponseError(\r\n            'Selected server does not support retryable writes'\r\n          )\r\n        );\r\n      }\r\n\r\n      if (error || !server) {\r\n        return callback(\r\n          error ?? new MongoUnexpectedServerResponseError('Server selection failed without error')\r\n        );\r\n      }\r\n\r\n      operation.execute(server, session, callback);\r\n    });\r\n  }\r\n\r\n  if (\r\n    readPreference &&\r\n    !readPreference.equals(ReadPreference.primary) &&\r\n    session?.inTransaction()\r\n  ) {\r\n    callback(\r\n      new MongoTransactionError(\r\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\r\n      )\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  // select a server, and execute the operation against it\r\n  topology.selectServer(selector, serverSelectionOptions, (error, server) => {\r\n    if (error || !server) {\r\n      return callback(error);\r\n    }\r\n\r\n    if (session && operation.hasAspect(Aspect.RETRYABLE)) {\r\n      const willRetryRead =\r\n        topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\r\n\r\n      const willRetryWrite =\r\n        topology.s.options.retryWrites &&\r\n        !inTransaction &&\r\n        supportsRetryableWrites(server) &&\r\n        operation.canRetryWrite;\r\n\r\n      const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\r\n      const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\r\n\r\n      if ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite)) {\r\n        if (hasWriteAspect && willRetryWrite) {\r\n          operation.options.willRetryWrite = true;\r\n          session.incrementTransactionNumber();\r\n        }\r\n\r\n        return operation.execute(server, session, (error, result) => {\r\n          if (error instanceof MongoError) {\r\n            return retryOperation(error);\r\n          } else if (error) {\r\n            return callback(error);\r\n          }\r\n          callback(undefined, result);\r\n        });\r\n      }\r\n    }\r\n\r\n    return operation.execute(server, session, callback);\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"script"}