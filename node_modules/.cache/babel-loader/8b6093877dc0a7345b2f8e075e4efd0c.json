{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst write_concern_1 = require(\"../write_concern\");\n\nconst bulk_write_1 = require(\"./bulk_write\");\n\nconst command_1 = require(\"./command\");\n\nconst common_functions_1 = require(\"./common_functions\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nclass InsertOperation extends command_1.CommandOperation {\n  constructor(ns, documents, options) {\n    var _a;\n\n    super(undefined, options);\n    this.options = { ...options,\n      checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false\n    };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  execute(server, session, callback) {\n    var _a;\n\n    const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.InsertOperation = InsertOperation;\n\nclass InsertOneOperation extends InsertOperation {\n  constructor(collection, doc, options) {\n    super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, (err, res) => {\n      var _a, _b;\n\n      if (err || res == null) return callback(err);\n      if (res.code) return callback(new error_1.MongoServerError(res));\n\n      if (res.writeErrors) {\n        // This should be a WriteError but we can't change it now because of error hierarchy\n        return callback(new error_1.MongoServerError(res.writeErrors[0]));\n      }\n\n      callback(undefined, {\n        acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n        insertedId: this.documents[0]._id\n      });\n    });\n  }\n\n}\n\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\n\nclass InsertManyOperation extends operation_1.AbstractOperation {\n  constructor(collection, docs, options) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = { ...this.options,\n      ...this.bsonOptions,\n      readPreference: this.readPreference\n    };\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(document => ({\n      insertOne: {\n        document\n      }\n    })), options);\n    bulkWriteOperation.execute(server, session, (err, res) => {\n      var _a;\n\n      if (err || res == null) return callback(err);\n      callback(undefined, {\n        acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      });\n    });\n  }\n\n}\n\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":"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","names":["InsertOperation","command_1","constructor","ns","documents","options","undefined","checkKeys","_a","execute","server","session","callback","ordered","command","insert","collection","bypassDocumentValidation","comment","executeCommand","exports","InsertOneOperation","doc","s","namespace","err","res","code","error_1","writeErrors","acknowledged","writeConcern","w","_b","insertedId","_id","InsertManyOperation","operation_1","docs","Array","isArray","coll","bsonOptions","readPreference","write_concern_1","fromOptions","bulkWriteOperation","bulk_write_1","map","document","insertOne","insertedCount","insertedIds","RETRYABLE","WRITE_OPERATION"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\operations\\insert.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport type { BulkWriteOptions } from '../bulk/common';\r\nimport type { Collection } from '../collection';\r\nimport { MongoInvalidArgumentError, MongoServerError } from '../error';\r\nimport type { InferIdType } from '../mongo_types';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport type { Callback, MongoDBNamespace } from '../utils';\r\nimport { WriteConcern } from '../write_concern';\r\nimport { BulkWriteOperation } from './bulk_write';\r\nimport { CommandOperation, CommandOperationOptions } from './command';\r\nimport { prepareDocs } from './common_functions';\r\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\r\n\r\n/** @internal */\r\nexport class InsertOperation extends CommandOperation<Document> {\r\n  override options: BulkWriteOptions;\r\n  documents: Document[];\r\n\r\n  constructor(ns: MongoDBNamespace, documents: Document[], options: BulkWriteOptions) {\r\n    super(undefined, options);\r\n    this.options = { ...options, checkKeys: options.checkKeys ?? false };\r\n    this.ns = ns;\r\n    this.documents = documents;\r\n  }\r\n\r\n  override execute(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<Document>\r\n  ): void {\r\n    const options = this.options ?? {};\r\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\r\n    const command: Document = {\r\n      insert: this.ns.collection,\r\n      documents: this.documents,\r\n      ordered\r\n    };\r\n\r\n    if (typeof options.bypassDocumentValidation === 'boolean') {\r\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\r\n    }\r\n\r\n    // we check for undefined specifically here to allow falsy values\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    if (options.comment !== undefined) {\r\n      command.comment = options.comment;\r\n    }\r\n\r\n    super.executeCommand(server, session, command, callback);\r\n  }\r\n}\r\n\r\n/** @public */\r\nexport interface InsertOneOptions extends CommandOperationOptions {\r\n  /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */\r\n  bypassDocumentValidation?: boolean;\r\n  /** Force server to assign _id values instead of driver. */\r\n  forceServerObjectId?: boolean;\r\n}\r\n\r\n/** @public */\r\nexport interface InsertOneResult<TSchema = Document> {\r\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\r\n  acknowledged: boolean;\r\n  /** The identifier that was inserted. If the server generated the identifier, this value will be null as the driver does not have access to that data */\r\n  insertedId: InferIdType<TSchema>;\r\n}\r\n\r\nexport class InsertOneOperation extends InsertOperation {\r\n  constructor(collection: Collection, doc: Document, options: InsertOneOptions) {\r\n    super(collection.s.namespace, prepareDocs(collection, [doc], options), options);\r\n  }\r\n\r\n  override execute(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<InsertOneResult>\r\n  ): void {\r\n    super.execute(server, session, (err, res) => {\r\n      if (err || res == null) return callback(err);\r\n      if (res.code) return callback(new MongoServerError(res));\r\n      if (res.writeErrors) {\r\n        // This should be a WriteError but we can't change it now because of error hierarchy\r\n        return callback(new MongoServerError(res.writeErrors[0]));\r\n      }\r\n\r\n      callback(undefined, {\r\n        acknowledged: this.writeConcern?.w !== 0 ?? true,\r\n        insertedId: this.documents[0]._id\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\n/** @public */\r\nexport interface InsertManyResult<TSchema = Document> {\r\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\r\n  acknowledged: boolean;\r\n  /** The number of inserted documents for this operations */\r\n  insertedCount: number;\r\n  /** Map of the index of the inserted document to the id of the inserted document */\r\n  insertedIds: { [key: number]: InferIdType<TSchema> };\r\n}\r\n\r\n/** @internal */\r\nexport class InsertManyOperation extends AbstractOperation<InsertManyResult> {\r\n  override options: BulkWriteOptions;\r\n  collection: Collection;\r\n  docs: Document[];\r\n\r\n  constructor(collection: Collection, docs: Document[], options: BulkWriteOptions) {\r\n    super(options);\r\n\r\n    if (!Array.isArray(docs)) {\r\n      throw new MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\r\n    }\r\n\r\n    this.options = options;\r\n    this.collection = collection;\r\n    this.docs = docs;\r\n  }\r\n\r\n  override execute(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<InsertManyResult>\r\n  ): void {\r\n    const coll = this.collection;\r\n    const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };\r\n    const writeConcern = WriteConcern.fromOptions(options);\r\n    const bulkWriteOperation = new BulkWriteOperation(\r\n      coll,\r\n      prepareDocs(coll, this.docs, options).map(document => ({ insertOne: { document } })),\r\n      options\r\n    );\r\n\r\n    bulkWriteOperation.execute(server, session, (err, res) => {\r\n      if (err || res == null) return callback(err);\r\n      callback(undefined, {\r\n        acknowledged: writeConcern?.w !== 0 ?? true,\r\n        insertedCount: res.insertedCount,\r\n        insertedIds: res.insertedIds\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\ndefineAspects(InsertOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\r\ndefineAspects(InsertOneOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\r\ndefineAspects(InsertManyOperation, [Aspect.WRITE_OPERATION]);\r\n"]},"metadata":{},"sourceType":"script"}