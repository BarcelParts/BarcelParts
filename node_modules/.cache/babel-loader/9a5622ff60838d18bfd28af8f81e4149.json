{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.connect = void 0;\n\nconst connection_string_1 = require(\"../connection_string\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst topology_1 = require(\"../sdam/topology\");\n\nfunction connect(mongoClient, options, callback) {\n  if (!callback) {\n    throw new error_1.MongoInvalidArgumentError('Callback function must be provided');\n  } // If a connection already been established, we can terminate early\n\n\n  if (mongoClient.topology && mongoClient.topology.isConnected()) {\n    return callback(undefined, mongoClient);\n  }\n\n  const logger = mongoClient.logger;\n\n  const connectCallback = err => {\n    const warningMessage = 'seed list contains no mongos proxies, replicaset connections requires ' + 'the parameter replicaSet to be supplied in the URI or options object, ' + 'mongodb://server:port/db?replicaSet=name';\n\n    if (err && err.message === 'no mongos proxies found in seed list') {\n      if (logger.isWarn()) {\n        logger.warn(warningMessage);\n      } // Return a more specific error message for MongoClient.connect\n      // TODO(NODE-3483)\n\n\n      return callback(new error_1.MongoRuntimeError(warningMessage));\n    }\n\n    callback(err, mongoClient);\n  };\n\n  if (typeof options.srvHost === 'string') {\n    return (0, connection_string_1.resolveSRVRecord)(options, (err, hosts) => {\n      if (err || !hosts) return callback(err);\n\n      for (const [index, host] of hosts.entries()) {\n        options.hosts[index] = host;\n      }\n\n      return createTopology(mongoClient, options, connectCallback);\n    });\n  }\n\n  return createTopology(mongoClient, options, connectCallback);\n}\n\nexports.connect = connect;\n\nfunction createTopology(mongoClient, options, callback) {\n  // Create the topology\n  const topology = new topology_1.Topology(options.hosts, options); // Events can be emitted before initialization is complete so we have to\n  // save the reference to the topology on the client ASAP if the event handlers need to access it\n\n  mongoClient.topology = topology;\n  topology.once(topology_1.Topology.OPEN, () => mongoClient.emit('open', mongoClient));\n\n  for (const event of constants_1.MONGO_CLIENT_EVENTS) {\n    topology.on(event, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return mongoClient.emit(event, ...args);\n    });\n  } // initialize CSFLE if requested\n\n\n  if (mongoClient.autoEncrypter) {\n    mongoClient.autoEncrypter.init(err => {\n      if (err) {\n        return callback(err);\n      }\n\n      topology.connect(options, err => {\n        if (err) {\n          topology.close({\n            force: true\n          });\n          return callback(err);\n        }\n\n        options.encrypter.connectInternalClient(error => {\n          if (error) return callback(error);\n          callback(undefined, topology);\n        });\n      });\n    });\n    return;\n  } // otherwise connect normally\n\n\n  topology.connect(options, err => {\n    if (err) {\n      topology.close({\n        force: true\n      });\n      return callback(err);\n    }\n\n    callback(undefined, topology);\n    return;\n  });\n}","map":{"version":3,"mappings":"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","names":["connect","mongoClient","options","callback","error_1","topology","isConnected","undefined","logger","connectCallback","err","warningMessage","message","isWarn","warn","srvHost","hosts","index","host","entries","createTopology","exports","topology_1","once","OPEN","emit","event","constants_1","on","args","autoEncrypter","init","close","force","encrypter","connectInternalClient","error"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\operations\\connect.ts"],"sourcesContent":["import { resolveSRVRecord } from '../connection_string';\nimport { MONGO_CLIENT_EVENTS } from '../constants';\nimport { MongoInvalidArgumentError, MongoRuntimeError } from '../error';\nimport type { MongoClient, MongoOptions } from '../mongo_client';\nimport { Topology } from '../sdam/topology';\nimport type { Callback } from '../utils';\n\nexport function connect(\n  mongoClient: MongoClient,\n  options: MongoOptions,\n  callback: Callback<MongoClient>\n): void {\n  if (!callback) {\n    throw new MongoInvalidArgumentError('Callback function must be provided');\n  }\n\n  // If a connection already been established, we can terminate early\n  if (mongoClient.topology && mongoClient.topology.isConnected()) {\n    return callback(undefined, mongoClient);\n  }\n\n  const logger = mongoClient.logger;\n  const connectCallback: Callback = err => {\n    const warningMessage =\n      'seed list contains no mongos proxies, replicaset connections requires ' +\n      'the parameter replicaSet to be supplied in the URI or options object, ' +\n      'mongodb://server:port/db?replicaSet=name';\n    if (err && err.message === 'no mongos proxies found in seed list') {\n      if (logger.isWarn()) {\n        logger.warn(warningMessage);\n      }\n\n      // Return a more specific error message for MongoClient.connect\n      // TODO(NODE-3483)\n      return callback(new MongoRuntimeError(warningMessage));\n    }\n\n    callback(err, mongoClient);\n  };\n\n  if (typeof options.srvHost === 'string') {\n    return resolveSRVRecord(options, (err, hosts) => {\n      if (err || !hosts) return callback(err);\n      for (const [index, host] of hosts.entries()) {\n        options.hosts[index] = host;\n      }\n\n      return createTopology(mongoClient, options, connectCallback);\n    });\n  }\n\n  return createTopology(mongoClient, options, connectCallback);\n}\n\nfunction createTopology(\n  mongoClient: MongoClient,\n  options: MongoOptions,\n  callback: Callback<Topology>\n) {\n  // Create the topology\n  const topology = new Topology(options.hosts, options);\n  // Events can be emitted before initialization is complete so we have to\n  // save the reference to the topology on the client ASAP if the event handlers need to access it\n  mongoClient.topology = topology;\n\n  topology.once(Topology.OPEN, () => mongoClient.emit('open', mongoClient));\n\n  for (const event of MONGO_CLIENT_EVENTS) {\n    topology.on(event, (...args: any[]) => mongoClient.emit(event, ...(args as any)));\n  }\n\n  // initialize CSFLE if requested\n  if (mongoClient.autoEncrypter) {\n    mongoClient.autoEncrypter.init(err => {\n      if (err) {\n        return callback(err);\n      }\n\n      topology.connect(options, err => {\n        if (err) {\n          topology.close({ force: true });\n          return callback(err);\n        }\n\n        options.encrypter.connectInternalClient(error => {\n          if (error) return callback(error);\n\n          callback(undefined, topology);\n        });\n      });\n    });\n\n    return;\n  }\n\n  // otherwise connect normally\n  topology.connect(options, err => {\n    if (err) {\n      topology.close({ force: true });\n      return callback(err);\n    }\n\n    callback(undefined, topology);\n    return;\n  });\n}\n"]},"metadata":{},"sourceType":"script"}