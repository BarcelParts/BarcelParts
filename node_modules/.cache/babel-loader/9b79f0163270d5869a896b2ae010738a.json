{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FindOperation = void 0;\n\nconst shared_1 = require(\"../cmap/wire_protocol/shared\");\n\nconst error_1 = require(\"../error\");\n\nconst read_concern_1 = require(\"../read_concern\");\n\nconst sort_1 = require(\"../sort\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n\nconst SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;\n/** @internal */\n\nclass FindOperation extends command_1.CommandOperation {\n  constructor(collection, ns) {\n    let filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(collection, options);\n    this.options = options;\n    this.ns = ns;\n\n    if (typeof filter !== 'object' || Array.isArray(filter)) {\n      throw new error_1.MongoInvalidArgumentError('Query filter must be a plain object or ObjectId');\n    } // If the filter is a buffer, validate that is a valid BSON document\n\n\n    if (Buffer.isBuffer(filter)) {\n      const objectSize = filter[0] | filter[1] << 8 | filter[2] << 16 | filter[3] << 24;\n\n      if (objectSize !== filter.length) {\n        throw new error_1.MongoInvalidArgumentError(`Query filter raw message size does not match message header size [${filter.length}] != [${objectSize}]`);\n      }\n    } // special case passing in an ObjectId as a filter\n\n\n    this.filter = filter != null && filter._bsontype === 'ObjectID' ? {\n      _id: filter\n    } : filter;\n  }\n\n  execute(server, session, callback) {\n    this.server = server;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const options = this.options;\n\n    if (options.allowDiskUse != null && serverWireVersion < 4) {\n      callback(new error_1.MongoCompatibilityError('Option \"allowDiskUse\" is not supported on MongoDB < 3.2'));\n      return;\n    }\n\n    if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {\n      callback(new error_1.MongoCompatibilityError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));\n      return;\n    }\n\n    if (serverWireVersion < 4) {\n      if (this.readConcern && this.readConcern.level !== 'local') {\n        callback(new error_1.MongoCompatibilityError(`Server find command does not support a readConcern level of ${this.readConcern.level}`));\n        return;\n      }\n\n      const findCommand = makeLegacyFindCommand(this.ns, this.filter, options);\n\n      if ((0, shared_1.isSharded)(server) && this.readPreference) {\n        findCommand.$readPreference = this.readPreference.toJSON();\n      }\n\n      server.query(this.ns, findCommand, { ...this.options,\n        ...this.bsonOptions,\n        documentsReturnedIn: 'firstBatch',\n        readPreference: this.readPreference\n      }, callback);\n      return;\n    }\n\n    let findCommand = makeFindCommand(this.ns, this.filter, options);\n\n    if (this.explain) {\n      findCommand = (0, utils_1.decorateWithExplain)(findCommand, this.explain);\n    }\n\n    server.command(this.ns, findCommand, { ...this.options,\n      ...this.bsonOptions,\n      documentsReturnedIn: 'firstBatch',\n      session\n    }, callback);\n  }\n\n}\n\nexports.FindOperation = FindOperation;\n\nfunction makeFindCommand(ns, filter, options) {\n  const findCommand = {\n    find: ns.collection,\n    filter\n  };\n\n  if (options.sort) {\n    findCommand.sort = (0, sort_1.formatSort)(options.sort);\n  }\n\n  if (options.projection) {\n    let projection = options.projection;\n\n    if (projection && Array.isArray(projection)) {\n      projection = projection.length ? projection.reduce((result, field) => {\n        result[field] = 1;\n        return result;\n      }, {}) : {\n        _id: 1\n      };\n    }\n\n    findCommand.projection = projection;\n  }\n\n  if (options.hint) {\n    findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);\n  }\n\n  if (typeof options.skip === 'number') {\n    findCommand.skip = options.skip;\n  }\n\n  if (typeof options.limit === 'number') {\n    if (options.limit < 0) {\n      findCommand.limit = -options.limit;\n      findCommand.singleBatch = true;\n    } else {\n      findCommand.limit = options.limit;\n    }\n  }\n\n  if (typeof options.batchSize === 'number') {\n    if (options.batchSize < 0) {\n      if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {\n        findCommand.limit = -options.batchSize;\n      }\n\n      findCommand.singleBatch = true;\n    } else {\n      findCommand.batchSize = options.batchSize;\n    }\n  }\n\n  if (typeof options.singleBatch === 'boolean') {\n    findCommand.singleBatch = options.singleBatch;\n  } // we check for undefined specifically here to allow falsy values\n  // eslint-disable-next-line no-restricted-syntax\n\n\n  if (options.comment !== undefined) {\n    findCommand.comment = options.comment;\n  }\n\n  if (typeof options.maxTimeMS === 'number') {\n    findCommand.maxTimeMS = options.maxTimeMS;\n  }\n\n  const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n\n  if (readConcern) {\n    findCommand.readConcern = readConcern.toJSON();\n  }\n\n  if (options.max) {\n    findCommand.max = options.max;\n  }\n\n  if (options.min) {\n    findCommand.min = options.min;\n  }\n\n  if (typeof options.returnKey === 'boolean') {\n    findCommand.returnKey = options.returnKey;\n  }\n\n  if (typeof options.showRecordId === 'boolean') {\n    findCommand.showRecordId = options.showRecordId;\n  }\n\n  if (typeof options.tailable === 'boolean') {\n    findCommand.tailable = options.tailable;\n  }\n\n  if (typeof options.timeout === 'boolean') {\n    findCommand.noCursorTimeout = !options.timeout;\n  } else if (typeof options.noCursorTimeout === 'boolean') {\n    findCommand.noCursorTimeout = options.noCursorTimeout;\n  }\n\n  if (typeof options.awaitData === 'boolean') {\n    findCommand.awaitData = options.awaitData;\n  }\n\n  if (typeof options.allowPartialResults === 'boolean') {\n    findCommand.allowPartialResults = options.allowPartialResults;\n  }\n\n  if (options.collation) {\n    findCommand.collation = options.collation;\n  }\n\n  if (typeof options.allowDiskUse === 'boolean') {\n    findCommand.allowDiskUse = options.allowDiskUse;\n  }\n\n  if (options.let) {\n    findCommand.let = options.let;\n  }\n\n  return findCommand;\n}\n\nfunction makeLegacyFindCommand(ns, filter, options) {\n  const findCommand = {\n    $query: filter\n  };\n\n  if (options.sort) {\n    findCommand.$orderby = (0, sort_1.formatSort)(options.sort);\n  }\n\n  if (options.hint) {\n    findCommand.$hint = (0, utils_1.normalizeHintField)(options.hint);\n  }\n\n  if (typeof options.returnKey === 'boolean') {\n    findCommand.$returnKey = options.returnKey;\n  }\n\n  if (options.max) {\n    findCommand.$max = options.max;\n  }\n\n  if (options.min) {\n    findCommand.$min = options.min;\n  }\n\n  if (typeof options.showRecordId === 'boolean') {\n    findCommand.$showDiskLoc = options.showRecordId;\n  }\n\n  if (options.comment) {\n    findCommand.$comment = options.comment;\n  }\n\n  if (typeof options.maxTimeMS === 'number') {\n    findCommand.$maxTimeMS = options.maxTimeMS;\n  }\n\n  if (options.explain != null) {\n    findCommand.$explain = true;\n  }\n\n  return findCommand;\n}\n\n(0, operation_1.defineAspects)(FindOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);","map":{"version":3,"mappings":";;;;;;;AACA;;AAEA;;AACA;;AAGA;;AACA;;AAOA;;AACA;;AAoDA,MAAMA,oCAAoC,GAAG,CAA7C;AAEA;;AACA,MAAaC,aAAb,SAAmCC,0BAAnC,CAA6D;AAI3DC,cACEC,UADF,EAEEC,EAFF,EAI2B;AAAA,QADzBC,MACyB,uEADN,EACM;AAAA,QAAzBC,OAAyB,uEAAF,EAAE;AAEzB,UAAMH,UAAN,EAAkBG,OAAlB;AAEA,SAAKA,OAAL,GAAeA,OAAf;AACA,SAAKF,EAAL,GAAUA,EAAV;;AAEA,QAAI,OAAOC,MAAP,KAAkB,QAAlB,IAA8BE,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAlC,EAAyD;AACvD,YAAM,IAAII,iCAAJ,CAA8B,iDAA9B,CAAN;AACD,KATwB,CAWzB;;;AACA,QAAIC,MAAM,CAACC,QAAP,CAAgBN,MAAhB,CAAJ,EAA6B;AAC3B,YAAMO,UAAU,GAAGP,MAAM,CAAC,CAAD,CAAN,GAAaA,MAAM,CAAC,CAAD,CAAN,IAAa,CAA1B,GAAgCA,MAAM,CAAC,CAAD,CAAN,IAAa,EAA7C,GAAoDA,MAAM,CAAC,CAAD,CAAN,IAAa,EAApF;;AACA,UAAIO,UAAU,KAAKP,MAAM,CAACQ,MAA1B,EAAkC;AAChC,cAAM,IAAIJ,iCAAJ,CACJ,qEAAqEJ,MAAM,CAACQ,MAAM,SAASD,UAAU,GADjG,CAAN;AAGD;AACF,KAnBwB,CAqBzB;;;AACA,SAAKP,MAAL,GAAcA,MAAM,IAAI,IAAV,IAAkBA,MAAM,CAACS,SAAP,KAAqB,UAAvC,GAAoD;AAAEC,SAAG,EAAEV;AAAP,KAApD,GAAsEA,MAApF;AACD;;AAEQW,SAAO,CACdC,MADc,EAEdC,OAFc,EAGdC,QAHc,EAGc;AAE5B,SAAKF,MAAL,GAAcA,MAAd;AAEA,UAAMG,iBAAiB,GAAG,4BAAeH,MAAf,CAA1B;AACA,UAAMX,OAAO,GAAG,KAAKA,OAArB;;AACA,QAAIA,OAAO,CAACe,YAAR,IAAwB,IAAxB,IAAgCD,iBAAiB,GAAG,CAAxD,EAA2D;AACzDD,cAAQ,CACN,IAAIV,+BAAJ,CAA4B,yDAA5B,CADM,CAAR;AAGA;AACD;;AAED,QAAIH,OAAO,CAACgB,SAAR,IAAqBF,iBAAiB,GAAGrB,oCAA7C,EAAmF;AACjFoB,cAAQ,CACN,IAAIV,+BAAJ,CACE,UAAUQ,MAAM,CAACM,IAAI,gCAAgCH,iBAAiB,8BADxE,CADM,CAAR;AAMA;AACD;;AAED,QAAIA,iBAAiB,GAAG,CAAxB,EAA2B;AACzB,UAAI,KAAKI,WAAL,IAAoB,KAAKA,WAAL,CAAiBC,KAAjB,KAA2B,OAAnD,EAA4D;AAC1DN,gBAAQ,CACN,IAAIV,+BAAJ,CACE,+DAA+D,KAAKe,WAAL,CAAiBC,KAAK,EADvF,CADM,CAAR;AAMA;AACD;;AAED,YAAMC,WAAW,GAAGC,qBAAqB,CAAC,KAAKvB,EAAN,EAAU,KAAKC,MAAf,EAAuBC,OAAvB,CAAzC;;AACA,UAAI,wBAAUW,MAAV,KAAqB,KAAKW,cAA9B,EAA8C;AAC5CF,mBAAW,CAACG,eAAZ,GAA8B,KAAKD,cAAL,CAAoBE,MAApB,EAA9B;AACD;;AAEDb,YAAM,CAACc,KAAP,CACE,KAAK3B,EADP,EAEEsB,WAFF,EAGE,EACE,GAAG,KAAKpB,OADV;AAEE,WAAG,KAAK0B,WAFV;AAGEC,2BAAmB,EAAE,YAHvB;AAIEL,sBAAc,EAAE,KAAKA;AAJvB,OAHF,EASET,QATF;AAYA;AACD;;AAED,QAAIO,WAAW,GAAGQ,eAAe,CAAC,KAAK9B,EAAN,EAAU,KAAKC,MAAf,EAAuBC,OAAvB,CAAjC;;AACA,QAAI,KAAK6B,OAAT,EAAkB;AAChBT,iBAAW,GAAG,iCAAoBA,WAApB,EAAiC,KAAKS,OAAtC,CAAd;AACD;;AAEDlB,UAAM,CAACmB,OAAP,CACE,KAAKhC,EADP,EAEEsB,WAFF,EAGE,EACE,GAAG,KAAKpB,OADV;AAEE,SAAG,KAAK0B,WAFV;AAGEC,yBAAmB,EAAE,YAHvB;AAIEf;AAJF,KAHF,EASEC,QATF;AAWD;;AA1G0D;;AAA7DkB;;AA6GA,SAASH,eAAT,CAAyB9B,EAAzB,EAA+CC,MAA/C,EAAiEC,OAAjE,EAAqF;AACnF,QAAMoB,WAAW,GAAa;AAC5BY,QAAI,EAAElC,EAAE,CAACD,UADmB;AAE5BE;AAF4B,GAA9B;;AAKA,MAAIC,OAAO,CAACiC,IAAZ,EAAkB;AAChBb,eAAW,CAACa,IAAZ,GAAmB,uBAAWjC,OAAO,CAACiC,IAAnB,CAAnB;AACD;;AAED,MAAIjC,OAAO,CAACkC,UAAZ,EAAwB;AACtB,QAAIA,UAAU,GAAGlC,OAAO,CAACkC,UAAzB;;AACA,QAAIA,UAAU,IAAIjC,KAAK,CAACC,OAAN,CAAcgC,UAAd,CAAlB,EAA6C;AAC3CA,gBAAU,GAAGA,UAAU,CAAC3B,MAAX,GACT2B,UAAU,CAACC,MAAX,CAAkB,CAACC,MAAD,EAASC,KAAT,KAAkB;AAClCD,cAAM,CAACC,KAAD,CAAN,GAAgB,CAAhB;AACA,eAAOD,MAAP;AACD,OAHD,EAGG,EAHH,CADS,GAKT;AAAE3B,WAAG,EAAE;AAAP,OALJ;AAMD;;AAEDW,eAAW,CAACc,UAAZ,GAAyBA,UAAzB;AACD;;AAED,MAAIlC,OAAO,CAACsC,IAAZ,EAAkB;AAChBlB,eAAW,CAACkB,IAAZ,GAAmB,gCAAmBtC,OAAO,CAACsC,IAA3B,CAAnB;AACD;;AAED,MAAI,OAAOtC,OAAO,CAACuC,IAAf,KAAwB,QAA5B,EAAsC;AACpCnB,eAAW,CAACmB,IAAZ,GAAmBvC,OAAO,CAACuC,IAA3B;AACD;;AAED,MAAI,OAAOvC,OAAO,CAACwC,KAAf,KAAyB,QAA7B,EAAuC;AACrC,QAAIxC,OAAO,CAACwC,KAAR,GAAgB,CAApB,EAAuB;AACrBpB,iBAAW,CAACoB,KAAZ,GAAoB,CAACxC,OAAO,CAACwC,KAA7B;AACApB,iBAAW,CAACqB,WAAZ,GAA0B,IAA1B;AACD,KAHD,MAGO;AACLrB,iBAAW,CAACoB,KAAZ,GAAoBxC,OAAO,CAACwC,KAA5B;AACD;AACF;;AAED,MAAI,OAAOxC,OAAO,CAAC0C,SAAf,KAA6B,QAAjC,EAA2C;AACzC,QAAI1C,OAAO,CAAC0C,SAAR,GAAoB,CAAxB,EAA2B;AACzB,UACE1C,OAAO,CAACwC,KAAR,IACAxC,OAAO,CAACwC,KAAR,KAAkB,CADlB,IAEAG,IAAI,CAACC,GAAL,CAAS5C,OAAO,CAAC0C,SAAjB,IAA8BC,IAAI,CAACC,GAAL,CAAS5C,OAAO,CAACwC,KAAjB,CAHhC,EAIE;AACApB,mBAAW,CAACoB,KAAZ,GAAoB,CAACxC,OAAO,CAAC0C,SAA7B;AACD;;AAEDtB,iBAAW,CAACqB,WAAZ,GAA0B,IAA1B;AACD,KAVD,MAUO;AACLrB,iBAAW,CAACsB,SAAZ,GAAwB1C,OAAO,CAAC0C,SAAhC;AACD;AACF;;AAED,MAAI,OAAO1C,OAAO,CAACyC,WAAf,KAA+B,SAAnC,EAA8C;AAC5CrB,eAAW,CAACqB,WAAZ,GAA0BzC,OAAO,CAACyC,WAAlC;AACD,GA3DkF,CA6DnF;AACA;;;AACA,MAAIzC,OAAO,CAAC6C,OAAR,KAAoBC,SAAxB,EAAmC;AACjC1B,eAAW,CAACyB,OAAZ,GAAsB7C,OAAO,CAAC6C,OAA9B;AACD;;AAED,MAAI,OAAO7C,OAAO,CAAC+C,SAAf,KAA6B,QAAjC,EAA2C;AACzC3B,eAAW,CAAC2B,SAAZ,GAAwB/C,OAAO,CAAC+C,SAAhC;AACD;;AAED,QAAM7B,WAAW,GAAG8B,2BAAYC,WAAZ,CAAwBjD,OAAxB,CAApB;;AACA,MAAIkB,WAAJ,EAAiB;AACfE,eAAW,CAACF,WAAZ,GAA0BA,WAAW,CAACM,MAAZ,EAA1B;AACD;;AAED,MAAIxB,OAAO,CAACkD,GAAZ,EAAiB;AACf9B,eAAW,CAAC8B,GAAZ,GAAkBlD,OAAO,CAACkD,GAA1B;AACD;;AAED,MAAIlD,OAAO,CAACmD,GAAZ,EAAiB;AACf/B,eAAW,CAAC+B,GAAZ,GAAkBnD,OAAO,CAACmD,GAA1B;AACD;;AAED,MAAI,OAAOnD,OAAO,CAACoD,SAAf,KAA6B,SAAjC,EAA4C;AAC1ChC,eAAW,CAACgC,SAAZ,GAAwBpD,OAAO,CAACoD,SAAhC;AACD;;AAED,MAAI,OAAOpD,OAAO,CAACqD,YAAf,KAAgC,SAApC,EAA+C;AAC7CjC,eAAW,CAACiC,YAAZ,GAA2BrD,OAAO,CAACqD,YAAnC;AACD;;AAED,MAAI,OAAOrD,OAAO,CAACsD,QAAf,KAA4B,SAAhC,EAA2C;AACzClC,eAAW,CAACkC,QAAZ,GAAuBtD,OAAO,CAACsD,QAA/B;AACD;;AAED,MAAI,OAAOtD,OAAO,CAACuD,OAAf,KAA2B,SAA/B,EAA0C;AACxCnC,eAAW,CAACoC,eAAZ,GAA8B,CAACxD,OAAO,CAACuD,OAAvC;AACD,GAFD,MAEO,IAAI,OAAOvD,OAAO,CAACwD,eAAf,KAAmC,SAAvC,EAAkD;AACvDpC,eAAW,CAACoC,eAAZ,GAA8BxD,OAAO,CAACwD,eAAtC;AACD;;AAED,MAAI,OAAOxD,OAAO,CAACyD,SAAf,KAA6B,SAAjC,EAA4C;AAC1CrC,eAAW,CAACqC,SAAZ,GAAwBzD,OAAO,CAACyD,SAAhC;AACD;;AAED,MAAI,OAAOzD,OAAO,CAAC0D,mBAAf,KAAuC,SAA3C,EAAsD;AACpDtC,eAAW,CAACsC,mBAAZ,GAAkC1D,OAAO,CAAC0D,mBAA1C;AACD;;AAED,MAAI1D,OAAO,CAACgB,SAAZ,EAAuB;AACrBI,eAAW,CAACJ,SAAZ,GAAwBhB,OAAO,CAACgB,SAAhC;AACD;;AAED,MAAI,OAAOhB,OAAO,CAACe,YAAf,KAAgC,SAApC,EAA+C;AAC7CK,eAAW,CAACL,YAAZ,GAA2Bf,OAAO,CAACe,YAAnC;AACD;;AAED,MAAIf,OAAO,CAAC2D,GAAZ,EAAiB;AACfvC,eAAW,CAACuC,GAAZ,GAAkB3D,OAAO,CAAC2D,GAA1B;AACD;;AAED,SAAOvC,WAAP;AACD;;AAED,SAASC,qBAAT,CACEvB,EADF,EAEEC,MAFF,EAGEC,OAHF,EAGsB;AAEpB,QAAMoB,WAAW,GAAa;AAC5BwC,UAAM,EAAE7D;AADoB,GAA9B;;AAIA,MAAIC,OAAO,CAACiC,IAAZ,EAAkB;AAChBb,eAAW,CAACyC,QAAZ,GAAuB,uBAAW7D,OAAO,CAACiC,IAAnB,CAAvB;AACD;;AAED,MAAIjC,OAAO,CAACsC,IAAZ,EAAkB;AAChBlB,eAAW,CAAC0C,KAAZ,GAAoB,gCAAmB9D,OAAO,CAACsC,IAA3B,CAApB;AACD;;AAED,MAAI,OAAOtC,OAAO,CAACoD,SAAf,KAA6B,SAAjC,EAA4C;AAC1ChC,eAAW,CAAC2C,UAAZ,GAAyB/D,OAAO,CAACoD,SAAjC;AACD;;AAED,MAAIpD,OAAO,CAACkD,GAAZ,EAAiB;AACf9B,eAAW,CAAC4C,IAAZ,GAAmBhE,OAAO,CAACkD,GAA3B;AACD;;AAED,MAAIlD,OAAO,CAACmD,GAAZ,EAAiB;AACf/B,eAAW,CAAC6C,IAAZ,GAAmBjE,OAAO,CAACmD,GAA3B;AACD;;AAED,MAAI,OAAOnD,OAAO,CAACqD,YAAf,KAAgC,SAApC,EAA+C;AAC7CjC,eAAW,CAAC8C,YAAZ,GAA2BlE,OAAO,CAACqD,YAAnC;AACD;;AAED,MAAIrD,OAAO,CAAC6C,OAAZ,EAAqB;AACnBzB,eAAW,CAAC+C,QAAZ,GAAuBnE,OAAO,CAAC6C,OAA/B;AACD;;AAED,MAAI,OAAO7C,OAAO,CAAC+C,SAAf,KAA6B,QAAjC,EAA2C;AACzC3B,eAAW,CAACgD,UAAZ,GAAyBpE,OAAO,CAAC+C,SAAjC;AACD;;AAED,MAAI/C,OAAO,CAAC6B,OAAR,IAAmB,IAAvB,EAA6B;AAC3BT,eAAW,CAACiD,QAAZ,GAAuB,IAAvB;AACD;;AAED,SAAOjD,WAAP;AACD;;AAED,+BAAc1B,aAAd,EAA6B,CAC3B4E,mBAAOC,cADoB,EAE3BD,mBAAOE,SAFoB,EAG3BF,mBAAOG,WAHoB,EAI3BH,mBAAOI,eAJoB,CAA7B","names":["SUPPORTS_WRITE_CONCERN_AND_COLLATION","FindOperation","command_1","constructor","collection","ns","filter","options","Array","isArray","error_1","Buffer","isBuffer","objectSize","length","_bsontype","_id","execute","server","session","callback","serverWireVersion","allowDiskUse","collation","name","readConcern","level","findCommand","makeLegacyFindCommand","readPreference","$readPreference","toJSON","query","bsonOptions","documentsReturnedIn","makeFindCommand","explain","command","exports","find","sort","projection","reduce","result","field","hint","skip","limit","singleBatch","batchSize","Math","abs","comment","undefined","maxTimeMS","read_concern_1","fromOptions","max","min","returnKey","showRecordId","tailable","timeout","noCursorTimeout","awaitData","allowPartialResults","let","$query","$orderby","$hint","$returnKey","$max","$min","$showDiskLoc","$comment","$maxTimeMS","$explain","operation_1","READ_OPERATION","RETRYABLE","EXPLAINABLE","CURSOR_CREATING"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\operations\\find.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport { isSharded } from '../cmap/wire_protocol/shared';\r\nimport type { Collection } from '../collection';\r\nimport { MongoCompatibilityError, MongoInvalidArgumentError } from '../error';\r\nimport { ReadConcern } from '../read_concern';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport { formatSort, Sort } from '../sort';\r\nimport {\r\n  Callback,\r\n  decorateWithExplain,\r\n  maxWireVersion,\r\n  MongoDBNamespace,\r\n  normalizeHintField\r\n} from '../utils';\r\nimport { CollationOptions, CommandOperation, CommandOperationOptions } from './command';\r\nimport { Aspect, defineAspects, Hint } from './operation';\r\n\r\n/**\r\n * @public\r\n * @typeParam TSchema - Unused schema definition, deprecated usage, only specify `FindOptions` with no generic\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport interface FindOptions<TSchema extends Document = Document> extends CommandOperationOptions {\r\n  /** Sets the limit of documents returned in the query. */\r\n  limit?: number;\r\n  /** Set to sort the documents coming back from the query. Array of indexes, `[['a', 1]]` etc. */\r\n  sort?: Sort;\r\n  /** The fields to return in the query. Object of fields to either include or exclude (one of, not both), `{'a':1, 'b': 1}` **or** `{'a': 0, 'b': 0}` */\r\n  projection?: Document;\r\n  /** Set to skip N documents ahead in your query (useful for pagination). */\r\n  skip?: number;\r\n  /** Tell the query to use specific indexes in the query. Object of indexes to use, `{'_id':1}` */\r\n  hint?: Hint;\r\n  /** Specify if the cursor can timeout. */\r\n  timeout?: boolean;\r\n  /** Specify if the cursor is tailable. */\r\n  tailable?: boolean;\r\n  /** Specify if the cursor is a tailable-await cursor. Requires `tailable` to be true */\r\n  awaitData?: boolean;\r\n  /** Set the batchSize for the getMoreCommand when iterating over the query results. */\r\n  batchSize?: number;\r\n  /** If true, returns only the index keys in the resulting documents. */\r\n  returnKey?: boolean;\r\n  /** The inclusive lower bound for a specific index */\r\n  min?: Document;\r\n  /** The exclusive upper bound for a specific index */\r\n  max?: Document;\r\n  /** Number of milliseconds to wait before aborting the query. */\r\n  maxTimeMS?: number;\r\n  /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true */\r\n  maxAwaitTimeMS?: number;\r\n  /** The server normally times out idle cursors after an inactivity period (10 minutes) to prevent excess memory use. Set this option to prevent that. */\r\n  noCursorTimeout?: boolean;\r\n  /** Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields). */\r\n  collation?: CollationOptions;\r\n  /** Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher) */\r\n  allowDiskUse?: boolean;\r\n  /** Determines whether to close the cursor after the first batch. Defaults to false. */\r\n  singleBatch?: boolean;\r\n  /** For queries against a sharded collection, allows the command (or subsequent getMore commands) to return partial results, rather than an error, if one or more queried shards are unavailable. */\r\n  allowPartialResults?: boolean;\r\n  /** Determines whether to return the record identifier for each document. If true, adds a field $recordId to the returned documents. */\r\n  showRecordId?: boolean;\r\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\r\n  let?: Document;\r\n}\r\n\r\nconst SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;\r\n\r\n/** @internal */\r\nexport class FindOperation extends CommandOperation<Document> {\r\n  override options: FindOptions;\r\n  filter: Document;\r\n\r\n  constructor(\r\n    collection: Collection | undefined,\r\n    ns: MongoDBNamespace,\r\n    filter: Document = {},\r\n    options: FindOptions = {}\r\n  ) {\r\n    super(collection, options);\r\n\r\n    this.options = options;\r\n    this.ns = ns;\r\n\r\n    if (typeof filter !== 'object' || Array.isArray(filter)) {\r\n      throw new MongoInvalidArgumentError('Query filter must be a plain object or ObjectId');\r\n    }\r\n\r\n    // If the filter is a buffer, validate that is a valid BSON document\r\n    if (Buffer.isBuffer(filter)) {\r\n      const objectSize = filter[0] | (filter[1] << 8) | (filter[2] << 16) | (filter[3] << 24);\r\n      if (objectSize !== filter.length) {\r\n        throw new MongoInvalidArgumentError(\r\n          `Query filter raw message size does not match message header size [${filter.length}] != [${objectSize}]`\r\n        );\r\n      }\r\n    }\r\n\r\n    // special case passing in an ObjectId as a filter\r\n    this.filter = filter != null && filter._bsontype === 'ObjectID' ? { _id: filter } : filter;\r\n  }\r\n\r\n  override execute(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<Document>\r\n  ): void {\r\n    this.server = server;\r\n\r\n    const serverWireVersion = maxWireVersion(server);\r\n    const options = this.options;\r\n    if (options.allowDiskUse != null && serverWireVersion < 4) {\r\n      callback(\r\n        new MongoCompatibilityError('Option \"allowDiskUse\" is not supported on MongoDB < 3.2')\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {\r\n      callback(\r\n        new MongoCompatibilityError(\r\n          `Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`\r\n        )\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    if (serverWireVersion < 4) {\r\n      if (this.readConcern && this.readConcern.level !== 'local') {\r\n        callback(\r\n          new MongoCompatibilityError(\r\n            `Server find command does not support a readConcern level of ${this.readConcern.level}`\r\n          )\r\n        );\r\n\r\n        return;\r\n      }\r\n\r\n      const findCommand = makeLegacyFindCommand(this.ns, this.filter, options);\r\n      if (isSharded(server) && this.readPreference) {\r\n        findCommand.$readPreference = this.readPreference.toJSON();\r\n      }\r\n\r\n      server.query(\r\n        this.ns,\r\n        findCommand,\r\n        {\r\n          ...this.options,\r\n          ...this.bsonOptions,\r\n          documentsReturnedIn: 'firstBatch',\r\n          readPreference: this.readPreference\r\n        },\r\n        callback\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    let findCommand = makeFindCommand(this.ns, this.filter, options);\r\n    if (this.explain) {\r\n      findCommand = decorateWithExplain(findCommand, this.explain);\r\n    }\r\n\r\n    server.command(\r\n      this.ns,\r\n      findCommand,\r\n      {\r\n        ...this.options,\r\n        ...this.bsonOptions,\r\n        documentsReturnedIn: 'firstBatch',\r\n        session\r\n      },\r\n      callback\r\n    );\r\n  }\r\n}\r\n\r\nfunction makeFindCommand(ns: MongoDBNamespace, filter: Document, options: FindOptions): Document {\r\n  const findCommand: Document = {\r\n    find: ns.collection,\r\n    filter\r\n  };\r\n\r\n  if (options.sort) {\r\n    findCommand.sort = formatSort(options.sort);\r\n  }\r\n\r\n  if (options.projection) {\r\n    let projection = options.projection;\r\n    if (projection && Array.isArray(projection)) {\r\n      projection = projection.length\r\n        ? projection.reduce((result, field) => {\r\n            result[field] = 1;\r\n            return result;\r\n          }, {})\r\n        : { _id: 1 };\r\n    }\r\n\r\n    findCommand.projection = projection;\r\n  }\r\n\r\n  if (options.hint) {\r\n    findCommand.hint = normalizeHintField(options.hint);\r\n  }\r\n\r\n  if (typeof options.skip === 'number') {\r\n    findCommand.skip = options.skip;\r\n  }\r\n\r\n  if (typeof options.limit === 'number') {\r\n    if (options.limit < 0) {\r\n      findCommand.limit = -options.limit;\r\n      findCommand.singleBatch = true;\r\n    } else {\r\n      findCommand.limit = options.limit;\r\n    }\r\n  }\r\n\r\n  if (typeof options.batchSize === 'number') {\r\n    if (options.batchSize < 0) {\r\n      if (\r\n        options.limit &&\r\n        options.limit !== 0 &&\r\n        Math.abs(options.batchSize) < Math.abs(options.limit)\r\n      ) {\r\n        findCommand.limit = -options.batchSize;\r\n      }\r\n\r\n      findCommand.singleBatch = true;\r\n    } else {\r\n      findCommand.batchSize = options.batchSize;\r\n    }\r\n  }\r\n\r\n  if (typeof options.singleBatch === 'boolean') {\r\n    findCommand.singleBatch = options.singleBatch;\r\n  }\r\n\r\n  // we check for undefined specifically here to allow falsy values\r\n  // eslint-disable-next-line no-restricted-syntax\r\n  if (options.comment !== undefined) {\r\n    findCommand.comment = options.comment;\r\n  }\r\n\r\n  if (typeof options.maxTimeMS === 'number') {\r\n    findCommand.maxTimeMS = options.maxTimeMS;\r\n  }\r\n\r\n  const readConcern = ReadConcern.fromOptions(options);\r\n  if (readConcern) {\r\n    findCommand.readConcern = readConcern.toJSON();\r\n  }\r\n\r\n  if (options.max) {\r\n    findCommand.max = options.max;\r\n  }\r\n\r\n  if (options.min) {\r\n    findCommand.min = options.min;\r\n  }\r\n\r\n  if (typeof options.returnKey === 'boolean') {\r\n    findCommand.returnKey = options.returnKey;\r\n  }\r\n\r\n  if (typeof options.showRecordId === 'boolean') {\r\n    findCommand.showRecordId = options.showRecordId;\r\n  }\r\n\r\n  if (typeof options.tailable === 'boolean') {\r\n    findCommand.tailable = options.tailable;\r\n  }\r\n\r\n  if (typeof options.timeout === 'boolean') {\r\n    findCommand.noCursorTimeout = !options.timeout;\r\n  } else if (typeof options.noCursorTimeout === 'boolean') {\r\n    findCommand.noCursorTimeout = options.noCursorTimeout;\r\n  }\r\n\r\n  if (typeof options.awaitData === 'boolean') {\r\n    findCommand.awaitData = options.awaitData;\r\n  }\r\n\r\n  if (typeof options.allowPartialResults === 'boolean') {\r\n    findCommand.allowPartialResults = options.allowPartialResults;\r\n  }\r\n\r\n  if (options.collation) {\r\n    findCommand.collation = options.collation;\r\n  }\r\n\r\n  if (typeof options.allowDiskUse === 'boolean') {\r\n    findCommand.allowDiskUse = options.allowDiskUse;\r\n  }\r\n\r\n  if (options.let) {\r\n    findCommand.let = options.let;\r\n  }\r\n\r\n  return findCommand;\r\n}\r\n\r\nfunction makeLegacyFindCommand(\r\n  ns: MongoDBNamespace,\r\n  filter: Document,\r\n  options: FindOptions\r\n): Document {\r\n  const findCommand: Document = {\r\n    $query: filter\r\n  };\r\n\r\n  if (options.sort) {\r\n    findCommand.$orderby = formatSort(options.sort);\r\n  }\r\n\r\n  if (options.hint) {\r\n    findCommand.$hint = normalizeHintField(options.hint);\r\n  }\r\n\r\n  if (typeof options.returnKey === 'boolean') {\r\n    findCommand.$returnKey = options.returnKey;\r\n  }\r\n\r\n  if (options.max) {\r\n    findCommand.$max = options.max;\r\n  }\r\n\r\n  if (options.min) {\r\n    findCommand.$min = options.min;\r\n  }\r\n\r\n  if (typeof options.showRecordId === 'boolean') {\r\n    findCommand.$showDiskLoc = options.showRecordId;\r\n  }\r\n\r\n  if (options.comment) {\r\n    findCommand.$comment = options.comment;\r\n  }\r\n\r\n  if (typeof options.maxTimeMS === 'number') {\r\n    findCommand.$maxTimeMS = options.maxTimeMS;\r\n  }\r\n\r\n  if (options.explain != null) {\r\n    findCommand.$explain = true;\r\n  }\r\n\r\n  return findCommand;\r\n}\r\n\r\ndefineAspects(FindOperation, [\r\n  Aspect.READ_OPERATION,\r\n  Aspect.RETRYABLE,\r\n  Aspect.EXPLAINABLE,\r\n  Aspect.CURSOR_CREATING\r\n]);\r\n"]},"metadata":{},"sourceType":"script"}