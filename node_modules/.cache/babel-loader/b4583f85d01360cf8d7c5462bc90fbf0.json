{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RenameOperation = void 0;\n\nconst collection_1 = require(\"../collection\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst operation_1 = require(\"./operation\");\n\nconst run_command_1 = require(\"./run_command\");\n/** @internal */\n\n\nclass RenameOperation extends run_command_1.RunAdminCommandOperation {\n  constructor(collection, newName, options) {\n    // Check the collection name\n    (0, utils_1.checkCollectionName)(newName); // Build the command\n\n    const renameCollection = collection.namespace;\n    const toCollection = collection.s.namespace.withCollection(newName).toString();\n    const dropTarget = typeof options.dropTarget === 'boolean' ? options.dropTarget : false;\n    const cmd = {\n      renameCollection: renameCollection,\n      to: toCollection,\n      dropTarget: dropTarget\n    };\n    super(collection, cmd, options);\n    this.options = options;\n    this.collection = collection;\n    this.newName = newName;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    super.execute(server, session, (err, doc) => {\n      if (err) return callback(err); // We have an error\n\n      if (doc === null || doc === void 0 ? void 0 : doc.errmsg) {\n        return callback(new error_1.MongoServerError(doc));\n      }\n\n      let newColl;\n\n      try {\n        newColl = new collection_1.Collection(coll.s.db, this.newName, coll.s.options);\n      } catch (err) {\n        return callback(err);\n      }\n\n      return callback(undefined, newColl);\n    });\n  }\n\n}\n\nexports.RenameOperation = RenameOperation;\n(0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":";;;;;;;AACA;;AACA;;AAGA;;AAEA;;AACA;AAUA;;;AACA,MAAaA,eAAb,SAAqCC,sCAArC,CAA6D;AAK3DC,cAAYC,UAAZ,EAAoCC,OAApC,EAAqDC,OAArD,EAA2E;AACzE;AACA,qCAAoBD,OAApB,EAFyE,CAIzE;;AACA,UAAME,gBAAgB,GAAGH,UAAU,CAACI,SAApC;AACA,UAAMC,YAAY,GAAGL,UAAU,CAACM,CAAX,CAAaF,SAAb,CAAuBG,cAAvB,CAAsCN,OAAtC,EAA+CO,QAA/C,EAArB;AACA,UAAMC,UAAU,GAAG,OAAOP,OAAO,CAACO,UAAf,KAA8B,SAA9B,GAA0CP,OAAO,CAACO,UAAlD,GAA+D,KAAlF;AACA,UAAMC,GAAG,GAAG;AAAEP,sBAAgB,EAAEA,gBAApB;AAAsCQ,QAAE,EAAEN,YAA1C;AAAwDI,gBAAU,EAAEA;AAApE,KAAZ;AAEA,UAAMT,UAAN,EAAkBU,GAAlB,EAAuBR,OAAvB;AACA,SAAKA,OAAL,GAAeA,OAAf;AACA,SAAKF,UAAL,GAAkBA,UAAlB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAEQW,SAAO,CACdC,MADc,EAEdC,OAFc,EAGdC,QAHc,EAGgB;AAE9B,UAAMC,IAAI,GAAG,KAAKhB,UAAlB;AAEA,UAAMY,OAAN,CAAcC,MAAd,EAAsBC,OAAtB,EAA+B,CAACG,GAAD,EAAMC,GAAN,KAAa;AAC1C,UAAID,GAAJ,EAAS,OAAOF,QAAQ,CAACE,GAAD,CAAf,CADiC,CAE1C;;AACA,UAAIC,GAAG,SAAH,OAAG,WAAH,GAAG,MAAH,MAAG,CAAEC,MAAT,EAAiB;AACf,eAAOJ,QAAQ,CAAC,IAAIK,wBAAJ,CAAqBF,GAArB,CAAD,CAAf;AACD;;AAED,UAAIG,OAAJ;;AACA,UAAI;AACFA,eAAO,GAAG,IAAIC,uBAAJ,CAAeN,IAAI,CAACV,CAAL,CAAOiB,EAAtB,EAA0B,KAAKtB,OAA/B,EAAwCe,IAAI,CAACV,CAAL,CAAOJ,OAA/C,CAAV;AACD,OAFD,CAEE,OAAOe,GAAP,EAAY;AACZ,eAAOF,QAAQ,CAACE,GAAD,CAAf;AACD;;AAED,aAAOF,QAAQ,CAACS,SAAD,EAAYH,OAAZ,CAAf;AACD,KAfD;AAgBD;;AA5C0D;;AAA7DI;AA+CA,+BAAc5B,eAAd,EAA+B,CAAC6B,mBAAOC,eAAR,CAA/B","names":["RenameOperation","run_command_1","constructor","collection","newName","options","renameCollection","namespace","toCollection","s","withCollection","toString","dropTarget","cmd","to","execute","server","session","callback","coll","err","doc","errmsg","error_1","newColl","collection_1","db","undefined","exports","operation_1","WRITE_OPERATION"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\operations\\rename.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { Collection } from '../collection';\nimport { MongoServerError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { Callback, checkCollectionName } from '../utils';\nimport type { CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\nimport { RunAdminCommandOperation } from './run_command';\n\n/** @public */\nexport interface RenameOptions extends CommandOperationOptions {\n  /** Drop the target name collection if it previously exists. */\n  dropTarget?: boolean;\n  /** Unclear */\n  new_collection?: boolean;\n}\n\n/** @internal */\nexport class RenameOperation extends RunAdminCommandOperation {\n  override options: RenameOptions;\n  collection: Collection;\n  newName: string;\n\n  constructor(collection: Collection, newName: string, options: RenameOptions) {\n    // Check the collection name\n    checkCollectionName(newName);\n\n    // Build the command\n    const renameCollection = collection.namespace;\n    const toCollection = collection.s.namespace.withCollection(newName).toString();\n    const dropTarget = typeof options.dropTarget === 'boolean' ? options.dropTarget : false;\n    const cmd = { renameCollection: renameCollection, to: toCollection, dropTarget: dropTarget };\n\n    super(collection, cmd, options);\n    this.options = options;\n    this.collection = collection;\n    this.newName = newName;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Collection>\n  ): void {\n    const coll = this.collection;\n\n    super.execute(server, session, (err, doc) => {\n      if (err) return callback(err);\n      // We have an error\n      if (doc?.errmsg) {\n        return callback(new MongoServerError(doc));\n      }\n\n      let newColl: Collection<Document>;\n      try {\n        newColl = new Collection(coll.s.db, this.newName, coll.s.options);\n      } catch (err) {\n        return callback(err);\n      }\n\n      return callback(undefined, newColl);\n    });\n  }\n}\n\ndefineAspects(RenameOperation, [Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}