{"ast":null,"code":"\"use strict\"; // Returns \"Type(value) is Object\" in ES terminology.\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\n\nconst hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty); // Like `Object.assign`, but using `[[GetOwnProperty]]` and `[[DefineOwnProperty]]`\n// instead of `[[Get]]` and `[[Set]]` and only allowing objects\n\nfunction define(target, source) {\n  for (const key of Reflect.ownKeys(source)) {\n    const descriptor = Reflect.getOwnPropertyDescriptor(source, key);\n\n    if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {\n      throw new TypeError(`Cannot redefine property: ${String(key)}`);\n    }\n  }\n}\n\nfunction newObjectInRealm(globalObject, object) {\n  const ctorRegistry = initCtorRegistry(globalObject);\n  return Object.defineProperties(Object.create(ctorRegistry[\"%Object.prototype%\"]), Object.getOwnPropertyDescriptors(object));\n}\n\nconst wrapperSymbol = Symbol(\"wrapper\");\nconst implSymbol = Symbol(\"impl\");\nconst sameObjectCaches = Symbol(\"SameObject caches\");\nconst ctorRegistrySymbol = Symbol.for(\"[webidl2js] constructor registry\");\nconst AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);\n\nfunction initCtorRegistry(globalObject) {\n  if (hasOwn(globalObject, ctorRegistrySymbol)) {\n    return globalObject[ctorRegistrySymbol];\n  }\n\n  const ctorRegistry = Object.create(null); // In addition to registering all the WebIDL2JS-generated types in the constructor registry,\n  // we also register a few intrinsics that we make use of in generated code, since they are not\n  // easy to grab from the globalObject variable.\n\n  ctorRegistry[\"%Object.prototype%\"] = globalObject.Object.prototype;\n  ctorRegistry[\"%IteratorPrototype%\"] = Object.getPrototypeOf(Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]()));\n\n  try {\n    ctorRegistry[\"%AsyncIteratorPrototype%\"] = Object.getPrototypeOf(Object.getPrototypeOf(globalObject.eval(\"(async function* () {})\").prototype));\n  } catch {\n    ctorRegistry[\"%AsyncIteratorPrototype%\"] = AsyncIteratorPrototype;\n  }\n\n  globalObject[ctorRegistrySymbol] = ctorRegistry;\n  return ctorRegistry;\n}\n\nfunction getSameObject(wrapper, prop, creator) {\n  if (!wrapper[sameObjectCaches]) {\n    wrapper[sameObjectCaches] = Object.create(null);\n  }\n\n  if (prop in wrapper[sameObjectCaches]) {\n    return wrapper[sameObjectCaches][prop];\n  }\n\n  wrapper[sameObjectCaches][prop] = creator();\n  return wrapper[sameObjectCaches][prop];\n}\n\nfunction wrapperForImpl(impl) {\n  return impl ? impl[wrapperSymbol] : null;\n}\n\nfunction implForWrapper(wrapper) {\n  return wrapper ? wrapper[implSymbol] : null;\n}\n\nfunction tryWrapperForImpl(impl) {\n  const wrapper = wrapperForImpl(impl);\n  return wrapper ? wrapper : impl;\n}\n\nfunction tryImplForWrapper(wrapper) {\n  const impl = implForWrapper(wrapper);\n  return impl ? impl : wrapper;\n}\n\nconst iterInternalSymbol = Symbol(\"internal\");\n\nfunction isArrayIndexPropName(P) {\n  if (typeof P !== \"string\") {\n    return false;\n  }\n\n  const i = P >>> 0;\n\n  if (i === 2 ** 32 - 1) {\n    return false;\n  }\n\n  const s = `${i}`;\n\n  if (P !== s) {\n    return false;\n  }\n\n  return true;\n}\n\nconst byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, \"byteLength\").get;\n\nfunction isArrayBuffer(value) {\n  try {\n    byteLengthGetter.call(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction iteratorResult(_ref, kind) {\n  let [key, value] = _ref;\n  let result;\n\n  switch (kind) {\n    case \"key\":\n      result = key;\n      break;\n\n    case \"value\":\n      result = value;\n      break;\n\n    case \"key+value\":\n      result = [key, value];\n      break;\n  }\n\n  return {\n    value: result,\n    done: false\n  };\n}\n\nconst supportsPropertyIndex = Symbol(\"supports property index\");\nconst supportedPropertyIndices = Symbol(\"supported property indices\");\nconst supportsPropertyName = Symbol(\"supports property name\");\nconst supportedPropertyNames = Symbol(\"supported property names\");\nconst indexedGet = Symbol(\"indexed property get\");\nconst indexedSetNew = Symbol(\"indexed property set new\");\nconst indexedSetExisting = Symbol(\"indexed property set existing\");\nconst namedGet = Symbol(\"named property get\");\nconst namedSetNew = Symbol(\"named property set new\");\nconst namedSetExisting = Symbol(\"named property set existing\");\nconst namedDelete = Symbol(\"named property delete\");\nconst asyncIteratorNext = Symbol(\"async iterator get the next iteration result\");\nconst asyncIteratorReturn = Symbol(\"async iterator return steps\");\nconst asyncIteratorInit = Symbol(\"async iterator initialization steps\");\nconst asyncIteratorEOI = Symbol(\"async iterator end of iteration\");\nmodule.exports = exports = {\n  isObject,\n  hasOwn,\n  define,\n  newObjectInRealm,\n  wrapperSymbol,\n  implSymbol,\n  getSameObject,\n  ctorRegistrySymbol,\n  initCtorRegistry,\n  wrapperForImpl,\n  implForWrapper,\n  tryWrapperForImpl,\n  tryImplForWrapper,\n  iterInternalSymbol,\n  isArrayBuffer,\n  isArrayIndexPropName,\n  supportsPropertyIndex,\n  supportedPropertyIndices,\n  supportsPropertyName,\n  supportedPropertyNames,\n  indexedGet,\n  indexedSetNew,\n  indexedSetExisting,\n  namedGet,\n  namedSetNew,\n  namedSetExisting,\n  namedDelete,\n  asyncIteratorNext,\n  asyncIteratorReturn,\n  asyncIteratorInit,\n  asyncIteratorEOI,\n  iteratorResult\n};","map":{"version":3,"sources":["D:/Barcelparts/node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/utils.js"],"names":["isObject","value","hasOwn","Function","prototype","call","bind","Object","hasOwnProperty","define","target","source","key","Reflect","ownKeys","descriptor","getOwnPropertyDescriptor","defineProperty","TypeError","String","newObjectInRealm","globalObject","object","ctorRegistry","initCtorRegistry","defineProperties","create","getOwnPropertyDescriptors","wrapperSymbol","Symbol","implSymbol","sameObjectCaches","ctorRegistrySymbol","for","AsyncIteratorPrototype","getPrototypeOf","Array","iterator","eval","getSameObject","wrapper","prop","creator","wrapperForImpl","impl","implForWrapper","tryWrapperForImpl","tryImplForWrapper","iterInternalSymbol","isArrayIndexPropName","P","i","s","byteLengthGetter","ArrayBuffer","get","isArrayBuffer","e","iteratorResult","kind","result","done","supportsPropertyIndex","supportedPropertyIndices","supportsPropertyName","supportedPropertyNames","indexedGet","indexedSetNew","indexedSetExisting","namedGet","namedSetNew","namedSetExisting","namedDelete","asyncIteratorNext","asyncIteratorReturn","asyncIteratorInit","asyncIteratorEOI","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\n// Returns \"Type(value) is Object\" in ES terminology.\r\nfunction isObject(value) {\r\n  return (typeof value === \"object\" && value !== null) || typeof value === \"function\";\r\n}\r\n\r\nconst hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);\r\n\r\n// Like `Object.assign`, but using `[[GetOwnProperty]]` and `[[DefineOwnProperty]]`\r\n// instead of `[[Get]]` and `[[Set]]` and only allowing objects\r\nfunction define(target, source) {\r\n  for (const key of Reflect.ownKeys(source)) {\r\n    const descriptor = Reflect.getOwnPropertyDescriptor(source, key);\r\n    if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {\r\n      throw new TypeError(`Cannot redefine property: ${String(key)}`);\r\n    }\r\n  }\r\n}\r\n\r\nfunction newObjectInRealm(globalObject, object) {\r\n  const ctorRegistry = initCtorRegistry(globalObject);\r\n  return Object.defineProperties(\r\n    Object.create(ctorRegistry[\"%Object.prototype%\"]),\r\n    Object.getOwnPropertyDescriptors(object)\r\n  );\r\n}\r\n\r\nconst wrapperSymbol = Symbol(\"wrapper\");\r\nconst implSymbol = Symbol(\"impl\");\r\nconst sameObjectCaches = Symbol(\"SameObject caches\");\r\nconst ctorRegistrySymbol = Symbol.for(\"[webidl2js] constructor registry\");\r\n\r\nconst AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);\r\n\r\nfunction initCtorRegistry(globalObject) {\r\n  if (hasOwn(globalObject, ctorRegistrySymbol)) {\r\n    return globalObject[ctorRegistrySymbol];\r\n  }\r\n\r\n  const ctorRegistry = Object.create(null);\r\n\r\n  // In addition to registering all the WebIDL2JS-generated types in the constructor registry,\r\n  // we also register a few intrinsics that we make use of in generated code, since they are not\r\n  // easy to grab from the globalObject variable.\r\n  ctorRegistry[\"%Object.prototype%\"] = globalObject.Object.prototype;\r\n  ctorRegistry[\"%IteratorPrototype%\"] = Object.getPrototypeOf(\r\n    Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]())\r\n  );\r\n\r\n  try {\r\n    ctorRegistry[\"%AsyncIteratorPrototype%\"] = Object.getPrototypeOf(\r\n      Object.getPrototypeOf(\r\n        globalObject.eval(\"(async function* () {})\").prototype\r\n      )\r\n    );\r\n  } catch {\r\n    ctorRegistry[\"%AsyncIteratorPrototype%\"] = AsyncIteratorPrototype;\r\n  }\r\n\r\n  globalObject[ctorRegistrySymbol] = ctorRegistry;\r\n  return ctorRegistry;\r\n}\r\n\r\nfunction getSameObject(wrapper, prop, creator) {\r\n  if (!wrapper[sameObjectCaches]) {\r\n    wrapper[sameObjectCaches] = Object.create(null);\r\n  }\r\n\r\n  if (prop in wrapper[sameObjectCaches]) {\r\n    return wrapper[sameObjectCaches][prop];\r\n  }\r\n\r\n  wrapper[sameObjectCaches][prop] = creator();\r\n  return wrapper[sameObjectCaches][prop];\r\n}\r\n\r\nfunction wrapperForImpl(impl) {\r\n  return impl ? impl[wrapperSymbol] : null;\r\n}\r\n\r\nfunction implForWrapper(wrapper) {\r\n  return wrapper ? wrapper[implSymbol] : null;\r\n}\r\n\r\nfunction tryWrapperForImpl(impl) {\r\n  const wrapper = wrapperForImpl(impl);\r\n  return wrapper ? wrapper : impl;\r\n}\r\n\r\nfunction tryImplForWrapper(wrapper) {\r\n  const impl = implForWrapper(wrapper);\r\n  return impl ? impl : wrapper;\r\n}\r\n\r\nconst iterInternalSymbol = Symbol(\"internal\");\r\n\r\nfunction isArrayIndexPropName(P) {\r\n  if (typeof P !== \"string\") {\r\n    return false;\r\n  }\r\n  const i = P >>> 0;\r\n  if (i === 2 ** 32 - 1) {\r\n    return false;\r\n  }\r\n  const s = `${i}`;\r\n  if (P !== s) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nconst byteLengthGetter =\r\n    Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, \"byteLength\").get;\r\nfunction isArrayBuffer(value) {\r\n  try {\r\n    byteLengthGetter.call(value);\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction iteratorResult([key, value], kind) {\r\n  let result;\r\n  switch (kind) {\r\n    case \"key\":\r\n      result = key;\r\n      break;\r\n    case \"value\":\r\n      result = value;\r\n      break;\r\n    case \"key+value\":\r\n      result = [key, value];\r\n      break;\r\n  }\r\n  return { value: result, done: false };\r\n}\r\n\r\nconst supportsPropertyIndex = Symbol(\"supports property index\");\r\nconst supportedPropertyIndices = Symbol(\"supported property indices\");\r\nconst supportsPropertyName = Symbol(\"supports property name\");\r\nconst supportedPropertyNames = Symbol(\"supported property names\");\r\nconst indexedGet = Symbol(\"indexed property get\");\r\nconst indexedSetNew = Symbol(\"indexed property set new\");\r\nconst indexedSetExisting = Symbol(\"indexed property set existing\");\r\nconst namedGet = Symbol(\"named property get\");\r\nconst namedSetNew = Symbol(\"named property set new\");\r\nconst namedSetExisting = Symbol(\"named property set existing\");\r\nconst namedDelete = Symbol(\"named property delete\");\r\n\r\nconst asyncIteratorNext = Symbol(\"async iterator get the next iteration result\");\r\nconst asyncIteratorReturn = Symbol(\"async iterator return steps\");\r\nconst asyncIteratorInit = Symbol(\"async iterator initialization steps\");\r\nconst asyncIteratorEOI = Symbol(\"async iterator end of iteration\");\r\n\r\nmodule.exports = exports = {\r\n  isObject,\r\n  hasOwn,\r\n  define,\r\n  newObjectInRealm,\r\n  wrapperSymbol,\r\n  implSymbol,\r\n  getSameObject,\r\n  ctorRegistrySymbol,\r\n  initCtorRegistry,\r\n  wrapperForImpl,\r\n  implForWrapper,\r\n  tryWrapperForImpl,\r\n  tryImplForWrapper,\r\n  iterInternalSymbol,\r\n  isArrayBuffer,\r\n  isArrayIndexPropName,\r\n  supportsPropertyIndex,\r\n  supportedPropertyIndices,\r\n  supportsPropertyName,\r\n  supportedPropertyNames,\r\n  indexedGet,\r\n  indexedSetNew,\r\n  indexedSetExisting,\r\n  namedGet,\r\n  namedSetNew,\r\n  namedSetExisting,\r\n  namedDelete,\r\n  asyncIteratorNext,\r\n  asyncIteratorReturn,\r\n  asyncIteratorInit,\r\n  asyncIteratorEOI,\r\n  iteratorResult\r\n};\r\n"]},"metadata":{},"sourceType":"script"}