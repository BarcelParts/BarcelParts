{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoDBAWS = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst http = require(\"http\");\n\nconst url = require(\"url\");\n\nconst BSON = require(\"../../bson\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst auth_provider_1 = require(\"./auth_provider\");\n\nconst mongo_credentials_1 = require(\"./mongo_credentials\");\n\nconst providers_1 = require(\"./providers\");\n\nconst ASCII_N = 110;\nconst AWS_RELATIVE_URI = 'http://169.254.170.2';\nconst AWS_EC2_URI = 'http://169.254.169.254';\nconst AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';\nconst bsonOptions = {\n  promoteLongs: true,\n  promoteValues: true,\n  promoteBuffers: false,\n  bsonRegExp: false\n};\n\nclass MongoDBAWS extends auth_provider_1.AuthProvider {\n  auth(authContext, callback) {\n    const {\n      connection,\n      credentials\n    } = authContext;\n\n    if (!credentials) {\n      return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n\n    if ('kModuleError' in deps_1.aws4) {\n      return callback(deps_1.aws4['kModuleError']);\n    }\n\n    const {\n      sign\n    } = deps_1.aws4;\n\n    if ((0, utils_1.maxWireVersion)(connection) < 9) {\n      callback(new error_1.MongoCompatibilityError('MONGODB-AWS authentication requires MongoDB version 4.4 or later'));\n      return;\n    }\n\n    if (!credentials.username) {\n      makeTempCredentials(credentials, (err, tempCredentials) => {\n        if (err || !tempCredentials) return callback(err);\n        authContext.credentials = tempCredentials;\n        this.auth(authContext, callback);\n      });\n      return;\n    }\n\n    const accessKeyId = credentials.username;\n    const secretAccessKey = credentials.password;\n    const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN; // If all three defined, include sessionToken, else include username and pass, else no credentials\n\n    const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? {\n      accessKeyId,\n      secretAccessKey,\n      sessionToken\n    } : accessKeyId && secretAccessKey ? {\n      accessKeyId,\n      secretAccessKey\n    } : undefined;\n    const db = credentials.source;\n    crypto.randomBytes(32, (err, nonce) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const saslStart = {\n        saslStart: 1,\n        mechanism: 'MONGODB-AWS',\n        payload: BSON.serialize({\n          r: nonce,\n          p: ASCII_N\n        }, bsonOptions)\n      };\n      connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStart, undefined, (err, res) => {\n        if (err) return callback(err);\n        const serverResponse = BSON.deserialize(res.payload.buffer, bsonOptions);\n        const host = serverResponse.h;\n        const serverNonce = serverResponse.s.buffer;\n\n        if (serverNonce.length !== 64) {\n          callback( // TODO(NODE-3483)\n          new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`));\n          return;\n        }\n\n        if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {\n          // TODO(NODE-3483)\n          callback(new error_1.MongoRuntimeError('Server nonce does not begin with client nonce'));\n          return;\n        }\n\n        if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {\n          // TODO(NODE-3483)\n          callback(new error_1.MongoRuntimeError(`Server returned an invalid host: \"${host}\"`));\n          return;\n        }\n\n        const body = 'Action=GetCallerIdentity&Version=2011-06-15';\n        const options = sign({\n          method: 'POST',\n          host,\n          region: deriveRegion(serverResponse.h),\n          service: 'sts',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Content-Length': body.length,\n            'X-MongoDB-Server-Nonce': serverNonce.toString('base64'),\n            'X-MongoDB-GS2-CB-Flag': 'n'\n          },\n          path: '/',\n          body\n        }, awsCredentials);\n        const payload = {\n          a: options.headers.Authorization,\n          d: options.headers['X-Amz-Date']\n        };\n\n        if (sessionToken) {\n          payload.t = sessionToken;\n        }\n\n        const saslContinue = {\n          saslContinue: 1,\n          conversationId: 1,\n          payload: BSON.serialize(payload, bsonOptions)\n        };\n        connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinue, undefined, callback);\n      });\n    });\n  }\n\n}\n\nexports.MongoDBAWS = MongoDBAWS;\n\nfunction makeTempCredentials(credentials, callback) {\n  function done(creds) {\n    if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {\n      callback(new error_1.MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials'));\n      return;\n    }\n\n    callback(undefined, new mongo_credentials_1.MongoCredentials({\n      username: creds.AccessKeyId,\n      password: creds.SecretAccessKey,\n      source: credentials.source,\n      mechanism: providers_1.AuthMechanism.MONGODB_AWS,\n      mechanismProperties: {\n        AWS_SESSION_TOKEN: creds.Token\n      }\n    }));\n  } // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\n  // is set then drivers MUST assume that it was set by an AWS ECS agent\n\n\n  if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {\n    request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, undefined, (err, res) => {\n      if (err) return callback(err);\n      done(res);\n    });\n    return;\n  } // Otherwise assume we are on an EC2 instance\n  // get a token\n\n\n  request(`${AWS_EC2_URI}/latest/api/token`, {\n    method: 'PUT',\n    json: false,\n    headers: {\n      'X-aws-ec2-metadata-token-ttl-seconds': 30\n    }\n  }, (err, token) => {\n    if (err) return callback(err); // get role name\n\n    request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {\n      json: false,\n      headers: {\n        'X-aws-ec2-metadata-token': token\n      }\n    }, (err, roleName) => {\n      if (err) return callback(err); // get temp credentials\n\n      request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {\n        headers: {\n          'X-aws-ec2-metadata-token': token\n        }\n      }, (err, creds) => {\n        if (err) return callback(err);\n        done(creds);\n      });\n    });\n  });\n}\n\nfunction deriveRegion(host) {\n  const parts = host.split('.');\n\n  if (parts.length === 1 || parts[1] === 'amazonaws') {\n    return 'us-east-1';\n  }\n\n  return parts[1];\n}\n\nfunction request(uri, _options, callback) {\n  const options = Object.assign({\n    method: 'GET',\n    timeout: 10000,\n    json: true\n  }, url.parse(uri), _options);\n  const req = http.request(options, res => {\n    res.setEncoding('utf8');\n    let data = '';\n    res.on('data', d => data += d);\n    res.on('end', () => {\n      if (options.json === false) {\n        callback(undefined, data);\n        return;\n      }\n\n      try {\n        const parsed = JSON.parse(data);\n        callback(undefined, parsed);\n      } catch (err) {\n        // TODO(NODE-3483)\n        callback(new error_1.MongoRuntimeError(`Invalid JSON response: \"${data}\"`));\n      }\n    });\n  });\n  req.on('error', err => callback(err));\n  req.end();\n}","map":{"version":3,"mappings":"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","names":["ASCII_N","AWS_RELATIVE_URI","AWS_EC2_URI","AWS_EC2_PATH","bsonOptions","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","MongoDBAWS","auth_provider_1","auth","authContext","callback","connection","credentials","error_1","deps_1","sign","username","makeTempCredentials","err","tempCredentials","accessKeyId","secretAccessKey","password","sessionToken","mechanismProperties","AWS_SESSION_TOKEN","awsCredentials","undefined","db","source","crypto","randomBytes","nonce","saslStart","mechanism","payload","BSON","serialize","r","p","command","res","serverResponse","deserialize","buffer","host","h","serverNonce","s","length","compare","indexOf","body","options","method","region","deriveRegion","service","headers","toString","path","a","Authorization","d","t","saslContinue","conversationId","exports","done","creds","AccessKeyId","SecretAccessKey","Token","mongo_credentials_1","providers_1","MONGODB_AWS","process","env","AWS_CONTAINER_CREDENTIALS_RELATIVE_URI","request","json","token","roleName","parts","split","uri","_options","Object","assign","timeout","url","parse","req","http","setEncoding","data","on","parsed","JSON","end"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_aws.ts"],"sourcesContent":["import * as crypto from 'crypto';\r\nimport * as http from 'http';\r\nimport * as url from 'url';\r\n\r\nimport type { Binary, BSONSerializeOptions } from '../../bson';\r\nimport * as BSON from '../../bson';\r\nimport { aws4 } from '../../deps';\r\nimport {\r\n  MongoCompatibilityError,\r\n  MongoMissingCredentialsError,\r\n  MongoRuntimeError\r\n} from '../../error';\r\nimport { Callback, maxWireVersion, ns } from '../../utils';\r\nimport { AuthContext, AuthProvider } from './auth_provider';\r\nimport { MongoCredentials } from './mongo_credentials';\r\nimport { AuthMechanism } from './providers';\r\n\r\nconst ASCII_N = 110;\r\nconst AWS_RELATIVE_URI = 'http://169.254.170.2';\r\nconst AWS_EC2_URI = 'http://169.254.169.254';\r\nconst AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';\r\nconst bsonOptions: BSONSerializeOptions = {\r\n  promoteLongs: true,\r\n  promoteValues: true,\r\n  promoteBuffers: false,\r\n  bsonRegExp: false\r\n};\r\n\r\ninterface AWSSaslContinuePayload {\r\n  a: string;\r\n  d: string;\r\n  t?: string;\r\n}\r\n\r\nexport class MongoDBAWS extends AuthProvider {\r\n  override auth(authContext: AuthContext, callback: Callback): void {\r\n    const { connection, credentials } = authContext;\r\n    if (!credentials) {\r\n      return callback(new MongoMissingCredentialsError('AuthContext must provide credentials.'));\r\n    }\r\n\r\n    if ('kModuleError' in aws4) {\r\n      return callback(aws4['kModuleError']);\r\n    }\r\n    const { sign } = aws4;\r\n\r\n    if (maxWireVersion(connection) < 9) {\r\n      callback(\r\n        new MongoCompatibilityError(\r\n          'MONGODB-AWS authentication requires MongoDB version 4.4 or later'\r\n        )\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (!credentials.username) {\r\n      makeTempCredentials(credentials, (err, tempCredentials) => {\r\n        if (err || !tempCredentials) return callback(err);\r\n\r\n        authContext.credentials = tempCredentials;\r\n        this.auth(authContext, callback);\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    const accessKeyId = credentials.username;\r\n    const secretAccessKey = credentials.password;\r\n    const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;\r\n\r\n    // If all three defined, include sessionToken, else include username and pass, else no credentials\r\n    const awsCredentials =\r\n      accessKeyId && secretAccessKey && sessionToken\r\n        ? { accessKeyId, secretAccessKey, sessionToken }\r\n        : accessKeyId && secretAccessKey\r\n        ? { accessKeyId, secretAccessKey }\r\n        : undefined;\r\n\r\n    const db = credentials.source;\r\n    crypto.randomBytes(32, (err, nonce) => {\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      const saslStart = {\r\n        saslStart: 1,\r\n        mechanism: 'MONGODB-AWS',\r\n        payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)\r\n      };\r\n\r\n      connection.command(ns(`${db}.$cmd`), saslStart, undefined, (err, res) => {\r\n        if (err) return callback(err);\r\n\r\n        const serverResponse = BSON.deserialize(res.payload.buffer, bsonOptions) as {\r\n          s: Binary;\r\n          h: string;\r\n        };\r\n        const host = serverResponse.h;\r\n        const serverNonce = serverResponse.s.buffer;\r\n        if (serverNonce.length !== 64) {\r\n          callback(\r\n            // TODO(NODE-3483)\r\n            new MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`)\r\n          );\r\n\r\n          return;\r\n        }\r\n\r\n        if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {\r\n          // TODO(NODE-3483)\r\n          callback(new MongoRuntimeError('Server nonce does not begin with client nonce'));\r\n          return;\r\n        }\r\n\r\n        if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {\r\n          // TODO(NODE-3483)\r\n          callback(new MongoRuntimeError(`Server returned an invalid host: \"${host}\"`));\r\n          return;\r\n        }\r\n\r\n        const body = 'Action=GetCallerIdentity&Version=2011-06-15';\r\n        const options = sign(\r\n          {\r\n            method: 'POST',\r\n            host,\r\n            region: deriveRegion(serverResponse.h),\r\n            service: 'sts',\r\n            headers: {\r\n              'Content-Type': 'application/x-www-form-urlencoded',\r\n              'Content-Length': body.length,\r\n              'X-MongoDB-Server-Nonce': serverNonce.toString('base64'),\r\n              'X-MongoDB-GS2-CB-Flag': 'n'\r\n            },\r\n            path: '/',\r\n            body\r\n          },\r\n          awsCredentials\r\n        );\r\n\r\n        const payload: AWSSaslContinuePayload = {\r\n          a: options.headers.Authorization,\r\n          d: options.headers['X-Amz-Date']\r\n        };\r\n        if (sessionToken) {\r\n          payload.t = sessionToken;\r\n        }\r\n\r\n        const saslContinue = {\r\n          saslContinue: 1,\r\n          conversationId: 1,\r\n          payload: BSON.serialize(payload, bsonOptions)\r\n        };\r\n\r\n        connection.command(ns(`${db}.$cmd`), saslContinue, undefined, callback);\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\ninterface AWSTempCredentials {\r\n  AccessKeyId?: string;\r\n  SecretAccessKey?: string;\r\n  Token?: string;\r\n  RoleArn?: string;\r\n  Expiration?: Date;\r\n}\r\n\r\nfunction makeTempCredentials(credentials: MongoCredentials, callback: Callback<MongoCredentials>) {\r\n  function done(creds: AWSTempCredentials) {\r\n    if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {\r\n      callback(\r\n        new MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials')\r\n      );\r\n      return;\r\n    }\r\n\r\n    callback(\r\n      undefined,\r\n      new MongoCredentials({\r\n        username: creds.AccessKeyId,\r\n        password: creds.SecretAccessKey,\r\n        source: credentials.source,\r\n        mechanism: AuthMechanism.MONGODB_AWS,\r\n        mechanismProperties: {\r\n          AWS_SESSION_TOKEN: creds.Token\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\r\n  // is set then drivers MUST assume that it was set by an AWS ECS agent\r\n  if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {\r\n    request(\r\n      `${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`,\r\n      undefined,\r\n      (err, res) => {\r\n        if (err) return callback(err);\r\n        done(res);\r\n      }\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  // Otherwise assume we are on an EC2 instance\r\n\r\n  // get a token\r\n  request(\r\n    `${AWS_EC2_URI}/latest/api/token`,\r\n    { method: 'PUT', json: false, headers: { 'X-aws-ec2-metadata-token-ttl-seconds': 30 } },\r\n    (err, token) => {\r\n      if (err) return callback(err);\r\n\r\n      // get role name\r\n      request(\r\n        `${AWS_EC2_URI}/${AWS_EC2_PATH}`,\r\n        { json: false, headers: { 'X-aws-ec2-metadata-token': token } },\r\n        (err, roleName) => {\r\n          if (err) return callback(err);\r\n\r\n          // get temp credentials\r\n          request(\r\n            `${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`,\r\n            { headers: { 'X-aws-ec2-metadata-token': token } },\r\n            (err, creds) => {\r\n              if (err) return callback(err);\r\n              done(creds);\r\n            }\r\n          );\r\n        }\r\n      );\r\n    }\r\n  );\r\n}\r\n\r\nfunction deriveRegion(host: string) {\r\n  const parts = host.split('.');\r\n  if (parts.length === 1 || parts[1] === 'amazonaws') {\r\n    return 'us-east-1';\r\n  }\r\n\r\n  return parts[1];\r\n}\r\n\r\ninterface RequestOptions {\r\n  json?: boolean;\r\n  method?: string;\r\n  timeout?: number;\r\n  headers?: http.OutgoingHttpHeaders;\r\n}\r\n\r\nfunction request(uri: string, _options: RequestOptions | undefined, callback: Callback) {\r\n  const options = Object.assign(\r\n    {\r\n      method: 'GET',\r\n      timeout: 10000,\r\n      json: true\r\n    },\r\n    url.parse(uri),\r\n    _options\r\n  );\r\n\r\n  const req = http.request(options, res => {\r\n    res.setEncoding('utf8');\r\n\r\n    let data = '';\r\n    res.on('data', d => (data += d));\r\n    res.on('end', () => {\r\n      if (options.json === false) {\r\n        callback(undefined, data);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        const parsed = JSON.parse(data);\r\n        callback(undefined, parsed);\r\n      } catch (err) {\r\n        // TODO(NODE-3483)\r\n        callback(new MongoRuntimeError(`Invalid JSON response: \"${data}\"`));\r\n      }\r\n    });\r\n  });\r\n\r\n  req.on('error', err => callback(err));\r\n  req.end();\r\n}\r\n"]},"metadata":{},"sourceType":"script"}