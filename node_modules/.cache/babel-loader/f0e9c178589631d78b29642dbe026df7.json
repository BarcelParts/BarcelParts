{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\n\nconst commands_1 = require(\"./commands\");\n\nconst message_stream_1 = require(\"./message_stream\");\n\nconst stream_description_1 = require(\"./stream_description\");\n\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\n\n\nconst kStream = Symbol('stream');\n/** @internal */\n\nconst kQueue = Symbol('queue');\n/** @internal */\n\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\n\nconst kGeneration = Symbol('generation');\n/** @internal */\n\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\n\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\n\nconst kDescription = Symbol('description');\n/** @internal */\n\nconst kHello = Symbol('hello');\n/** @internal */\n\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\n\nconst kFullResult = Symbol('fullResult');\n/** @internal */\n\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\n/** @internal */\n\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    var _a, _b;\n\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = (0, utils_1.now)(); // setup parser stream and message handling\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({ ...options,\n      maxBsonMessageSize: (_b = this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n    this[kDelayedTimeoutId] = null;\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    }); // hook the message stream up to the passed in stream\n\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get hello() {\n    return this[kHello];\n  } // the `connect` method stores the result of the handshake hello on the connection\n\n\n  set hello(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kHello] = response;\n  }\n\n  get serviceId() {\n    var _a;\n\n    return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;\n  }\n\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = (0, utils_1.now)();\n  }\n\n  onError(error) {\n    if (this.closed) {\n      return;\n    }\n\n    this[kStream].destroy(error);\n    this.closed = true;\n\n    for (const op of this[kQueue].values()) {\n      op.cb(error);\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onClose() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    const message = `connection ${this.id} to ${this.address} closed`;\n\n    for (const op of this[kQueue].values()) {\n      op.cb(new error_1.MongoNetworkError(message));\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onTimeout() {\n    if (this.closed) {\n      return;\n    }\n\n    this[kDelayedTimeoutId] = setTimeout(() => {\n      this[kStream].destroy();\n      this.closed = true;\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n\n      for (const op of this[kQueue].values()) {\n        op.cb(new error_1.MongoNetworkTimeoutError(message, {\n          beforeHandshake\n        }));\n      }\n\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n\n    if (delayedTimeoutId != null) {\n      clearTimeout(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    } // always emit the message, in case we are streaming\n\n\n    this.emit('message', message);\n    const operationDescription = this[kQueue].get(message.responseTo);\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    this[kQueue].delete(message.responseTo);\n\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      this[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      this[kStream].setTimeout(this.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        (0, sessions_1.updateSessionFromResponse)(session, document);\n      }\n\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        force: false\n      };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n\n  command(ns, cmd, options, callback) {\n    if (!(ns instanceof utils_1.MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n\n    const readPreference = (0, shared_1.getReadPreference)(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = (0, sessions_1.applySession)(session, finalCmd, options);\n\n      if (err) {\n        return callback(err);\n      }\n    } // if we have a known cluster time, gossip it\n\n\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions = Object.assign({\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n\n  query(ns, cmd, options, callback) {\n    var _a;\n\n    const isExplain = cmd.$explain != null;\n    const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n\n    if (limit && (limit < 0 || limit !== 0 && limit < batchSize || limit > 0 && batchSize === 0)) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n\n    const queryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      secondaryOk: readPreference.secondaryOk()\n    };\n\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n\n    const query = new commands_1.Query(ns.toString(), cmd, queryOptions);\n\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n\n    write(this, query, {\n      [kFullResult]: true,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    }, (err, result) => {\n      if (err || !result) return callback(err, result);\n\n      if (isExplain && result.documents && result.documents[0]) {\n        return callback(undefined, result.documents[0]);\n      }\n\n      callback(undefined, result);\n    });\n  }\n\n  getMore(ns, cursorId, options, callback) {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = (0, utils_1.maxWireVersion)(this);\n\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, {\n        numberToReturn: options.batchSize\n      });\n      const queryOptions = (0, shared_1.applyCommonQueryOptions)({}, Object.assign(options, { ...(0, bson_1.pluckBSONSerializeOptions)(options)\n      }));\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, {\n          cursor: {\n            id: response.cursorId,\n            nextBatch: response.documents\n          }\n        });\n      });\n      return;\n    }\n\n    const getMoreCmd = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      getMoreCmd.comment = options.comment;\n    }\n\n    const commandOptions = Object.assign({\n      returnFieldSelector: null,\n      documentsReturnedIn: 'nextBatch'\n    }, options);\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n\n  killCursors(ns, cursorIds, options, callback) {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n\n    if ((0, utils_1.maxWireVersion)(this) < 4) {\n      try {\n        write(this, new commands_1.KillCursor(ns.toString(), cursorIds), {\n          noResponse: true,\n          ...options\n        }, callback);\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(ns, {\n      killCursors: ns.collection,\n      cursors: cursorIds\n    }, {\n      [kFullResult]: true,\n      ...options\n    }, (err, response) => {\n      if (err || !response) return callback(err);\n\n      if (response.cursorNotFound) {\n        return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n      }\n\n      if (!Array.isArray(response.documents) || response.documents.length === 0) {\n        return callback( // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n      }\n\n      callback(undefined, response.documents[0]);\n    });\n  }\n\n}\n\nexports.Connection = Connection;\n/** @event */\n\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\n\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\n\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\n\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\n\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\n\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\n\nConnection.PINNED = constants_1.PINNED;\n/** @event */\n\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\n\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n\n\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n\n}\n\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\n\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nexports.hasSessionSupport = hasSessionSupport;\n\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return (0, utils_1.uuidV4)().toString('hex');\n}\n\nfunction write(conn, command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options !== null && options !== void 0 ? options : {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"mappings":"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","names":["kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kHello","kAutoEncrypter","kFullResult","kDelayedTimeoutId","Connection","mongo_types_1","constructor","stream","options","id","address","streamIdentifier","socketTimeoutMS","_a","monitorCommands","serverApi","closed","destroyed","stream_description_1","generation","Map","message_stream_1","maxBsonMessageSize","hello","_b","on","message","onMessage","error","onError","onClose","onTimeout","pipe","description","response","receiveResponse","Object","freeze","serviceId","loadBalanced","idleTime","clusterTime","markAvailable","destroy","op","values","cb","clear","emit","CLOSE","error_1","setTimeout","beforeHandshake","unref","delayedTimeoutId","clearTimeout","operationDescription","get","responseTo","callback","delete","moreToCome","set","requestId","socketTimeoutOverride","parse","err","documents","document","session","$clusterTime","CLUSTER_TIME_RECEIVED","command","writeConcernError","ok","$err","errmsg","code","undefined","fullResult","force","removeAllListeners","PINNED","UNPINNED","assign","end","ns","cmd","utils_1","readPreference","shouldUseOpMsg","supportsOpMsg","finalCmd","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","hasSessionSupport","greaterThan","mode","$query","$readPreference","toJSON","commandOptions","numberToSkip","numberToReturn","checkKeys","secondaryOk","cmdNs","db","commands_1","write","query","isExplain","$explain","read_preference_1","primary","batchSize","limit","skip","Math","abs","queryOptions","pre32Limit","projection","returnFieldSelector","toString","tailable","oplogReplay","timeout","noCursorTimeout","awaitData","partial","result","getMore","cursorId","wireVersion","getMoreOp","cursor","nextBatch","getMoreCmd","collection","maxAwaitTimeMS","maxTimeMS","comment","documentsReturnedIn","killCursors","cursorIds","Array","isArray","noResponse","cursors","cursorNotFound","length","exports","constants_1","CryptoConnection","autoEncrypter","serverWireVersion","encrypt","encrypted","decrypt","conn","logicalSessionTimeoutMinutes","__nodejs_mock_server__","proxyHost","hostAddress","remoteAddress","remotePort","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","enableUtf8Validation","raw","started","compressor","agreedCompressor","zlibCompressionLevel","COMMAND_STARTED","command_monitoring_events_1","reply","COMMAND_FAILED","COMMAND_SUCCEEDED","writeCommand","e"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\cmap\\connection.ts"],"sourcesContent":["import { BSONSerializeOptions, Document, Long, ObjectId, pluckBSONSerializeOptions } from '../bson';\r\nimport {\r\n  CLOSE,\r\n  CLUSTER_TIME_RECEIVED,\r\n  COMMAND_FAILED,\r\n  COMMAND_STARTED,\r\n  COMMAND_SUCCEEDED,\r\n  MESSAGE,\r\n  PINNED,\r\n  UNPINNED\r\n} from '../constants';\r\nimport type { AutoEncrypter } from '../deps';\r\nimport {\r\n  MongoCompatibilityError,\r\n  MongoMissingDependencyError,\r\n  MongoNetworkError,\r\n  MongoNetworkTimeoutError,\r\n  MongoRuntimeError,\r\n  MongoServerError,\r\n  MongoWriteConcernError\r\n} from '../error';\r\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\r\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\r\nimport { ReadPreference, ReadPreferenceLike } from '../read_preference';\r\nimport { applySession, ClientSession, updateSessionFromResponse } from '../sessions';\r\nimport {\r\n  calculateDurationInMs,\r\n  Callback,\r\n  ClientMetadata,\r\n  HostAddress,\r\n  maxWireVersion,\r\n  MongoDBNamespace,\r\n  now,\r\n  uuidV4\r\n} from '../utils';\r\nimport type { WriteConcern } from '../write_concern';\r\nimport type { MongoCredentials } from './auth/mongo_credentials';\r\nimport {\r\n  CommandFailedEvent,\r\n  CommandStartedEvent,\r\n  CommandSucceededEvent\r\n} from './command_monitoring_events';\r\nimport {\r\n  BinMsg,\r\n  GetMore,\r\n  KillCursor,\r\n  Msg,\r\n  OpQueryOptions,\r\n  Query,\r\n  Response,\r\n  WriteProtocolMessageType\r\n} from './commands';\r\nimport type { Stream } from './connect';\r\nimport { MessageStream, OperationDescription } from './message_stream';\r\nimport { StreamDescription, StreamDescriptionOptions } from './stream_description';\r\nimport { applyCommonQueryOptions, getReadPreference, isSharded } from './wire_protocol/shared';\r\n\r\n/** @internal */\r\nconst kStream = Symbol('stream');\r\n/** @internal */\r\nconst kQueue = Symbol('queue');\r\n/** @internal */\r\nconst kMessageStream = Symbol('messageStream');\r\n/** @internal */\r\nconst kGeneration = Symbol('generation');\r\n/** @internal */\r\nconst kLastUseTime = Symbol('lastUseTime');\r\n/** @internal */\r\nconst kClusterTime = Symbol('clusterTime');\r\n/** @internal */\r\nconst kDescription = Symbol('description');\r\n/** @internal */\r\nconst kHello = Symbol('hello');\r\n/** @internal */\r\nconst kAutoEncrypter = Symbol('autoEncrypter');\r\n/** @internal */\r\nconst kFullResult = Symbol('fullResult');\r\n/** @internal */\r\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\r\n\r\n/** @internal */\r\nexport interface QueryOptions extends BSONSerializeOptions {\r\n  readPreference: ReadPreference;\r\n  documentsReturnedIn?: string;\r\n  batchSize?: number;\r\n  limit?: number;\r\n  skip?: number;\r\n  projection?: Document;\r\n  tailable?: boolean;\r\n  awaitData?: boolean;\r\n  noCursorTimeout?: boolean;\r\n  /** @deprecated use `noCursorTimeout` instead */\r\n  timeout?: boolean;\r\n  partial?: boolean;\r\n  oplogReplay?: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport interface CommandOptions extends BSONSerializeOptions {\r\n  command?: boolean;\r\n  secondaryOk?: boolean;\r\n  /** Specify read preference if command supports it */\r\n  readPreference?: ReadPreferenceLike;\r\n  raw?: boolean;\r\n  monitoring?: boolean;\r\n  [kFullResult]?: boolean;\r\n  socketTimeoutMS?: number;\r\n  /** Session to use for the operation */\r\n  session?: ClientSession;\r\n  documentsReturnedIn?: string;\r\n  noResponse?: boolean;\r\n  omitReadPreference?: boolean;\r\n\r\n  // TODO(NODE-2802): Currently the CommandOptions take a property willRetryWrite which is a hint\r\n  // from executeOperation that the txnNum should be applied to this command.\r\n  // Applying a session to a command should happen as part of command construction,\r\n  // most likely in the CommandOperation#executeCommand method, where we have access to\r\n  // the details we need to determine if a txnNum should also be applied.\r\n  willRetryWrite?: boolean;\r\n\r\n  writeConcern?: WriteConcern;\r\n}\r\n\r\n/** @internal */\r\nexport interface GetMoreOptions extends CommandOptions {\r\n  batchSize?: number;\r\n  maxTimeMS?: number;\r\n  maxAwaitTimeMS?: number;\r\n  /**\r\n   * Comment to apply to the operation.\r\n   *\r\n   * In server versions pre-4.4, 'comment' must be string.  A server\r\n   * error will be thrown if any other type is provided.\r\n   *\r\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\r\n   */\r\n  comment?: unknown;\r\n}\r\n\r\n/** @public */\r\nexport interface ProxyOptions {\r\n  proxyHost?: string;\r\n  proxyPort?: number;\r\n  proxyUsername?: string;\r\n  proxyPassword?: string;\r\n}\r\n\r\n/** @public */\r\nexport interface ConnectionOptions\r\n  extends SupportedNodeConnectionOptions,\r\n    StreamDescriptionOptions,\r\n    ProxyOptions {\r\n  // Internal creation info\r\n  id: number | '<monitor>';\r\n  generation: number;\r\n  hostAddress: HostAddress;\r\n  // Settings\r\n  autoEncrypter?: AutoEncrypter;\r\n  serverApi?: ServerApi;\r\n  monitorCommands: boolean;\r\n  /** @internal */\r\n  connectionType?: typeof Connection;\r\n  credentials?: MongoCredentials;\r\n  connectTimeoutMS?: number;\r\n  tls: boolean;\r\n  keepAlive?: boolean;\r\n  keepAliveInitialDelay?: number;\r\n  noDelay?: boolean;\r\n  socketTimeoutMS?: number;\r\n  cancellationToken?: CancellationToken;\r\n\r\n  metadata: ClientMetadata;\r\n}\r\n\r\n/** @public */\r\nexport interface DestroyOptions {\r\n  /** Force the destruction. */\r\n  force?: boolean;\r\n}\r\n\r\n/** @public */\r\nexport type ConnectionEvents = {\r\n  commandStarted(event: CommandStartedEvent): void;\r\n  commandSucceeded(event: CommandSucceededEvent): void;\r\n  commandFailed(event: CommandFailedEvent): void;\r\n  clusterTimeReceived(clusterTime: Document): void;\r\n  close(): void;\r\n  message(message: any): void;\r\n  pinned(pinType: string): void;\r\n  unpinned(pinType: string): void;\r\n};\r\n\r\n/** @internal */\r\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\r\n  id: number | '<monitor>';\r\n  address: string;\r\n  socketTimeoutMS: number;\r\n  monitorCommands: boolean;\r\n  closed: boolean;\r\n  destroyed: boolean;\r\n  lastHelloMS?: number;\r\n  serverApi?: ServerApi;\r\n  helloOk?: boolean;\r\n\r\n  /**@internal */\r\n  [kDelayedTimeoutId]: NodeJS.Timeout | null;\r\n  /** @internal */\r\n  [kDescription]: StreamDescription;\r\n  /** @internal */\r\n  [kGeneration]: number;\r\n  /** @internal */\r\n  [kLastUseTime]: number;\r\n  /** @internal */\r\n  [kQueue]: Map<number, OperationDescription>;\r\n  /** @internal */\r\n  [kMessageStream]: MessageStream;\r\n  /** @internal */\r\n  [kStream]: Stream;\r\n  /** @internal */\r\n  [kHello]: Document | null;\r\n  /** @internal */\r\n  [kClusterTime]: Document | null;\r\n\r\n  /** @event */\r\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\r\n  /** @event */\r\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\r\n  /** @event */\r\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\r\n  /** @event */\r\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\r\n  /** @event */\r\n  static readonly CLOSE = CLOSE;\r\n  /** @event */\r\n  static readonly MESSAGE = MESSAGE;\r\n  /** @event */\r\n  static readonly PINNED = PINNED;\r\n  /** @event */\r\n  static readonly UNPINNED = UNPINNED;\r\n\r\n  constructor(stream: Stream, options: ConnectionOptions) {\r\n    super();\r\n    this.id = options.id;\r\n    this.address = streamIdentifier(stream, options);\r\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\r\n    this.monitorCommands = options.monitorCommands;\r\n    this.serverApi = options.serverApi;\r\n    this.closed = false;\r\n    this.destroyed = false;\r\n    this[kHello] = null;\r\n    this[kClusterTime] = null;\r\n\r\n    this[kDescription] = new StreamDescription(this.address, options);\r\n    this[kGeneration] = options.generation;\r\n    this[kLastUseTime] = now();\r\n\r\n    // setup parser stream and message handling\r\n    this[kQueue] = new Map();\r\n    this[kMessageStream] = new MessageStream({\r\n      ...options,\r\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\r\n    });\r\n    this[kStream] = stream;\r\n\r\n    this[kDelayedTimeoutId] = null;\r\n\r\n    this[kMessageStream].on('message', message => this.onMessage(message));\r\n    this[kMessageStream].on('error', error => this.onError(error));\r\n    this[kStream].on('close', () => this.onClose());\r\n    this[kStream].on('timeout', () => this.onTimeout());\r\n    this[kStream].on('error', () => {\r\n      /* ignore errors, listen to `close` instead */\r\n    });\r\n\r\n    // hook the message stream up to the passed in stream\r\n    this[kStream].pipe(this[kMessageStream]);\r\n    this[kMessageStream].pipe(this[kStream]);\r\n  }\r\n\r\n  get description(): StreamDescription {\r\n    return this[kDescription];\r\n  }\r\n\r\n  get hello(): Document | null {\r\n    return this[kHello];\r\n  }\r\n\r\n  // the `connect` method stores the result of the handshake hello on the connection\r\n  set hello(response: Document | null) {\r\n    this[kDescription].receiveResponse(response);\r\n    this[kDescription] = Object.freeze(this[kDescription]);\r\n\r\n    // TODO: remove this, and only use the `StreamDescription` in the future\r\n    this[kHello] = response;\r\n  }\r\n\r\n  get serviceId(): ObjectId | undefined {\r\n    return this.hello?.serviceId;\r\n  }\r\n\r\n  get loadBalanced(): boolean {\r\n    return this.description.loadBalanced;\r\n  }\r\n\r\n  get generation(): number {\r\n    return this[kGeneration] || 0;\r\n  }\r\n\r\n  set generation(generation: number) {\r\n    this[kGeneration] = generation;\r\n  }\r\n\r\n  get idleTime(): number {\r\n    return calculateDurationInMs(this[kLastUseTime]);\r\n  }\r\n\r\n  get clusterTime(): Document | null {\r\n    return this[kClusterTime];\r\n  }\r\n\r\n  get stream(): Stream {\r\n    return this[kStream];\r\n  }\r\n\r\n  markAvailable(): void {\r\n    this[kLastUseTime] = now();\r\n  }\r\n\r\n  onError(error: Error) {\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    this[kStream].destroy(error);\r\n\r\n    this.closed = true;\r\n\r\n    for (const op of this[kQueue].values()) {\r\n      op.cb(error);\r\n    }\r\n\r\n    this[kQueue].clear();\r\n    this.emit(Connection.CLOSE);\r\n  }\r\n\r\n  onClose() {\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    this.closed = true;\r\n\r\n    const message = `connection ${this.id} to ${this.address} closed`;\r\n    for (const op of this[kQueue].values()) {\r\n      op.cb(new MongoNetworkError(message));\r\n    }\r\n\r\n    this[kQueue].clear();\r\n    this.emit(Connection.CLOSE);\r\n  }\r\n\r\n  onTimeout() {\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    this[kDelayedTimeoutId] = setTimeout(() => {\r\n      this[kStream].destroy();\r\n\r\n      this.closed = true;\r\n\r\n      const message = `connection ${this.id} to ${this.address} timed out`;\r\n      const beforeHandshake = this.hello == null;\r\n      for (const op of this[kQueue].values()) {\r\n        op.cb(new MongoNetworkTimeoutError(message, { beforeHandshake }));\r\n      }\r\n\r\n      this[kQueue].clear();\r\n      this.emit(Connection.CLOSE);\r\n    }, 1).unref(); // No need for this timer to hold the event loop open\r\n  }\r\n\r\n  onMessage(message: BinMsg | Response) {\r\n    const delayedTimeoutId = this[kDelayedTimeoutId];\r\n    if (delayedTimeoutId != null) {\r\n      clearTimeout(delayedTimeoutId);\r\n      this[kDelayedTimeoutId] = null;\r\n    }\r\n\r\n    // always emit the message, in case we are streaming\r\n    this.emit('message', message);\r\n    const operationDescription = this[kQueue].get(message.responseTo);\r\n    if (!operationDescription) {\r\n      return;\r\n    }\r\n\r\n    const callback = operationDescription.cb;\r\n\r\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\r\n    // track response, however the server currently synthetically produces remote requests\r\n    // making the `responseTo` change on each response\r\n    this[kQueue].delete(message.responseTo);\r\n    if ('moreToCome' in message && message.moreToCome) {\r\n      // requeue the callback for next synthetic request\r\n      this[kQueue].set(message.requestId, operationDescription);\r\n    } else if (operationDescription.socketTimeoutOverride) {\r\n      this[kStream].setTimeout(this.socketTimeoutMS);\r\n    }\r\n\r\n    try {\r\n      // Pass in the entire description because it has BSON parsing options\r\n      message.parse(operationDescription);\r\n    } catch (err) {\r\n      // If this error is generated by our own code, it will already have the correct class applied\r\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\r\n      // in either case, it should not be wrapped\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (message.documents[0]) {\r\n      const document: Document = message.documents[0];\r\n      const session = operationDescription.session;\r\n      if (session) {\r\n        updateSessionFromResponse(session, document);\r\n      }\r\n\r\n      if (document.$clusterTime) {\r\n        this[kClusterTime] = document.$clusterTime;\r\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\r\n      }\r\n\r\n      if (operationDescription.command) {\r\n        if (document.writeConcernError) {\r\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\r\n          return;\r\n        }\r\n\r\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\r\n          callback(new MongoServerError(document));\r\n          return;\r\n        }\r\n      } else {\r\n        // Pre 3.2 support\r\n        if (document.ok === 0 || document.$err || document.errmsg) {\r\n          callback(new MongoServerError(document));\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\r\n  }\r\n\r\n  destroy(options?: DestroyOptions, callback?: Callback): void {\r\n    if (typeof options === 'function') {\r\n      callback = options;\r\n      options = { force: false };\r\n    }\r\n\r\n    this.removeAllListeners(Connection.PINNED);\r\n    this.removeAllListeners(Connection.UNPINNED);\r\n\r\n    options = Object.assign({ force: false }, options);\r\n    if (this[kStream] == null || this.destroyed) {\r\n      this.destroyed = true;\r\n      if (typeof callback === 'function') {\r\n        callback();\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (options.force) {\r\n      this[kStream].destroy();\r\n      this.destroyed = true;\r\n      if (typeof callback === 'function') {\r\n        callback();\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    this[kStream].end(() => {\r\n      this.destroyed = true;\r\n      if (typeof callback === 'function') {\r\n        callback();\r\n      }\r\n    });\r\n  }\r\n\r\n  command(\r\n    ns: MongoDBNamespace,\r\n    cmd: Document,\r\n    options: CommandOptions | undefined,\r\n    callback: Callback\r\n  ): void {\r\n    if (!(ns instanceof MongoDBNamespace)) {\r\n      // TODO(NODE-3483): Replace this with a MongoCommandError\r\n      throw new MongoRuntimeError('Must provide a MongoDBNamespace instance');\r\n    }\r\n\r\n    const readPreference = getReadPreference(cmd, options);\r\n    const shouldUseOpMsg = supportsOpMsg(this);\r\n    const session = options?.session;\r\n\r\n    let clusterTime = this.clusterTime;\r\n    let finalCmd = Object.assign({}, cmd);\r\n\r\n    if (this.serverApi) {\r\n      const { version, strict, deprecationErrors } = this.serverApi;\r\n      finalCmd.apiVersion = version;\r\n      if (strict != null) finalCmd.apiStrict = strict;\r\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\r\n    }\r\n\r\n    if (hasSessionSupport(this) && session) {\r\n      if (\r\n        session.clusterTime &&\r\n        clusterTime &&\r\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\r\n      ) {\r\n        clusterTime = session.clusterTime;\r\n      }\r\n\r\n      const err = applySession(session, finalCmd, options as CommandOptions);\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n    }\r\n\r\n    // if we have a known cluster time, gossip it\r\n    if (clusterTime) {\r\n      finalCmd.$clusterTime = clusterTime;\r\n    }\r\n\r\n    if (isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\r\n      finalCmd = {\r\n        $query: finalCmd,\r\n        $readPreference: readPreference.toJSON()\r\n      };\r\n    }\r\n\r\n    const commandOptions: Document = Object.assign(\r\n      {\r\n        command: true,\r\n        numberToSkip: 0,\r\n        numberToReturn: -1,\r\n        checkKeys: false,\r\n        // This value is not overridable\r\n        secondaryOk: readPreference.secondaryOk()\r\n      },\r\n      options\r\n    );\r\n\r\n    const cmdNs = `${ns.db}.$cmd`;\r\n    const message = shouldUseOpMsg\r\n      ? new Msg(cmdNs, finalCmd, commandOptions)\r\n      : new Query(cmdNs, finalCmd, commandOptions);\r\n\r\n    try {\r\n      write(this, message, commandOptions, callback);\r\n    } catch (err) {\r\n      callback(err);\r\n    }\r\n  }\r\n\r\n  query(ns: MongoDBNamespace, cmd: Document, options: QueryOptions, callback: Callback): void {\r\n    const isExplain = cmd.$explain != null;\r\n    const readPreference = options.readPreference ?? ReadPreference.primary;\r\n    const batchSize = options.batchSize || 0;\r\n    const limit = options.limit;\r\n    const numberToSkip = options.skip || 0;\r\n    let numberToReturn = 0;\r\n    if (\r\n      limit &&\r\n      (limit < 0 || (limit !== 0 && limit < batchSize) || (limit > 0 && batchSize === 0))\r\n    ) {\r\n      numberToReturn = limit;\r\n    } else {\r\n      numberToReturn = batchSize;\r\n    }\r\n\r\n    if (isExplain) {\r\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\r\n      // nToReturn > 0 will give explain results equivalent to limit(0)\r\n      numberToReturn = -Math.abs(limit || 0);\r\n    }\r\n\r\n    const queryOptions: OpQueryOptions = {\r\n      numberToSkip,\r\n      numberToReturn,\r\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\r\n      checkKeys: false,\r\n      secondaryOk: readPreference.secondaryOk()\r\n    };\r\n\r\n    if (options.projection) {\r\n      queryOptions.returnFieldSelector = options.projection;\r\n    }\r\n\r\n    const query = new Query(ns.toString(), cmd, queryOptions);\r\n    if (typeof options.tailable === 'boolean') {\r\n      query.tailable = options.tailable;\r\n    }\r\n\r\n    if (typeof options.oplogReplay === 'boolean') {\r\n      query.oplogReplay = options.oplogReplay;\r\n    }\r\n\r\n    if (typeof options.timeout === 'boolean') {\r\n      query.noCursorTimeout = !options.timeout;\r\n    } else if (typeof options.noCursorTimeout === 'boolean') {\r\n      query.noCursorTimeout = options.noCursorTimeout;\r\n    }\r\n\r\n    if (typeof options.awaitData === 'boolean') {\r\n      query.awaitData = options.awaitData;\r\n    }\r\n\r\n    if (typeof options.partial === 'boolean') {\r\n      query.partial = options.partial;\r\n    }\r\n\r\n    write(\r\n      this,\r\n      query,\r\n      { [kFullResult]: true, ...pluckBSONSerializeOptions(options) },\r\n      (err, result) => {\r\n        if (err || !result) return callback(err, result);\r\n        if (isExplain && result.documents && result.documents[0]) {\r\n          return callback(undefined, result.documents[0]);\r\n        }\r\n\r\n        callback(undefined, result);\r\n      }\r\n    );\r\n  }\r\n\r\n  getMore(\r\n    ns: MongoDBNamespace,\r\n    cursorId: Long,\r\n    options: GetMoreOptions,\r\n    callback: Callback<Document>\r\n  ): void {\r\n    const fullResult = !!options[kFullResult];\r\n    const wireVersion = maxWireVersion(this);\r\n    if (!cursorId) {\r\n      // TODO(NODE-3483): Replace this with a MongoCommandError\r\n      callback(new MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\r\n      return;\r\n    }\r\n\r\n    if (wireVersion < 4) {\r\n      const getMoreOp = new GetMore(ns.toString(), cursorId, { numberToReturn: options.batchSize });\r\n      const queryOptions = applyCommonQueryOptions(\r\n        {},\r\n        Object.assign(options, { ...pluckBSONSerializeOptions(options) })\r\n      );\r\n\r\n      queryOptions[kFullResult] = true;\r\n      queryOptions.command = true;\r\n      write(this, getMoreOp, queryOptions, (err, response) => {\r\n        if (fullResult) return callback(err, response);\r\n        if (err) return callback(err);\r\n        callback(undefined, { cursor: { id: response.cursorId, nextBatch: response.documents } });\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    const getMoreCmd: Document = {\r\n      getMore: cursorId,\r\n      collection: ns.collection\r\n    };\r\n\r\n    if (typeof options.batchSize === 'number') {\r\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\r\n    }\r\n\r\n    if (typeof options.maxAwaitTimeMS === 'number') {\r\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\r\n    }\r\n    // we check for undefined specifically here to allow falsy values\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    if (options.comment !== undefined) {\r\n      getMoreCmd.comment = options.comment;\r\n    }\r\n\r\n    const commandOptions = Object.assign(\r\n      {\r\n        returnFieldSelector: null,\r\n        documentsReturnedIn: 'nextBatch'\r\n      },\r\n      options\r\n    );\r\n\r\n    this.command(ns, getMoreCmd, commandOptions, callback);\r\n  }\r\n\r\n  killCursors(\r\n    ns: MongoDBNamespace,\r\n    cursorIds: Long[],\r\n    options: CommandOptions,\r\n    callback: Callback\r\n  ): void {\r\n    if (!cursorIds || !Array.isArray(cursorIds)) {\r\n      // TODO(NODE-3483): Replace this with a MongoCommandError\r\n      throw new MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\r\n    }\r\n\r\n    if (maxWireVersion(this) < 4) {\r\n      try {\r\n        write(\r\n          this,\r\n          new KillCursor(ns.toString(), cursorIds),\r\n          { noResponse: true, ...options },\r\n          callback\r\n        );\r\n      } catch (err) {\r\n        callback(err);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    this.command(\r\n      ns,\r\n      { killCursors: ns.collection, cursors: cursorIds },\r\n      { [kFullResult]: true, ...options },\r\n      (err, response) => {\r\n        if (err || !response) return callback(err);\r\n        if (response.cursorNotFound) {\r\n          return callback(new MongoNetworkError('cursor killed or timed out'), null);\r\n        }\r\n\r\n        if (!Array.isArray(response.documents) || response.documents.length === 0) {\r\n          return callback(\r\n            // TODO(NODE-3483)\r\n            new MongoRuntimeError(\r\n              `invalid killCursors result returned for cursor id ${cursorIds[0]}`\r\n            )\r\n          );\r\n        }\r\n\r\n        callback(undefined, response.documents[0]);\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class CryptoConnection extends Connection {\r\n  /** @internal */\r\n  [kAutoEncrypter]?: AutoEncrypter;\r\n\r\n  constructor(stream: Stream, options: ConnectionOptions) {\r\n    super(stream, options);\r\n    this[kAutoEncrypter] = options.autoEncrypter;\r\n  }\r\n\r\n  /** @internal @override */\r\n  override command(\r\n    ns: MongoDBNamespace,\r\n    cmd: Document,\r\n    options: CommandOptions,\r\n    callback: Callback\r\n  ): void {\r\n    const autoEncrypter = this[kAutoEncrypter];\r\n    if (!autoEncrypter) {\r\n      return callback(new MongoMissingDependencyError('No AutoEncrypter available for encryption'));\r\n    }\r\n\r\n    const serverWireVersion = maxWireVersion(this);\r\n    if (serverWireVersion === 0) {\r\n      // This means the initial handshake hasn't happened yet\r\n      return super.command(ns, cmd, options, callback);\r\n    }\r\n\r\n    if (serverWireVersion < 8) {\r\n      callback(\r\n        new MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2')\r\n      );\r\n      return;\r\n    }\r\n\r\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\r\n      if (err || encrypted == null) {\r\n        callback(err, null);\r\n        return;\r\n      }\r\n\r\n      super.command(ns, encrypted, options, (err, response) => {\r\n        if (err || response == null) {\r\n          callback(err, response);\r\n          return;\r\n        }\r\n\r\n        autoEncrypter.decrypt(response, options, callback);\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport function hasSessionSupport(conn: Connection): boolean {\r\n  const description = conn.description;\r\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\r\n}\r\n\r\nfunction supportsOpMsg(conn: Connection) {\r\n  const description = conn.description;\r\n  if (description == null) {\r\n    return false;\r\n  }\r\n\r\n  return maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\r\n}\r\n\r\nfunction streamIdentifier(stream: Stream, options: ConnectionOptions): string {\r\n  if (options.proxyHost) {\r\n    // If proxy options are specified, the properties of `stream` itself\r\n    // will not accurately reflect what endpoint this is connected to.\r\n    return options.hostAddress.toString();\r\n  }\r\n\r\n  if (typeof stream.address === 'function') {\r\n    return `${stream.remoteAddress}:${stream.remotePort}`;\r\n  }\r\n\r\n  return uuidV4().toString('hex');\r\n}\r\n\r\nfunction write(\r\n  conn: Connection,\r\n  command: WriteProtocolMessageType,\r\n  options: CommandOptions,\r\n  callback: Callback\r\n) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n  }\r\n\r\n  options = options ?? {};\r\n  const operationDescription: OperationDescription = {\r\n    requestId: command.requestId,\r\n    cb: callback,\r\n    session: options.session,\r\n    fullResult: !!options[kFullResult],\r\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\r\n    documentsReturnedIn: options.documentsReturnedIn,\r\n    command: !!options.command,\r\n\r\n    // for BSON parsing\r\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\r\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\r\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\r\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\r\n    enableUtf8Validation:\r\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\r\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\r\n    started: 0\r\n  };\r\n\r\n  if (conn[kDescription] && conn[kDescription].compressor) {\r\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\r\n\r\n    if (conn[kDescription].zlibCompressionLevel) {\r\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\r\n    }\r\n  }\r\n\r\n  if (typeof options.socketTimeoutMS === 'number') {\r\n    operationDescription.socketTimeoutOverride = true;\r\n    conn[kStream].setTimeout(options.socketTimeoutMS);\r\n  }\r\n\r\n  // if command monitoring is enabled we need to modify the callback here\r\n  if (conn.monitorCommands) {\r\n    conn.emit(Connection.COMMAND_STARTED, new CommandStartedEvent(conn, command));\r\n\r\n    operationDescription.started = now();\r\n    operationDescription.cb = (err, reply) => {\r\n      if (err) {\r\n        conn.emit(\r\n          Connection.COMMAND_FAILED,\r\n          new CommandFailedEvent(conn, command, err, operationDescription.started)\r\n        );\r\n      } else {\r\n        if (reply && (reply.ok === 0 || reply.$err)) {\r\n          conn.emit(\r\n            Connection.COMMAND_FAILED,\r\n            new CommandFailedEvent(conn, command, reply, operationDescription.started)\r\n          );\r\n        } else {\r\n          conn.emit(\r\n            Connection.COMMAND_SUCCEEDED,\r\n            new CommandSucceededEvent(conn, command, reply, operationDescription.started)\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        callback(err, reply);\r\n      }\r\n    };\r\n  }\r\n\r\n  if (!operationDescription.noResponse) {\r\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\r\n  }\r\n\r\n  try {\r\n    conn[kMessageStream].writeCommand(command, operationDescription);\r\n  } catch (e) {\r\n    if (!operationDescription.noResponse) {\r\n      conn[kQueue].delete(operationDescription.requestId);\r\n      operationDescription.cb(e);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if (operationDescription.noResponse) {\r\n    operationDescription.cb();\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}