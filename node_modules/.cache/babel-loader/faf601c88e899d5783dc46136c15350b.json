{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FindCursor = exports.FLAGS = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst count_1 = require(\"../operations/count\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst find_1 = require(\"../operations/find\");\n\nconst sort_1 = require(\"../sort\");\n\nconst utils_1 = require(\"../utils\");\n\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\n\n\nconst kFilter = Symbol('filter');\n/** @internal */\n\nconst kNumReturned = Symbol('numReturned');\n/** @internal */\n\nconst kBuiltOptions = Symbol('builtOptions');\n/** @public Flags allowed for cursor */\n\nexports.FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\n\nclass FindCursor extends abstract_cursor_1.AbstractCursor {\n  /** @internal */\n  constructor(topology, namespace, filter) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(topology, namespace, options);\n    this[kFilter] = filter || {};\n    this[kBuiltOptions] = options;\n\n    if (options.sort != null) {\n      this[kBuiltOptions].sort = (0, sort_1.formatSort)(options.sort);\n    }\n  }\n\n  clone() {\n    const clonedOptions = (0, utils_1.mergeOptions)({}, this[kBuiltOptions]);\n    delete clonedOptions.session;\n    return new FindCursor(this.topology, this.namespace, this[kFilter], { ...clonedOptions\n    });\n  }\n\n  map(transform) {\n    return super.map(transform);\n  }\n  /** @internal */\n\n\n  _initialize(session, callback) {\n    const findOperation = new find_1.FindOperation(undefined, this.namespace, this[kFilter], { ...this[kBuiltOptions],\n      ...this.cursorOptions,\n      session\n    });\n    (0, execute_operation_1.executeOperation)(this, findOperation, (err, response) => {\n      if (err || response == null) return callback(err); // TODO: We only need this for legacy queries that do not support `limit`, maybe\n      //       the value should only be saved in those cases.\n\n      if (response.cursor) {\n        this[kNumReturned] = response.cursor.firstBatch.length;\n      } else {\n        this[kNumReturned] = response.documents ? response.documents.length : 0;\n      } // TODO: NODE-2882\n\n\n      callback(undefined, {\n        server: findOperation.server,\n        session,\n        response\n      });\n    });\n  }\n  /** @internal */\n\n\n  _getMore(batchSize, callback) {\n    // NOTE: this is to support client provided limits in pre-command servers\n    const numReturned = this[kNumReturned];\n\n    if (numReturned) {\n      const limit = this[kBuiltOptions].limit;\n      batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;\n\n      if (batchSize <= 0) {\n        return this.close(callback);\n      }\n    }\n\n    super._getMore(batchSize, (err, response) => {\n      if (err) return callback(err); // TODO: wrap this in some logic to prevent it from happening if we don't need this support\n\n      if (response) {\n        this[kNumReturned] = this[kNumReturned] + response.cursor.nextBatch.length;\n      }\n\n      callback(undefined, response);\n    });\n  }\n\n  count(options, callback) {\n    (0, utils_1.emitWarningOnce)('cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ');\n\n    if (typeof options === 'boolean') {\n      throw new error_1.MongoInvalidArgumentError('Invalid first parameter to count');\n    }\n\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return (0, execute_operation_1.executeOperation)(this, new count_1.CountOperation(this.namespace, this[kFilter], { ...this[kBuiltOptions],\n      ...this.cursorOptions,\n      ...options\n    }), callback);\n  }\n\n  explain(verbosity, callback) {\n    if (typeof verbosity === 'function') callback = verbosity, verbosity = true;\n    if (verbosity == null) verbosity = true;\n    return (0, execute_operation_1.executeOperation)(this, new find_1.FindOperation(undefined, this.namespace, this[kFilter], { ...this[kBuiltOptions],\n      ...this.cursorOptions,\n      explain: verbosity\n    }), callback);\n  }\n  /** Set the cursor query */\n\n\n  filter(filter) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kFilter] = filter;\n    return this;\n  }\n  /**\r\n   * Set the cursor hint\r\n   *\r\n   * @param hint - If specified, then the query system will only consider plans using the hinted index.\r\n   */\n\n\n  hint(hint) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kBuiltOptions].hint = hint;\n    return this;\n  }\n  /**\r\n   * Set the cursor min\r\n   *\r\n   * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.\r\n   */\n\n\n  min(min) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kBuiltOptions].min = min;\n    return this;\n  }\n  /**\r\n   * Set the cursor max\r\n   *\r\n   * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.\r\n   */\n\n\n  max(max) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kBuiltOptions].max = max;\n    return this;\n  }\n  /**\r\n   * Set the cursor returnKey.\r\n   * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.\r\n   * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.\r\n   *\r\n   * @param value - the returnKey value.\r\n   */\n\n\n  returnKey(value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kBuiltOptions].returnKey = value;\n    return this;\n  }\n  /**\r\n   * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.\r\n   *\r\n   * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.\r\n   */\n\n\n  showRecordId(value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kBuiltOptions].showRecordId = value;\n    return this;\n  }\n  /**\r\n   * Add a query modifier to the cursor query\r\n   *\r\n   * @param name - The query modifier (must start with $, such as $orderby etc)\r\n   * @param value - The modifier value.\r\n   */\n\n\n  addQueryModifier(name, value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n\n    if (name[0] !== '$') {\n      throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);\n    } // Strip of the $\n\n\n    const field = name.substr(1); // NOTE: consider some TS magic for this\n\n    switch (field) {\n      case 'comment':\n        this[kBuiltOptions].comment = value;\n        break;\n\n      case 'explain':\n        this[kBuiltOptions].explain = value;\n        break;\n\n      case 'hint':\n        this[kBuiltOptions].hint = value;\n        break;\n\n      case 'max':\n        this[kBuiltOptions].max = value;\n        break;\n\n      case 'maxTimeMS':\n        this[kBuiltOptions].maxTimeMS = value;\n        break;\n\n      case 'min':\n        this[kBuiltOptions].min = value;\n        break;\n\n      case 'orderby':\n        this[kBuiltOptions].sort = (0, sort_1.formatSort)(value);\n        break;\n\n      case 'query':\n        this[kFilter] = value;\n        break;\n\n      case 'returnKey':\n        this[kBuiltOptions].returnKey = value;\n        break;\n\n      case 'showDiskLoc':\n        this[kBuiltOptions].showRecordId = value;\n        break;\n\n      default:\n        throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);\n    }\n\n    return this;\n  }\n  /**\r\n   * Add a comment to the cursor query allowing for tracking the comment in the log.\r\n   *\r\n   * @param value - The comment attached to this query.\r\n   */\n\n\n  comment(value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kBuiltOptions].comment = value;\n    return this;\n  }\n  /**\r\n   * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)\r\n   *\r\n   * @param value - Number of milliseconds to wait before aborting the tailed query.\r\n   */\n\n\n  maxAwaitTimeMS(value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxAwaitTimeMS must be a number');\n    }\n\n    this[kBuiltOptions].maxAwaitTimeMS = value;\n    return this;\n  }\n  /**\r\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\r\n   *\r\n   * @param value - Number of milliseconds to wait before aborting the query.\r\n   */\n\n\n  maxTimeMS(value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this[kBuiltOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\r\n   * Add a project stage to the aggregation pipeline\r\n   *\r\n   * @remarks\r\n   * In order to strictly type this function you must provide an interface\r\n   * that represents the effect of your projection on the result documents.\r\n   *\r\n   * By default chaining a projection to your cursor changes the returned type to the generic\r\n   * {@link Document} type.\r\n   * You should specify a parameterized type to have assertions on your final results.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Best way\r\n   * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\r\n   * // Flexible way\r\n   * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });\r\n   * ```\r\n   *\r\n   * @remarks\r\n   *\r\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\r\n   * it **does not** return a new instance of a cursor. This means when calling project,\r\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\r\n   * Take note of the following example:\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const cursor: FindCursor<{ a: number; b: string }> = coll.find();\r\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\r\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\r\n   *\r\n   * // or always use chaining and save the final cursor\r\n   *\r\n   * const cursor = coll.find().project<{ a: string }>({\r\n   *   _id: 0,\r\n   *   a: { $convert: { input: '$a', to: 'string' }\r\n   * }});\r\n   * ```\r\n   */\n\n\n  project(value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kBuiltOptions].projection = value;\n    return this;\n  }\n  /**\r\n   * Sets the sort order of the cursor query.\r\n   *\r\n   * @param sort - The key or keys set for the sort.\r\n   * @param direction - The direction of the sorting (1 or -1).\r\n   */\n\n\n  sort(sort, direction) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n\n    if (this[kBuiltOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support sorting');\n    }\n\n    this[kBuiltOptions].sort = (0, sort_1.formatSort)(sort, direction);\n    return this;\n  }\n  /**\r\n   * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)\r\n   *\r\n   * @remarks\r\n   * {@link https://docs.mongodb.com/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}\r\n   */\n\n\n  allowDiskUse() {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n\n    if (!this[kBuiltOptions].sort) {\n      throw new error_1.MongoInvalidArgumentError('Option \"allowDiskUse\" requires a sort specification');\n    }\n\n    this[kBuiltOptions].allowDiskUse = true;\n    return this;\n  }\n  /**\r\n   * Set the collation options for the cursor.\r\n   *\r\n   * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\r\n   */\n\n\n  collation(value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n    this[kBuiltOptions].collation = value;\n    return this;\n  }\n  /**\r\n   * Set the limit for the cursor.\r\n   *\r\n   * @param value - The limit for the cursor query.\r\n   */\n\n\n  limit(value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n\n    if (this[kBuiltOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support limit');\n    }\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"limit\" requires an integer');\n    }\n\n    this[kBuiltOptions].limit = value;\n    return this;\n  }\n  /**\r\n   * Set the skip for the cursor.\r\n   *\r\n   * @param value - The skip for the cursor query.\r\n   */\n\n\n  skip(value) {\n    (0, abstract_cursor_1.assertUninitialized)(this);\n\n    if (this[kBuiltOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support skip');\n    }\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"skip\" requires an integer');\n    }\n\n    this[kBuiltOptions].skip = value;\n    return this;\n  }\n\n}\n\nexports.FindCursor = FindCursor;","map":{"version":3,"mappings":"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","names":["kFilter","Symbol","kNumReturned","kBuiltOptions","exports","FindCursor","abstract_cursor_1","constructor","topology","namespace","filter","options","sort","clone","clonedOptions","session","map","transform","_initialize","callback","findOperation","find_1","undefined","cursorOptions","err","response","cursor","firstBatch","length","documents","server","_getMore","batchSize","numReturned","limit","close","nextBatch","count","error_1","count_1","explain","verbosity","hint","min","max","returnKey","value","showRecordId","addQueryModifier","name","field","substr","comment","maxTimeMS","maxAwaitTimeMS","project","projection","direction","tailable","allowDiskUse","collation","skip"],"sources":["D:\\Barcelparts\\node_modules\\mongodb\\src\\cursor\\find_cursor.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport { MongoInvalidArgumentError, MongoTailableCursorError } from '../error';\r\nimport type { ExplainVerbosityLike } from '../explain';\r\nimport type { CollationOptions } from '../operations/command';\r\nimport { CountOperation, CountOptions } from '../operations/count';\r\nimport { executeOperation, ExecutionResult } from '../operations/execute_operation';\r\nimport { FindOperation, FindOptions } from '../operations/find';\r\nimport type { Hint } from '../operations/operation';\r\nimport type { Topology } from '../sdam/topology';\r\nimport type { ClientSession } from '../sessions';\r\nimport { formatSort, Sort, SortDirection } from '../sort';\r\nimport { Callback, emitWarningOnce, mergeOptions, MongoDBNamespace } from '../utils';\r\nimport { AbstractCursor, assertUninitialized } from './abstract_cursor';\r\n\r\n/** @internal */\r\nconst kFilter = Symbol('filter');\r\n/** @internal */\r\nconst kNumReturned = Symbol('numReturned');\r\n/** @internal */\r\nconst kBuiltOptions = Symbol('builtOptions');\r\n\r\n/** @public Flags allowed for cursor */\r\nexport const FLAGS = [\r\n  'tailable',\r\n  'oplogReplay',\r\n  'noCursorTimeout',\r\n  'awaitData',\r\n  'exhaust',\r\n  'partial'\r\n] as const;\r\n\r\n/** @public */\r\nexport class FindCursor<TSchema = any> extends AbstractCursor<TSchema> {\r\n  /** @internal */\r\n  [kFilter]: Document;\r\n  /** @internal */\r\n  [kNumReturned]?: number;\r\n  /** @internal */\r\n  [kBuiltOptions]: FindOptions;\r\n\r\n  /** @internal */\r\n  constructor(\r\n    topology: Topology,\r\n    namespace: MongoDBNamespace,\r\n    filter: Document | undefined,\r\n    options: FindOptions = {}\r\n  ) {\r\n    super(topology, namespace, options);\r\n\r\n    this[kFilter] = filter || {};\r\n    this[kBuiltOptions] = options;\r\n\r\n    if (options.sort != null) {\r\n      this[kBuiltOptions].sort = formatSort(options.sort);\r\n    }\r\n  }\r\n\r\n  clone(): FindCursor<TSchema> {\r\n    const clonedOptions = mergeOptions({}, this[kBuiltOptions]);\r\n    delete clonedOptions.session;\r\n    return new FindCursor(this.topology, this.namespace, this[kFilter], {\r\n      ...clonedOptions\r\n    });\r\n  }\r\n\r\n  override map<T>(transform: (doc: TSchema) => T): FindCursor<T> {\r\n    return super.map(transform) as FindCursor<T>;\r\n  }\r\n\r\n  /** @internal */\r\n  _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void {\r\n    const findOperation = new FindOperation(undefined, this.namespace, this[kFilter], {\r\n      ...this[kBuiltOptions], // NOTE: order matters here, we may need to refine this\r\n      ...this.cursorOptions,\r\n      session\r\n    });\r\n\r\n    executeOperation(this, findOperation, (err, response) => {\r\n      if (err || response == null) return callback(err);\r\n\r\n      // TODO: We only need this for legacy queries that do not support `limit`, maybe\r\n      //       the value should only be saved in those cases.\r\n      if (response.cursor) {\r\n        this[kNumReturned] = response.cursor.firstBatch.length;\r\n      } else {\r\n        this[kNumReturned] = response.documents ? response.documents.length : 0;\r\n      }\r\n\r\n      // TODO: NODE-2882\r\n      callback(undefined, { server: findOperation.server, session, response });\r\n    });\r\n  }\r\n\r\n  /** @internal */\r\n  override _getMore(batchSize: number, callback: Callback<Document>): void {\r\n    // NOTE: this is to support client provided limits in pre-command servers\r\n    const numReturned = this[kNumReturned];\r\n    if (numReturned) {\r\n      const limit = this[kBuiltOptions].limit;\r\n      batchSize =\r\n        limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;\r\n\r\n      if (batchSize <= 0) {\r\n        return this.close(callback);\r\n      }\r\n    }\r\n\r\n    super._getMore(batchSize, (err, response) => {\r\n      if (err) return callback(err);\r\n\r\n      // TODO: wrap this in some logic to prevent it from happening if we don't need this support\r\n      if (response) {\r\n        this[kNumReturned] = this[kNumReturned] + response.cursor.nextBatch.length;\r\n      }\r\n\r\n      callback(undefined, response);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the count of documents for this cursor\r\n   * @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead\r\n   */\r\n  count(): Promise<number>;\r\n  /** @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead */\r\n  count(callback: Callback<number>): void;\r\n  /** @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead */\r\n  count(options: CountOptions): Promise<number>;\r\n  /** @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead */\r\n  count(options: CountOptions, callback: Callback<number>): void;\r\n  count(\r\n    options?: CountOptions | Callback<number>,\r\n    callback?: Callback<number>\r\n  ): Promise<number> | void {\r\n    emitWarningOnce(\r\n      'cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead '\r\n    );\r\n    if (typeof options === 'boolean') {\r\n      throw new MongoInvalidArgumentError('Invalid first parameter to count');\r\n    }\r\n\r\n    if (typeof options === 'function') (callback = options), (options = {});\r\n    options = options ?? {};\r\n\r\n    return executeOperation(\r\n      this,\r\n      new CountOperation(this.namespace, this[kFilter], {\r\n        ...this[kBuiltOptions], // NOTE: order matters here, we may need to refine this\r\n        ...this.cursorOptions,\r\n        ...options\r\n      }),\r\n      callback\r\n    );\r\n  }\r\n\r\n  /** Execute the explain for the cursor */\r\n  explain(): Promise<Document>;\r\n  explain(callback: Callback): void;\r\n  explain(verbosity?: ExplainVerbosityLike): Promise<Document>;\r\n  explain(\r\n    verbosity?: ExplainVerbosityLike | Callback,\r\n    callback?: Callback<Document>\r\n  ): Promise<Document> | void {\r\n    if (typeof verbosity === 'function') (callback = verbosity), (verbosity = true);\r\n    if (verbosity == null) verbosity = true;\r\n\r\n    return executeOperation(\r\n      this,\r\n      new FindOperation(undefined, this.namespace, this[kFilter], {\r\n        ...this[kBuiltOptions], // NOTE: order matters here, we may need to refine this\r\n        ...this.cursorOptions,\r\n        explain: verbosity\r\n      }),\r\n      callback\r\n    );\r\n  }\r\n\r\n  /** Set the cursor query */\r\n  filter(filter: Document): this {\r\n    assertUninitialized(this);\r\n    this[kFilter] = filter;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the cursor hint\r\n   *\r\n   * @param hint - If specified, then the query system will only consider plans using the hinted index.\r\n   */\r\n  hint(hint: Hint): this {\r\n    assertUninitialized(this);\r\n    this[kBuiltOptions].hint = hint;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the cursor min\r\n   *\r\n   * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.\r\n   */\r\n  min(min: Document): this {\r\n    assertUninitialized(this);\r\n    this[kBuiltOptions].min = min;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the cursor max\r\n   *\r\n   * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.\r\n   */\r\n  max(max: Document): this {\r\n    assertUninitialized(this);\r\n    this[kBuiltOptions].max = max;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the cursor returnKey.\r\n   * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.\r\n   * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.\r\n   *\r\n   * @param value - the returnKey value.\r\n   */\r\n  returnKey(value: boolean): this {\r\n    assertUninitialized(this);\r\n    this[kBuiltOptions].returnKey = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.\r\n   *\r\n   * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.\r\n   */\r\n  showRecordId(value: boolean): this {\r\n    assertUninitialized(this);\r\n    this[kBuiltOptions].showRecordId = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a query modifier to the cursor query\r\n   *\r\n   * @param name - The query modifier (must start with $, such as $orderby etc)\r\n   * @param value - The modifier value.\r\n   */\r\n  addQueryModifier(name: string, value: string | boolean | number | Document): this {\r\n    assertUninitialized(this);\r\n    if (name[0] !== '$') {\r\n      throw new MongoInvalidArgumentError(`${name} is not a valid query modifier`);\r\n    }\r\n\r\n    // Strip of the $\r\n    const field = name.substr(1);\r\n\r\n    // NOTE: consider some TS magic for this\r\n    switch (field) {\r\n      case 'comment':\r\n        this[kBuiltOptions].comment = value as string | Document;\r\n        break;\r\n\r\n      case 'explain':\r\n        this[kBuiltOptions].explain = value as boolean;\r\n        break;\r\n\r\n      case 'hint':\r\n        this[kBuiltOptions].hint = value as string | Document;\r\n        break;\r\n\r\n      case 'max':\r\n        this[kBuiltOptions].max = value as Document;\r\n        break;\r\n\r\n      case 'maxTimeMS':\r\n        this[kBuiltOptions].maxTimeMS = value as number;\r\n        break;\r\n\r\n      case 'min':\r\n        this[kBuiltOptions].min = value as Document;\r\n        break;\r\n\r\n      case 'orderby':\r\n        this[kBuiltOptions].sort = formatSort(value as string | Document);\r\n        break;\r\n\r\n      case 'query':\r\n        this[kFilter] = value as Document;\r\n        break;\r\n\r\n      case 'returnKey':\r\n        this[kBuiltOptions].returnKey = value as boolean;\r\n        break;\r\n\r\n      case 'showDiskLoc':\r\n        this[kBuiltOptions].showRecordId = value as boolean;\r\n        break;\r\n\r\n      default:\r\n        throw new MongoInvalidArgumentError(`Invalid query modifier: ${name}`);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a comment to the cursor query allowing for tracking the comment in the log.\r\n   *\r\n   * @param value - The comment attached to this query.\r\n   */\r\n  comment(value: string): this {\r\n    assertUninitialized(this);\r\n    this[kBuiltOptions].comment = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)\r\n   *\r\n   * @param value - Number of milliseconds to wait before aborting the tailed query.\r\n   */\r\n  maxAwaitTimeMS(value: number): this {\r\n    assertUninitialized(this);\r\n    if (typeof value !== 'number') {\r\n      throw new MongoInvalidArgumentError('Argument for maxAwaitTimeMS must be a number');\r\n    }\r\n\r\n    this[kBuiltOptions].maxAwaitTimeMS = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\r\n   *\r\n   * @param value - Number of milliseconds to wait before aborting the query.\r\n   */\r\n  override maxTimeMS(value: number): this {\r\n    assertUninitialized(this);\r\n    if (typeof value !== 'number') {\r\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\r\n    }\r\n\r\n    this[kBuiltOptions].maxTimeMS = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a project stage to the aggregation pipeline\r\n   *\r\n   * @remarks\r\n   * In order to strictly type this function you must provide an interface\r\n   * that represents the effect of your projection on the result documents.\r\n   *\r\n   * By default chaining a projection to your cursor changes the returned type to the generic\r\n   * {@link Document} type.\r\n   * You should specify a parameterized type to have assertions on your final results.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Best way\r\n   * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\r\n   * // Flexible way\r\n   * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });\r\n   * ```\r\n   *\r\n   * @remarks\r\n   *\r\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\r\n   * it **does not** return a new instance of a cursor. This means when calling project,\r\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\r\n   * Take note of the following example:\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const cursor: FindCursor<{ a: number; b: string }> = coll.find();\r\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\r\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\r\n   *\r\n   * // or always use chaining and save the final cursor\r\n   *\r\n   * const cursor = coll.find().project<{ a: string }>({\r\n   *   _id: 0,\r\n   *   a: { $convert: { input: '$a', to: 'string' }\r\n   * }});\r\n   * ```\r\n   */\r\n  project<T extends Document = Document>(value: Document): FindCursor<T> {\r\n    assertUninitialized(this);\r\n    this[kBuiltOptions].projection = value;\r\n    return this as unknown as FindCursor<T>;\r\n  }\r\n\r\n  /**\r\n   * Sets the sort order of the cursor query.\r\n   *\r\n   * @param sort - The key or keys set for the sort.\r\n   * @param direction - The direction of the sorting (1 or -1).\r\n   */\r\n  sort(sort: Sort | string, direction?: SortDirection): this {\r\n    assertUninitialized(this);\r\n    if (this[kBuiltOptions].tailable) {\r\n      throw new MongoTailableCursorError('Tailable cursor does not support sorting');\r\n    }\r\n\r\n    this[kBuiltOptions].sort = formatSort(sort, direction);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)\r\n   *\r\n   * @remarks\r\n   * {@link https://docs.mongodb.com/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}\r\n   */\r\n  allowDiskUse(): this {\r\n    assertUninitialized(this);\r\n    if (!this[kBuiltOptions].sort) {\r\n      throw new MongoInvalidArgumentError('Option \"allowDiskUse\" requires a sort specification');\r\n    }\r\n    this[kBuiltOptions].allowDiskUse = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the collation options for the cursor.\r\n   *\r\n   * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\r\n   */\r\n  collation(value: CollationOptions): this {\r\n    assertUninitialized(this);\r\n    this[kBuiltOptions].collation = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the limit for the cursor.\r\n   *\r\n   * @param value - The limit for the cursor query.\r\n   */\r\n  limit(value: number): this {\r\n    assertUninitialized(this);\r\n    if (this[kBuiltOptions].tailable) {\r\n      throw new MongoTailableCursorError('Tailable cursor does not support limit');\r\n    }\r\n\r\n    if (typeof value !== 'number') {\r\n      throw new MongoInvalidArgumentError('Operation \"limit\" requires an integer');\r\n    }\r\n\r\n    this[kBuiltOptions].limit = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the skip for the cursor.\r\n   *\r\n   * @param value - The skip for the cursor query.\r\n   */\r\n  skip(value: number): this {\r\n    assertUninitialized(this);\r\n    if (this[kBuiltOptions].tailable) {\r\n      throw new MongoTailableCursorError('Tailable cursor does not support skip');\r\n    }\r\n\r\n    if (typeof value !== 'number') {\r\n      throw new MongoInvalidArgumentError('Operation \"skip\" requires an integer');\r\n    }\r\n\r\n    this[kBuiltOptions].skip = value;\r\n    return this;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}